{"config":{"lang":["en"],"separator":"[\\s\\-\\.]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Ralph Orchestrator","text":"## Production-Ready AI Orchestration  *Put your AI agent in a loop until the task is done*  [![Version](https://img.shields.io/badge/version-1.0.0-blue)](https://github.com/mikeyobrien/ralph-orchestrator/releases) [![License](https://img.shields.io/badge/license-MIT-green)](LICENSE) [![Tests](https://img.shields.io/badge/tests-18%20passing-brightgreen)](tests/) [![Python](https://img.shields.io/badge/python-3.8%2B-blue)](https://www.python.org/)  &gt; \"Me fail English? That's unpossible!\" - Ralph Wiggum"},{"location":"#what-is-ralph-orchestrator","title":"What is Ralph Orchestrator?","text":"<p>Ralph Orchestrator is a production-ready implementation of the Ralph Wiggum orchestration technique - a simple yet powerful pattern for autonomous AI task completion. It continuously runs an AI agent against a prompt file until the task is marked as complete or limits are reached.</p> <p>Based on the technique by Geoffrey Huntley, this implementation provides enterprise-grade safety, monitoring, and cost controls suitable for production environments.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li> <p>\ud83e\udd16 Multi-Agent Support   Works seamlessly with Claude, Q Chat, and Gemini CLI tools with automatic detection</p> </li> <li> <p>\ud83d\udcb0 Cost Management   Real-time token tracking, cost calculation, and configurable spending limits</p> </li> <li> <p>\ud83d\udd12 Enterprise Security   Input sanitization, command injection prevention, and path traversal protection</p> </li> <li> <p>\ud83d\udcca Production Monitoring   System metrics, performance tracking, and detailed JSON exports</p> </li> <li> <p>\ud83d\udd04 Resilient Execution   Automatic retries, circuit breakers, and state persistence</p> </li> <li> <p>\ud83d\udcbe Git Checkpointing   Version control integration for state recovery and history tracking</p> </li> </ul>"},{"location":"#quick-example","title":"Quick Example","text":"<pre><code># 1. Create a task prompt\ncat &gt; PROMPT.md &lt;&lt; EOF\nCreate a Python function that calculates the Fibonacci sequence.\nInclude proper documentation and unit tests.\nWhen complete, add \"TASK_COMPLETE\" to this file.\nEOF\n\n# 2. Run Ralph\npython ralph_orchestrator.py --prompt PROMPT.md\n\n# 3. Ralph iterates until the task is done!\n</code></pre>"},{"location":"#why-ralph-orchestrator","title":"Why Ralph Orchestrator?","text":""},{"location":"#the-problem","title":"The Problem","text":"<p>Modern AI agents are powerful but require supervision. They can lose context, make mistakes, or need multiple iterations to complete complex tasks. Manual supervision is time-consuming and error-prone.</p>"},{"location":"#the-solution","title":"The Solution","text":"<p>Ralph Orchestrator automates the iteration loop while maintaining safety and control:</p> <ul> <li>Autonomous Operation: Set it and forget it - Ralph handles the iterations</li> <li>Safety First: Built-in limits prevent runaway costs and infinite loops</li> <li>Production Ready: Battle-tested with comprehensive error handling</li> <li>Observable: Detailed metrics and logging for debugging and optimization</li> <li>Recoverable: Checkpoint system allows resuming from any point</li> </ul>"},{"location":"#use-cases","title":"Use Cases","text":"<p>Ralph Orchestrator excels at:</p> <ul> <li>Code Generation: Building features, fixing bugs, writing tests</li> <li>Documentation: Creating comprehensive docs, API references, tutorials</li> <li>Data Processing: ETL pipelines, data analysis, report generation</li> <li>Automation: CI/CD setup, deployment scripts, infrastructure as code</li> <li>Research: Information gathering, summarization, analysis</li> </ul>"},{"location":"#getting-started","title":"Getting Started","text":"<p>Ready to put Ralph to work? Check out our Quick Start Guide to get up and running in minutes.</p>"},{"location":"#production-features","title":"Production Features","text":"<p>Ralph Orchestrator is designed for production use with:</p> <ul> <li>Token &amp; Cost Limits: Prevent budget overruns</li> <li>Context Management: Handle large prompts intelligently</li> <li>Security Controls: Protect against malicious inputs</li> <li>Monitoring &amp; Metrics: Track performance and usage</li> <li>Error Recovery: Graceful handling of failures</li> <li>State Persistence: Resume interrupted tasks</li> </ul> <p>Learn more in our Production Deployment Guide.</p>"},{"location":"#community-support","title":"Community &amp; Support","text":"<ul> <li>\ud83d\udcd6 Documentation</li> <li>\ud83d\udc1b Issue Tracker</li> <li>\ud83d\udcac Discussions</li> <li>\ud83e\udd1d Contributing Guide</li> </ul>"},{"location":"#license","title":"License","text":"<p>Ralph Orchestrator is open source software licensed as MIT.</p> Built with \u2764\ufe0f by the Ralph Orchestrator community"},{"location":"changelog/","title":"Changelog","text":"<p>All notable changes to Ralph Orchestrator will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p>"},{"location":"changelog/#unreleased","title":"[Unreleased]","text":""},{"location":"changelog/#added","title":"Added","text":"<ul> <li>Documentation static site with MkDocs</li> <li>Comprehensive API reference documentation</li> <li>Additional example scenarios</li> <li>Performance monitoring tools</li> </ul>"},{"location":"changelog/#changed","title":"Changed","text":"<ul> <li>Improved error handling in agent execution</li> <li>Enhanced checkpoint creation logic</li> </ul>"},{"location":"changelog/#fixed","title":"Fixed","text":"<ul> <li>Race condition in state file updates</li> <li>Memory leak in long-running sessions</li> </ul>"},{"location":"changelog/#103-2025-09-07","title":"[1.0.3] - 2025-09-07","text":""},{"location":"changelog/#added_1","title":"Added","text":"<ul> <li>Production deployment guide</li> <li>Docker support with Dockerfile and docker-compose.yml</li> <li>Kubernetes deployment manifests</li> <li>Health check endpoint for monitoring</li> </ul>"},{"location":"changelog/#changed_1","title":"Changed","text":"<ul> <li>Improved resource limit handling</li> <li>Enhanced logging with structured JSON output</li> <li>Updated dependencies to latest versions</li> </ul>"},{"location":"changelog/#fixed_1","title":"Fixed","text":"<ul> <li>Git checkpoint creation on Windows</li> <li>Agent timeout handling in edge cases</li> </ul>"},{"location":"changelog/#102-2025-09-07","title":"[1.0.2] - 2025-09-07","text":""},{"location":"changelog/#added_2","title":"Added","text":"<ul> <li>Q Chat integration improvements</li> <li>Real-time metrics collection</li> <li>Interactive CLI mode</li> <li>Bash and ZSH completion scripts</li> </ul>"},{"location":"changelog/#changed_2","title":"Changed","text":"<ul> <li>Refactored agent manager for better extensibility</li> <li>Improved context window management</li> <li>Enhanced progress reporting</li> </ul>"},{"location":"changelog/#fixed_2","title":"Fixed","text":"<ul> <li>Unicode handling in prompt files</li> <li>State persistence across interruptions</li> </ul>"},{"location":"changelog/#101-2025-09-07","title":"[1.0.1] - 2025-09-07","text":""},{"location":"changelog/#added_3","title":"Added","text":"<ul> <li>Gemini CLI integration</li> <li>Advanced context management strategies</li> <li>Cost tracking and estimation</li> <li>HTML report generation</li> </ul>"},{"location":"changelog/#changed_3","title":"Changed","text":"<ul> <li>Optimized iteration performance</li> <li>Improved error recovery mechanisms</li> <li>Enhanced Git operations</li> </ul>"},{"location":"changelog/#fixed_3","title":"Fixed","text":"<ul> <li>Agent detection on macOS</li> <li>Prompt archiving with special characters</li> <li>Checkpoint interval calculation</li> </ul>"},{"location":"changelog/#100-2025-09-07","title":"[1.0.0] - 2025-09-07","text":""},{"location":"changelog/#added_4","title":"Added","text":"<ul> <li>Initial release with core functionality</li> <li>Claude CLI integration</li> <li>Q Chat integration</li> <li>Git-based checkpointing</li> <li>Prompt archiving</li> <li>State persistence</li> <li>Comprehensive test suite</li> <li>CLI wrapper script</li> <li>Configuration management</li> <li>Metrics collection</li> </ul>"},{"location":"changelog/#features","title":"Features","text":"<ul> <li>Auto-detection of available AI agents</li> <li>Configurable iteration and runtime limits</li> <li>Error recovery with exponential backoff</li> <li>Verbose and dry-run modes</li> <li>JSON configuration file support</li> <li>Environment variable configuration</li> </ul>"},{"location":"changelog/#documentation","title":"Documentation","text":"<ul> <li>Complete README with examples</li> <li>Installation instructions</li> <li>Usage guide</li> <li>API documentation</li> <li>Contributing guidelines</li> </ul>"},{"location":"changelog/#090-2025-09-06-beta","title":"[0.9.0] - 2025-09-06 (Beta)","text":""},{"location":"changelog/#added_5","title":"Added","text":"<ul> <li>Beta release for testing</li> <li>Basic orchestration loop</li> <li>Claude integration</li> <li>Simple checkpointing</li> </ul>"},{"location":"changelog/#known-issues","title":"Known Issues","text":"<ul> <li>Limited error handling</li> <li>No metrics collection</li> <li>Single agent support only</li> </ul>"},{"location":"changelog/#050-2025-09-05-alpha","title":"[0.5.0] - 2025-09-05 (Alpha)","text":""},{"location":"changelog/#added_6","title":"Added","text":"<ul> <li>Initial alpha release</li> <li>Proof of concept implementation</li> <li>Basic Ralph loop</li> <li>Manual testing only</li> </ul>"},{"location":"changelog/#version-history-summary","title":"Version History Summary","text":""},{"location":"changelog/#major-versions","title":"Major Versions","text":"<ul> <li>1.0.0 - First stable release with full feature set</li> <li>0.9.0 - Beta release for community testing</li> <li>0.5.0 - Alpha proof of concept</li> </ul>"},{"location":"changelog/#versioning-policy","title":"Versioning Policy","text":"<p>We use Semantic Versioning (SemVer): - MAJOR version for incompatible API changes - MINOR version for backwards-compatible functionality additions - PATCH version for backwards-compatible bug fixes</p>"},{"location":"changelog/#deprecation-policy","title":"Deprecation Policy","text":"<p>Features marked for deprecation will: 1. Be documented in the changelog 2. Show deprecation warnings for 2 minor versions 3. Be removed in the next major version</p>"},{"location":"changelog/#support-policy","title":"Support Policy","text":"<ul> <li>Current version: Full support with bug fixes and features</li> <li>Previous minor version: Bug fixes only</li> <li>Older versions: Community support only</li> </ul>"},{"location":"changelog/#upgrade-guide","title":"Upgrade Guide","text":""},{"location":"changelog/#from-0x-to-10","title":"From 0.x to 1.0","text":"<ol> <li>Configuration Changes</li> <li>Old: <code>max_iter</code> \u2192 New: <code>max_iterations</code></li> <li> <p>Old: <code>agent_name</code> \u2192 New: <code>agent</code></p> </li> <li> <p>API Changes</p> </li> <li><code>RalphOrchestrator.execute()</code> \u2192 <code>RalphOrchestrator.run()</code></li> <li> <p>Return format changed from tuple to dictionary</p> </li> <li> <p>File Structure</p> </li> <li>State files moved from <code>.ralph/</code> to <code>.agent/metrics/</code></li> <li>Checkpoint format updated</li> </ol>"},{"location":"changelog/#migration-script","title":"Migration Script","text":"<pre><code>#!/bin/bash\n# Migrate from 0.x to 1.0\n\n# Backup old data\ncp -r .ralph .ralph.backup\n\n# Create new structure\nmkdir -p .agent/metrics .agent/prompts .agent/checkpoints\n\n# Migrate state files\nmv .ralph/*.json .agent/metrics/ 2&gt;/dev/null\n\n# Update configuration\nif [ -f \"ralph.conf\" ]; then\n    python -c \"\nimport json\nwith open('ralph.conf') as f:\n    old_config = json.load(f)\n# Update keys\nold_config['max_iterations'] = old_config.pop('max_iter', 100)\nold_config['agent'] = old_config.pop('agent_name', 'auto')\n# Save new config\nwith open('ralph.json', 'w') as f:\n    json.dump(old_config, f, indent=2)\n\"\nfi\n\necho \"Migration complete!\"\n</code></pre>"},{"location":"changelog/#release-process","title":"Release Process","text":""},{"location":"changelog/#1-pre-release-checklist","title":"1. Pre-release Checklist","text":"<ul> <li> All tests passing</li> <li> Documentation updated</li> <li> Changelog updated</li> <li> Version bumped in setup.py</li> <li> README examples tested</li> </ul>"},{"location":"changelog/#2-release-steps","title":"2. Release Steps","text":"<pre><code># 1. Update version\nvim setup.py  # Update version number\n\n# 2. Commit changes\ngit add -A\ngit commit -m \"Release version X.Y.Z\"\n\n# 3. Tag release\ngit tag -a vX.Y.Z -m \"Version X.Y.Z\"\n\n# 4. Push to GitHub\ngit push origin main --tags\n\n# 5. Create GitHub release\ngh release create vX.Y.Z --title \"Version X.Y.Z\" --notes-file RELEASE_NOTES.md\n\n# 6. Publish to PyPI (if applicable)\npython setup.py sdist bdist_wheel\ntwine upload dist/*\n</code></pre>"},{"location":"changelog/#3-post-release","title":"3. Post-release","text":"<ul> <li> Announce on social media</li> <li> Update documentation site</li> <li> Close related issues</li> <li> Plan next release</li> </ul>"},{"location":"changelog/#contributors","title":"Contributors","text":"<p>Thanks to all contributors who have helped improve Ralph Orchestrator:</p> <ul> <li>Geoffrey Huntley (@ghuntley) - Original Ralph Wiggum technique</li> <li>Community contributors via GitHub</li> </ul>"},{"location":"changelog/#how-to-contribute","title":"How to Contribute","text":"<p>See CONTRIBUTING.md for details on: - Reporting bugs - Suggesting features - Submitting pull requests - Development setup</p>"},{"location":"changelog/#links","title":"Links","text":"<ul> <li>GitHub Repository</li> <li>Issue Tracker</li> <li>Discussions</li> <li>Documentation</li> </ul>"},{"location":"contributing/","title":"Contributing to Ralph Orchestrator","text":"<p>Thank you for your interest in contributing to Ralph Orchestrator! This guide will help you get started with contributing to the project.</p>"},{"location":"contributing/#code-of-conduct","title":"Code of Conduct","text":"<p>By participating in this project, you agree to abide by our Code of Conduct. Please read it before contributing.</p>"},{"location":"contributing/#ways-to-contribute","title":"Ways to Contribute","text":""},{"location":"contributing/#1-report-bugs","title":"1. Report Bugs","text":"<p>Found a bug? Help us fix it:</p> <ol> <li>Check existing issues to avoid duplicates</li> <li>Create a new issue with:</li> <li>Clear title and description</li> <li>Steps to reproduce</li> <li>Expected vs actual behavior</li> <li>System information</li> <li>Error messages/logs</li> </ol> <p>Bug Report Template: <pre><code>## Description\nBrief description of the bug\n\n## Steps to Reproduce\n1. Run command: `python ralph_orchestrator.py ...`\n2. See error\n\n## Expected Behavior\nWhat should happen\n\n## Actual Behavior\nWhat actually happens\n\n## Environment\n- OS: [e.g., Ubuntu 22.04]\n- Python: [e.g., 3.10.5]\n- Ralph Version: [e.g., 1.0.0]\n- AI Agent: [e.g., claude]\n\n## Logs\n</code></pre> Error messages here <pre><code>\n</code></pre></p>"},{"location":"contributing/#2-suggest-features","title":"2. Suggest Features","text":"<p>Have an idea? We'd love to hear it:</p> <ol> <li>Check existing feature requests</li> <li>Open a discussion for major changes</li> <li>Create a feature request with:</li> <li>Use case description</li> <li>Proposed solution</li> <li>Alternative approaches</li> <li>Implementation considerations</li> </ol>"},{"location":"contributing/#3-improve-documentation","title":"3. Improve Documentation","text":"<p>Documentation improvements are always welcome:</p> <ul> <li>Fix typos and grammar</li> <li>Clarify confusing sections</li> <li>Add missing information</li> <li>Create new examples</li> <li>Translate documentation</li> </ul>"},{"location":"contributing/#4-contribute-code","title":"4. Contribute Code","text":"<p>Ready to code? Follow these steps:</p>"},{"location":"contributing/#setup-development-environment","title":"Setup Development Environment","text":"<pre><code># Fork and clone the repository\ngit clone https://github.com/YOUR_USERNAME/ralph-orchestrator.git\ncd ralph-orchestrator\n\n# Create a virtual environment\npython -m venv venv\nsource venv/bin/activate  # On Windows: venv\\Scripts\\activate\n\n# Install development dependencies\npip install -e .\npip install pytest pytest-cov black ruff\n\n# Install pre-commit hooks (optional)\npip install pre-commit\npre-commit install\n</code></pre>"},{"location":"contributing/#development-workflow","title":"Development Workflow","text":"<ol> <li> <p>Create a branch <pre><code>git checkout -b feature/your-feature-name\n# or\ngit checkout -b fix/issue-number\n</code></pre></p> </li> <li> <p>Make changes</p> </li> <li>Follow existing code style</li> <li>Add/update tests</li> <li> <p>Update documentation</p> </li> <li> <p>Test your changes <pre><code># Run all tests\npytest\n\n# Run specific test\npytest test_orchestrator.py::test_function\n\n# Check coverage\npytest --cov=ralph_orchestrator --cov-report=html\n</code></pre></p> </li> <li> <p>Format code <pre><code># Format with black\nblack ralph_orchestrator.py\n\n# Lint with ruff\nruff check ralph_orchestrator.py\n</code></pre></p> </li> <li> <p>Commit changes <pre><code>git add .\ngit commit -m \"feat: add new feature\"\n# Use conventional commits: feat, fix, docs, test, refactor, style, chore\n</code></pre></p> </li> <li> <p>Push and create PR <pre><code>git push origin feature/your-feature-name\n</code></pre></p> </li> </ol>"},{"location":"contributing/#development-guidelines","title":"Development Guidelines","text":""},{"location":"contributing/#code-style","title":"Code Style","text":"<p>We follow PEP 8 with these preferences:</p> <ul> <li>Line length: 88 characters (Black default)</li> <li>Quotes: Double quotes for strings</li> <li>Imports: Sorted with <code>isort</code></li> <li>Type hints: Use where beneficial</li> <li>Docstrings: Google style</li> </ul> <p>Example: <pre><code>def calculate_cost(\n    input_tokens: int,\n    output_tokens: int,\n    agent_type: str = \"claude\"\n) -&gt; float:\n    \"\"\"\n    Calculate token usage cost.\n\n    Args:\n        input_tokens: Number of input tokens\n        output_tokens: Number of output tokens\n        agent_type: Type of AI agent\n\n    Returns:\n        Cost in USD\n\n    Raises:\n        ValueError: If agent_type is unknown\n    \"\"\"\n    if agent_type not in TOKEN_COSTS:\n        raise ValueError(f\"Unknown agent: {agent_type}\")\n\n    rates = TOKEN_COSTS[agent_type]\n    cost = (input_tokens * rates[\"input\"] + \n            output_tokens * rates[\"output\"]) / 1_000_000\n    return round(cost, 4)\n</code></pre></p>"},{"location":"contributing/#testing-guidelines","title":"Testing Guidelines","text":"<p>All new features require tests:</p> <ol> <li>Unit tests for individual functions</li> <li>Integration tests for workflows</li> <li>Edge cases and error conditions</li> <li>Documentation of test purpose</li> </ol> <p>Test Example: <pre><code>def test_calculate_cost():\n    \"\"\"Test cost calculation for different agents.\"\"\"\n    # Test Claude pricing\n    cost = calculate_cost(1000, 500, \"claude\")\n    assert cost == 0.0105\n\n    # Test invalid agent\n    with pytest.raises(ValueError):\n        calculate_cost(1000, 500, \"invalid\")\n\n    # Test edge case: zero tokens\n    cost = calculate_cost(0, 0, \"claude\")\n    assert cost == 0.0\n</code></pre></p>"},{"location":"contributing/#commit-message-convention","title":"Commit Message Convention","text":"<p>We use Conventional Commits:</p> <ul> <li><code>feat:</code> New feature</li> <li><code>fix:</code> Bug fix</li> <li><code>docs:</code> Documentation changes</li> <li><code>test:</code> Test additions/changes</li> <li><code>refactor:</code> Code refactoring</li> <li><code>style:</code> Code style changes</li> <li><code>chore:</code> Maintenance tasks</li> <li><code>perf:</code> Performance improvements</li> </ul> <p>Examples: <pre><code>feat: add Gemini agent support\nfix: resolve token overflow in long prompts\ndocs: update installation guide for Windows\ntest: add integration tests for checkpointing\nrefactor: extract prompt validation logic\n</code></pre></p>"},{"location":"contributing/#pull-request-process","title":"Pull Request Process","text":"<ol> <li>Title: Use conventional commit format</li> <li>Description: Explain what and why</li> <li>Testing: Describe testing performed</li> <li>Screenshots: Include if UI changes</li> <li>Checklist: Complete PR template</li> </ol> <p>PR Template: <pre><code>## Description\nBrief description of changes\n\n## Type of Change\n- [ ] Bug fix\n- [ ] New feature\n- [ ] Documentation update\n- [ ] Performance improvement\n\n## Testing\n- [ ] All tests pass\n- [ ] Added new tests\n- [ ] Manual testing performed\n\n## Checklist\n- [ ] Code follows style guidelines\n- [ ] Self-reviewed code\n- [ ] Updated documentation\n- [ ] No breaking changes\n</code></pre></p>"},{"location":"contributing/#project-structure","title":"Project Structure","text":"<pre><code>ralph-orchestrator/\n\u251c\u2500\u2500 ralph_orchestrator.py   # Main orchestrator\n\u251c\u2500\u2500 ralph                   # CLI wrapper\n\u251c\u2500\u2500 tests/                  # Test files\n\u2502   \u251c\u2500\u2500 test_orchestrator.py\n\u2502   \u251c\u2500\u2500 test_integration.py\n\u2502   \u2514\u2500\u2500 test_production.py\n\u251c\u2500\u2500 docs/                   # Documentation\n\u2502   \u251c\u2500\u2500 index.md\n\u2502   \u251c\u2500\u2500 guide/\n\u2502   \u2514\u2500\u2500 api/\n\u251c\u2500\u2500 examples/               # Example prompts\n\u251c\u2500\u2500 .agent/                 # Runtime data\n\u2514\u2500\u2500 .github/               # GitHub configs\n</code></pre>"},{"location":"contributing/#testing","title":"Testing","text":""},{"location":"contributing/#run-tests","title":"Run Tests","text":"<pre><code># All tests\npytest\n\n# With coverage\npytest --cov=ralph_orchestrator\n\n# Specific test file\npytest test_orchestrator.py\n\n# Verbose output\npytest -v\n\n# Stop on first failure\npytest -x\n</code></pre>"},{"location":"contributing/#test-categories","title":"Test Categories","text":"<ol> <li>Unit Tests: Test individual functions</li> <li>Integration Tests: Test component interaction</li> <li>E2E Tests: Test complete workflows</li> <li>Performance Tests: Test resource usage</li> <li>Security Tests: Test input validation</li> </ol>"},{"location":"contributing/#documentation","title":"Documentation","text":""},{"location":"contributing/#building-docs-locally","title":"Building Docs Locally","text":"<pre><code># Install MkDocs\npip install mkdocs mkdocs-material\n\n# Serve locally\nmkdocs serve\n\n# Build static site\nmkdocs build\n</code></pre>"},{"location":"contributing/#documentation-standards","title":"Documentation Standards","text":"<ul> <li>Clear, concise language</li> <li>Code examples for all features</li> <li>Explain the \"why\" not just \"how\"</li> <li>Keep examples up-to-date</li> <li>Include troubleshooting tips</li> </ul>"},{"location":"contributing/#release-process","title":"Release Process","text":"<ol> <li>Version Bump: Update version in code</li> <li>Changelog: Update CHANGELOG.md</li> <li>Tests: Ensure all tests pass</li> <li>Documentation: Update if needed</li> <li>Tag: Create version tag</li> <li>Release: Create GitHub release</li> </ol>"},{"location":"contributing/#getting-help","title":"Getting Help","text":""},{"location":"contributing/#for-contributors","title":"For Contributors","text":"<ul> <li>\ud83d\udcac Discord Server</li> <li>\ud83d\udce7 Email Maintainers</li> <li>\ud83d\udde3\ufe0f GitHub Discussions</li> </ul>"},{"location":"contributing/#resources","title":"Resources","text":"<ul> <li>Development Setup Video</li> <li>Architecture Overview</li> <li>API Documentation</li> <li>Testing Guide</li> </ul>"},{"location":"contributing/#recognition","title":"Recognition","text":"<p>Contributors are recognized in:</p> <ul> <li>CONTRIBUTORS.md</li> <li>Release notes</li> <li>Documentation credits</li> </ul>"},{"location":"contributing/#license","title":"License","text":"<p>By contributing, you agree that your contributions will be licensed under the MIT License.</p> <p>Thank you for contributing to Ralph Orchestrator! \ud83c\udf89</p>"},{"location":"faq/","title":"Frequently Asked Questions","text":""},{"location":"faq/#general-questions","title":"General Questions","text":""},{"location":"faq/#what-is-ralph-orchestrator","title":"What is Ralph Orchestrator?","text":"<p>Ralph Orchestrator is an implementation of the Ralph Wiggum technique - a simple but effective pattern for autonomous task completion using AI agents. It continuously runs an AI agent against a prompt file until the task is marked complete or limits are reached.</p>"},{"location":"faq/#why-is-it-called-ralph-wiggum","title":"Why is it called \"Ralph Wiggum\"?","text":"<p>The technique is named after the Simpsons character Ralph Wiggum, whose quote \"Me fail English? That's unpossible!\" embodies the philosophy of deterministic failure in an unpredictable world. The system keeps trying until it succeeds, embracing the \"unpossible.\"</p>"},{"location":"faq/#who-created-ralph-orchestrator","title":"Who created Ralph Orchestrator?","text":"<p>The Ralph Wiggum technique was created by Geoffrey Huntley. This implementation builds on his concept with additional features like multiple agent support, checkpointing, and comprehensive testing.</p>"},{"location":"faq/#what-ai-agents-does-it-support","title":"What AI agents does it support?","text":"<p>Ralph Orchestrator currently supports: - Claude (Anthropic Claude Code CLI) - Gemini (Google Gemini CLI) - Q Chat (Q CLI tool)</p> <p>The system auto-detects available agents and can automatically select the best one.</p>"},{"location":"faq/#installation-setup","title":"Installation &amp; Setup","text":""},{"location":"faq/#do-i-need-all-three-ai-agents-installed","title":"Do I need all three AI agents installed?","text":"<p>No, you only need at least one AI agent installed. Ralph will auto-detect which agents are available and use them accordingly.</p>"},{"location":"faq/#how-do-i-install-the-ai-agents","title":"How do I install the AI agents?","text":"<pre><code># Claude\nnpm install -g @anthropic-ai/claude-code\n\n# Gemini\nnpm install -g @google/gemini-cli\n\n# Q Chat\n# Follow instructions at https://github.com/qchat/qchat\n</code></pre>"},{"location":"faq/#what-are-the-system-requirements","title":"What are the system requirements?","text":"<ul> <li>OS: Linux, macOS, or Windows (with WSL)</li> <li>Python: 3.9 or higher</li> <li>Git: 2.25 or higher</li> <li>Memory: 4GB minimum, 8GB recommended</li> <li>Storage: 20GB available space</li> </ul>"},{"location":"faq/#can-i-run-ralph-in-docker","title":"Can I run Ralph in Docker?","text":"<p>Yes! A Dockerfile is provided: <pre><code>docker build -t ralph-orchestrator .\ndocker run -v $(pwd):/workspace ralph-orchestrator\n</code></pre></p>"},{"location":"faq/#usage-questions","title":"Usage Questions","text":""},{"location":"faq/#how-do-i-know-when-ralph-is-done","title":"How do I know when Ralph is done?","text":"<p>Ralph stops when: 1. It finds <code>TASK_COMPLETE</code> marker in PROMPT.md 2. Maximum iterations are reached 3. Maximum runtime is exceeded 4. Too many consecutive errors occur</p>"},{"location":"faq/#what-should-i-put-in-promptmd","title":"What should I put in PROMPT.md?","text":"<p>Write clear, specific requirements with measurable success criteria. Include: - Task description - Requirements list - Success criteria - Example inputs/outputs (if applicable) - File structure (for complex projects)</p>"},{"location":"faq/#how-many-iterations-does-it-typically-take","title":"How many iterations does it typically take?","text":"<p>This varies by task complexity: - Simple functions: 5-10 iterations - Web APIs: 20-30 iterations - Complex applications: 50-100 iterations</p>"},{"location":"faq/#can-i-resume-if-ralph-stops","title":"Can I resume if Ralph stops?","text":"<p>Yes! Ralph saves state and can resume from where it left off: <pre><code># Ralph will automatically resume from last state\nralph run\n</code></pre></p>"},{"location":"faq/#how-do-i-monitor-progress","title":"How do I monitor progress?","text":"<pre><code># Check status\nralph status\n\n# Watch in real-time\nwatch -n 5 'ralph status'\n\n# View logs\ntail -f .agent/logs/ralph.log\n</code></pre>"},{"location":"faq/#configuration","title":"Configuration","text":""},{"location":"faq/#how-do-i-change-the-default-agent","title":"How do I change the default agent?","text":"<p>Edit <code>ralph.json</code>: <pre><code>{\n  \"agent\": \"claude\"  // or \"gemini\", \"q\", \"auto\"\n}\n</code></pre></p> <p>Or use command line: <pre><code>ralph run --agent claude\n</code></pre></p>"},{"location":"faq/#can-i-set-custom-iteration-limits","title":"Can I set custom iteration limits?","text":"<p>Yes, in multiple ways: <pre><code># Command line\nralph run --max-iterations 50\n\n# Config file (ralph.json)\n{\n  \"max_iterations\": 50\n}\n\n# Environment variable\nexport RALPH_MAX_ITERATIONS=50\n</code></pre></p>"},{"location":"faq/#what-is-checkpoint-interval","title":"What is checkpoint interval?","text":"<p>Checkpoint interval determines how often Ralph creates Git commits to save progress. Default is every 5 iterations.</p>"},{"location":"faq/#how-do-i-disable-git-operations","title":"How do I disable Git operations?","text":"<pre><code>ralph run --no-git\n</code></pre> <p>Or in config: <pre><code>{\n  \"git_enabled\": false\n}\n</code></pre></p>"},{"location":"faq/#troubleshooting","title":"Troubleshooting","text":""},{"location":"faq/#why-isnt-my-task-completing","title":"Why isn't my task completing?","text":"<p>Common reasons: 1. Task description is unclear 2. Requirements are too complex for single prompt 3. Agent doesn't understand the format 4. Missing resources or dependencies</p>"},{"location":"faq/#ralph-keeps-hitting-the-same-error","title":"Ralph keeps hitting the same error","text":"<p>Try: 1. Simplifying the task 2. Adding clarification to PROMPT.md 3. Using a different agent 4. Manually fixing the specific issue</p>"},{"location":"faq/#how-do-i-reduce-api-costs","title":"How do I reduce API costs?","text":"<ol> <li>Use more efficient agents (Q is free)</li> <li>Reduce max iterations</li> <li>Write clearer prompts to reduce iterations</li> <li>Use checkpoint recovery instead of restarting</li> </ol>"},{"location":"faq/#can-i-use-ralph-offline","title":"Can I use Ralph offline?","text":"<p>No, Ralph requires internet access to communicate with AI agent APIs. However, you can use a local AI model if you create a compatible CLI wrapper.</p>"},{"location":"faq/#advanced-usage","title":"Advanced Usage","text":""},{"location":"faq/#can-i-extend-ralph-with-custom-agents","title":"Can I extend Ralph with custom agents?","text":"<p>Yes! Implement the Agent interface: <pre><code>class MyAgent(Agent):\n    def __init__(self):\n        super().__init__('myagent', 'myagent-cli')\n\n    def execute(self, prompt_file):\n        # Your implementation\n        pass\n</code></pre></p>"},{"location":"faq/#can-i-run-multiple-ralph-instances","title":"Can I run multiple Ralph instances?","text":"<p>Yes, but in different directories to avoid conflicts: <pre><code># Terminal 1\ncd project1 &amp;&amp; ralph run\n\n# Terminal 2\ncd project2 &amp;&amp; ralph run\n</code></pre></p>"},{"location":"faq/#how-do-i-integrate-ralph-into-cicd","title":"How do I integrate Ralph into CI/CD?","text":"<pre><code># GitHub Actions example\n- name: Run Ralph\n  run: |\n    ralph run --max-iterations 50 --dry-run\n\n- name: Check completion\n  run: |\n    grep TASK_COMPLETE PROMPT.md\n</code></pre>"},{"location":"faq/#can-ralph-modify-files-outside-the-project","title":"Can Ralph modify files outside the project?","text":"<p>By default, Ralph works within the current directory. For safety, it's designed not to modify system files or files outside the project directory.</p>"},{"location":"faq/#best-practices","title":"Best Practices","text":""},{"location":"faq/#what-makes-a-good-prompt","title":"What makes a good prompt?","text":"<p>Good prompts are: - Specific: Clear requirements and constraints - Measurable: Defined success criteria - Structured: Organized with sections - Complete: All necessary information included</p>"},{"location":"faq/#should-i-commit-promptmd-to-git","title":"Should I commit PROMPT.md to Git?","text":"<p>Yes! Version control your prompts to: - Track requirement changes - Share with team members - Reproduce results - Build a prompt library</p>"},{"location":"faq/#how-often-should-i-check-on-ralph","title":"How often should I check on Ralph?","text":"<p>For typical tasks: - First 5 iterations: Watch closely - 5-20 iterations: Check every 5 minutes - 20+ iterations: Check every 15 minutes</p>"},{"location":"faq/#when-should-i-intervene-manually","title":"When should I intervene manually?","text":"<p>Intervene when: - Same error repeats 3+ times - Progress stalls for 10+ iterations - Output diverges from requirements - Resource usage is excessive</p>"},{"location":"faq/#cost-performance","title":"Cost &amp; Performance","text":""},{"location":"faq/#how-much-does-it-cost-to-run-ralph","title":"How much does it cost to run Ralph?","text":"<p>Approximate costs per task: - Simple function: $0.05-0.10 - Web API: $0.20-0.30 - Complex application: $0.50-1.00</p> <p>(Varies by agent and API pricing)</p>"},{"location":"faq/#which-agent-is-fastest","title":"Which agent is fastest?","text":"<p>Generally: 1. Q: Fastest response time 2. Gemini: Balanced speed and capability 3. Claude: Most capable but slower</p>"},{"location":"faq/#how-can-i-speed-up-execution","title":"How can I speed up execution?","text":"<ol> <li>Use simpler prompts</li> <li>Reduce context size</li> <li>Choose faster agents</li> <li>Increase system resources</li> <li>Disable unnecessary features</li> </ol>"},{"location":"faq/#does-ralph-work-with-rate-limits","title":"Does Ralph work with rate limits?","text":"<p>Yes, Ralph handles rate limits with: - Exponential backoff - Retry logic - Agent switching (if multiple available)</p>"},{"location":"faq/#security-privacy","title":"Security &amp; Privacy","text":""},{"location":"faq/#is-my-code-sent-to-ai-providers","title":"Is my code sent to AI providers?","text":"<p>Yes, the contents of PROMPT.md and relevant files are sent to the AI agent's API. Never include sensitive data like: - API keys - Passwords - Personal information - Proprietary code</p>"},{"location":"faq/#how-do-i-protect-sensitive-information","title":"How do I protect sensitive information?","text":"<ol> <li>Use environment variables for secrets</li> <li>Add sensitive files to .gitignore</li> <li>Review prompts before running</li> <li>Use local development credentials</li> <li>Audit generated code</li> </ol>"},{"location":"faq/#can-ralph-access-my-system","title":"Can Ralph access my system?","text":"<p>Ralph runs AI agents in subprocesses with: - Timeout protection - Resource limits - Working directory restrictions</p> <p>However, agents can execute code, so always review outputs.</p>"},{"location":"faq/#is-it-safe-to-run-ralph-on-production-servers","title":"Is it safe to run Ralph on production servers?","text":"<p>Not recommended. Ralph is designed for development environments. For production, use Ralph locally and deploy tested code.</p>"},{"location":"faq/#community-support","title":"Community &amp; Support","text":""},{"location":"faq/#how-do-i-report-bugs","title":"How do I report bugs?","text":"<ol> <li>Check existing issues on GitHub</li> <li>Create detailed bug report with:</li> <li>Ralph version</li> <li>Error messages</li> <li>Steps to reproduce</li> <li>System information</li> </ol>"},{"location":"faq/#can-i-contribute-to-ralph","title":"Can I contribute to Ralph?","text":"<p>Yes! We welcome contributions: - Bug fixes - New features - Documentation improvements - Agent integrations</p> <p>See CONTRIBUTING.md for guidelines.</p>"},{"location":"faq/#where-can-i-get-help","title":"Where can I get help?","text":"<ul> <li>GitHub Issues: Bug reports and feature requests</li> <li>GitHub Discussions: Questions and community help</li> <li>Discord: Real-time chat with community</li> </ul>"},{"location":"faq/#is-there-commercial-support","title":"Is there commercial support?","text":"<p>Currently, Ralph Orchestrator is community-supported open source software. Commercial support may be available in the future.</p>"},{"location":"glossary/","title":"Glossary","text":""},{"location":"glossary/#a","title":"A","text":"Agent An AI-powered CLI tool that executes tasks based on prompts. Ralph supports Claude, Gemini, and Q agents. Agent Manager Component that detects, selects, and manages AI agents, including automatic fallback when preferred agents are unavailable. Archive Storage of historical prompts and iterations in <code>.agent/prompts/</code> directory for debugging and analysis. Auto-detection Ralph's ability to automatically discover which AI agents are installed and available on the system."},{"location":"glossary/#c","title":"C","text":"Checkpoint A Git commit created at regular intervals to save progress and enable recovery. Default interval is every 5 iterations. Claude Anthropic's AI assistant, accessible via Claude Code CLI. Known for high context window (200K tokens) and code generation capabilities. CLI Command Line Interface - the primary way to interact with Ralph Orchestrator through terminal commands. Config Configuration settings stored in <code>ralph.json</code> or passed via command line arguments and environment variables. Context Window The maximum amount of text/tokens an AI agent can process in a single request. Varies by agent (Claude: 200K, Gemini: 32K, Q: 8K). Convergence The process of iterations gradually approaching task completion through successive improvements."},{"location":"glossary/#d","title":"D","text":"Dry Run Test mode that simulates execution without actually running AI agents. Useful for testing configuration and setup. Deterministic Failure The philosophy that it's better to fail predictably than succeed unpredictably - core to the Ralph Wiggum technique."},{"location":"glossary/#e","title":"E","text":"Exponential Backoff Retry strategy where wait time doubles after each failure (2, 4, 8, 16 seconds) to handle transient errors. Execution Cycle One complete iteration of reading prompt, executing agent, checking completion, and updating state."},{"location":"glossary/#g","title":"G","text":"Gemini Google's AI model, accessible via Gemini CLI. Balanced context window (32K tokens) and capabilities. Git Integration Ralph's use of Git for checkpointing, history tracking, and recovery from failed states."},{"location":"glossary/#i","title":"I","text":"Iteration One complete cycle of the Ralph loop - executing an agent with the current prompt and processing results. Iteration Limit Maximum number of iterations before Ralph stops. Default is 100, configurable via <code>max_iterations</code>."},{"location":"glossary/#l","title":"L","text":"Loop The core Ralph pattern - continuously running an AI agent until task completion or limits are reached."},{"location":"glossary/#m","title":"M","text":"Metrics Performance and execution data collected in <code>.agent/metrics/</code> including timing, errors, and resource usage. MkDocs Static site generator used for Ralph's documentation, configured in <code>mkdocs.yml</code>."},{"location":"glossary/#o","title":"O","text":"Orchestrator The main component that manages the execution loop, agent interaction, and state management."},{"location":"glossary/#p","title":"P","text":"Prompt The task description file (usually <code>PROMPT.md</code>) that tells the AI agent what to accomplish. Prompt Archive Historical storage of all prompt iterations in <code>.agent/prompts/</code> for debugging and analysis. Plugin Extension mechanism for adding custom agents or commands to Ralph."},{"location":"glossary/#q","title":"Q","text":"Q Chat An AI assistant accessible via Q CLI. Smaller context window (8K tokens) but fast execution."},{"location":"glossary/#r","title":"R","text":"Ralph Wiggum Technique The software engineering pattern of putting AI agents in a loop until the task is done, created by Geoffrey Huntley. Recovery Process of resuming execution from a saved state or Git checkpoint after failure or interruption. Retry Logic Automatic retry mechanism with exponential backoff for handling transient failures. Runtime Limit Maximum execution time in seconds before Ralph stops. Default is 14400 (4 hours)."},{"location":"glossary/#s","title":"S","text":"State Current execution status including iteration count, errors, and metrics, saved in <code>.agent/metrics/state_latest.json</code>. State Manager Component responsible for saving, loading, and updating execution state across iterations. Success Marker The <code>TASK_COMPLETE</code> comment that signals task completion in PROMPT.md."},{"location":"glossary/#t","title":"T","text":"Task The work to be accomplished, described in PROMPT.md with requirements and success criteria. Task Complete State when <code>&lt;!-- TASK_COMPLETE --&gt;</code> marker is found in PROMPT.md, indicating successful completion. Timeout Maximum time allowed for a single agent execution. Default is 300 seconds (5 minutes) per iteration. Token Unit of text processed by AI models. Roughly 4 characters = 1 token."},{"location":"glossary/#u","title":"U","text":"Unpossible Reference to Ralph Wiggum's quote, embodying the philosophy of achieving the seemingly impossible through persistence."},{"location":"glossary/#v","title":"V","text":"Verbose Mode Detailed logging mode enabled with <code>--verbose</code> flag for debugging and monitoring."},{"location":"glossary/#w","title":"W","text":"Working Directory The directory where Ralph executes, containing PROMPT.md and project files. Defaults to current directory. Workspace The <code>.agent/</code> directory containing Ralph's operational data including metrics, checkpoints, and archives."},{"location":"glossary/#technical-terms","title":"Technical Terms","text":"API Application Programming Interface - the interface through which Ralph communicates with AI services. JSON JavaScript Object Notation - format used for configuration files and state storage. Subprocess Separate process spawned to execute AI agents, providing isolation and timeout control. YAML YAML Ain't Markup Language - human-readable data format used for some configuration files."},{"location":"glossary/#file-formats","title":"File Formats","text":"<code>.md</code> Markdown files used for prompts and documentation. <code>.json</code> JSON files used for configuration and state storage. <code>.yaml</code>/<code>.yml</code> YAML files used for configuration (e.g., <code>mkdocs.yml</code>). <code>.log</code> Log files containing execution history and debugging information."},{"location":"glossary/#directory-structure","title":"Directory Structure","text":"<code>.agent/</code> Ralph's workspace directory containing all operational data. <code>.agent/metrics/</code> Storage for execution metrics and state files. <code>.agent/prompts/</code> Archive of historical prompt iterations. <code>.agent/checkpoints/</code> Markers for Git checkpoints created during execution. <code>.agent/logs/</code> Execution logs for debugging and analysis. <code>.agent/plans/</code> Agent planning documents and long-term strategies."},{"location":"glossary/#command-reference","title":"Command Reference","text":"<code>ralph run</code> Execute the orchestrator with current configuration. <code>ralph init</code> Initialize a new Ralph project with default structure. <code>ralph status</code> Check current execution status and metrics. <code>ralph clean</code> Clean workspace and reset state. <code>ralph agents</code> List available AI agents on the system."},{"location":"glossary/#environment-variables","title":"Environment Variables","text":"<code>RALPH_AGENT</code> Override default agent selection. <code>RALPH_MAX_ITERATIONS</code> Set maximum iteration limit. <code>RALPH_MAX_RUNTIME</code> Set maximum runtime in seconds. <code>RALPH_VERBOSE</code> Enable verbose logging (true/false). <code>RALPH_DRY_RUN</code> Enable dry run mode (true/false)."},{"location":"glossary/#exit-codes","title":"Exit Codes","text":"<p>0: Success - task completed successfully</p> <p>1: General failure - check logs for details</p> <p>130: Interrupted - user pressed Ctrl+C</p> <p>137: Killed - process terminated (often memory issues)</p> <p>124: Timeout - execution time exceeded</p>"},{"location":"installation/","title":"Installation Guide","text":"<p>Comprehensive installation instructions for Ralph Orchestrator.</p>"},{"location":"installation/#system-requirements","title":"System Requirements","text":""},{"location":"installation/#minimum-requirements","title":"Minimum Requirements","text":"<ul> <li>Python: 3.8 or higher</li> <li>Memory: 512 MB RAM</li> <li>Disk: 100 MB free space</li> <li>OS: Linux, macOS, or Windows</li> </ul>"},{"location":"installation/#recommended-requirements","title":"Recommended Requirements","text":"<ul> <li>Python: 3.10 or higher</li> <li>Memory: 2 GB RAM</li> <li>Disk: 1 GB free space</li> <li>Git: For checkpoint features</li> <li>Network: Stable internet connection</li> </ul>"},{"location":"installation/#installation-methods","title":"Installation Methods","text":""},{"location":"installation/#method-1-git-clone-recommended","title":"Method 1: Git Clone (Recommended)","text":"<pre><code># Clone the repository\ngit clone https://github.com/mikeyobrien/ralph-orchestrator.git\ncd ralph-orchestrator\n\n# Make the orchestrator executable\nchmod +x ralph_orchestrator.py\nchmod +x ralph\n\n# Install optional dependencies\npip install psutil  # For system metrics\n</code></pre>"},{"location":"installation/#method-2-direct-download","title":"Method 2: Direct Download","text":"<pre><code># Download the latest release\nwget https://github.com/mikeyobrien/ralph-orchestrator/archive/refs/tags/v1.0.0.tar.gz\n\n# Extract the archive\ntar -xzf v1.0.0.tar.gz\ncd ralph-orchestrator-1.0.0\n\n# Make executable\nchmod +x ralph_orchestrator.py\n</code></pre>"},{"location":"installation/#method-3-pip-install-coming-soon","title":"Method 3: pip Install (Coming Soon)","text":"<pre><code># Future installation via pip\npip install ralph-orchestrator\n</code></pre>"},{"location":"installation/#ai-agent-installation","title":"AI Agent Installation","text":"<p>Ralph requires at least one AI agent to function. Choose and install one or more:</p>"},{"location":"installation/#claude-anthropic","title":"Claude (Anthropic)","text":"<p>Claude is the recommended agent for most use cases.</p> <pre><code># Install via npm\nnpm install -g @anthropic-ai/claude-code\n\n# Or download from\n# https://claude.ai/code\n\n# Verify installation\nclaude --version\n</code></pre> <p>Configuration: <pre><code># Set your API key (if required)\nexport ANTHROPIC_API_KEY=\"your-api-key-here\"\n</code></pre></p>"},{"location":"installation/#q-chat","title":"Q Chat","text":"<p>Q Chat is a lightweight alternative agent.</p> <pre><code># Install via pip\npip install q-cli\n\n# Or clone from repository\ngit clone https://github.com/qchat/qchat.git\ncd qchat\npython setup.py install\n\n# Verify installation\nq --version\n</code></pre> <p>Configuration: <pre><code># Configure Q Chat\nq config --set api_key=\"your-api-key\"\n</code></pre></p>"},{"location":"installation/#gemini-google","title":"Gemini (Google)","text":"<p>Gemini provides access to Google's AI models.</p> <pre><code># Install via npm\nnpm install -g @google/gemini-cli\n\n# Verify installation\ngemini --version\n</code></pre> <p>Configuration: <pre><code># Set your API key\nexport GEMINI_API_KEY=\"your-api-key-here\"\n\n# Or use config file\ngemini config set api_key \"your-api-key\"\n</code></pre></p>"},{"location":"installation/#dependency-installation","title":"Dependency Installation","text":""},{"location":"installation/#required-python-packages","title":"Required Python Packages","text":"<p>Ralph Orchestrator has minimal dependencies, but some features require additional packages:</p> <pre><code># Core functionality (no additional packages needed)\n# Ralph uses only Python standard library for core features\n\n# Optional: System metrics monitoring\npip install psutil\n\n# Optional: Enhanced JSON handling\npip install orjson  # Faster JSON processing\n\n# Optional: Development dependencies\npip install pytest pytest-cov black ruff\n</code></pre>"},{"location":"installation/#using-requirementstxt","title":"Using requirements.txt","text":"<p>If you want to install all optional dependencies:</p> <pre><code># Create requirements.txt\ncat &gt; requirements.txt &lt;&lt; EOF\npsutil&gt;=5.9.0\norjson&gt;=3.9.0\npytest&gt;=7.0.0\npytest-cov&gt;=4.0.0\nblack&gt;=23.0.0\nruff&gt;=0.1.0\nEOF\n\n# Install all dependencies\npip install -r requirements.txt\n</code></pre>"},{"location":"installation/#using-uv-recommended-for-development","title":"Using uv (Recommended for Development)","text":"<pre><code># Install uv\ncurl -LsSf https://astral.sh/uv/install.sh | sh\n\n# Install dependencies with uv\nuv pip install psutil orjson\n\n# Or use pyproject.toml\nuv sync\n</code></pre>"},{"location":"installation/#verification","title":"Verification","text":""},{"location":"installation/#verify-installation","title":"Verify Installation","text":"<p>Run these commands to verify your installation:</p> <pre><code># Check Python version\npython --version  # Should be 3.8+\n\n# Check Ralph Orchestrator\npython ralph_orchestrator.py --version\n\n# Check for available agents\npython ralph_orchestrator.py --list-agents\n\n# Run a test\necho \"Say hello and add TASK_COMPLETE\" &gt; test.md\npython ralph_orchestrator.py --prompt test.md --dry-run\n</code></pre>"},{"location":"installation/#expected-output","title":"Expected Output","text":"<pre><code>Ralph Orchestrator v1.0.0\nPython 3.10.12\nAvailable agents: claude, q, gemini\nDry run completed successfully\n</code></pre>"},{"location":"installation/#platform-specific-instructions","title":"Platform-Specific Instructions","text":""},{"location":"installation/#linux","title":"Linux","text":"<pre><code># Ubuntu/Debian\nsudo apt update\nsudo apt install python3 python3-pip git\n\n# Fedora/RHEL\nsudo dnf install python3 python3-pip git\n\n# Arch Linux\nsudo pacman -S python python-pip git\n</code></pre>"},{"location":"installation/#macos","title":"macOS","text":"<pre><code># Using Homebrew\nbrew install python git\n\n# Using MacPorts\nsudo port install python310 git\n\n# Verify Python installation\npython3 --version\n</code></pre>"},{"location":"installation/#windows","title":"Windows","text":"<pre><code># Using PowerShell as Administrator\n\n# Install Python from Microsoft Store\nwinget install Python.Python.3.11\n\n# Or download from python.org\n# https://www.python.org/downloads/windows/\n\n# Install Git\nwinget install Git.Git\n\n# Clone Ralph\ngit clone https://github.com/mikeyobrien/ralph-orchestrator.git\ncd ralph-orchestrator\n\n# Run Ralph\npython ralph_orchestrator.py --prompt PROMPT.md\n</code></pre>"},{"location":"installation/#docker-alternative","title":"Docker (Alternative)","text":"<pre><code># Dockerfile\nFROM python:3.11-slim\n\nWORKDIR /app\nCOPY . /app\n\nRUN pip install psutil\n\n# Install your preferred AI agent\nRUN npm install -g @anthropic-ai/claude-code\n\nCMD [\"python\", \"ralph_orchestrator.py\"]\n</code></pre> <pre><code># Build and run\ndocker build -t ralph-orchestrator .\ndocker run -v $(pwd):/app ralph-orchestrator --prompt PROMPT.md\n</code></pre>"},{"location":"installation/#configuration-files","title":"Configuration Files","text":""},{"location":"installation/#basic-configuration","title":"Basic Configuration","text":"<p>Create a configuration file for default settings:</p> <pre><code># Create .ralph.conf\ncat &gt; .ralph.conf &lt;&lt; EOF\n# Default Ralph Configuration\nagent=claude\nmax_iterations=100\nmax_runtime=14400\ncheckpoint_interval=5\nverbose=false\nEOF\n</code></pre>"},{"location":"installation/#environment-variables","title":"Environment Variables","text":"<p>Set environment variables for common settings:</p> <pre><code># Add to your ~/.bashrc or ~/.zshrc\nexport RALPH_AGENT=\"claude\"\nexport RALPH_MAX_ITERATIONS=\"100\"\nexport RALPH_MAX_COST=\"50.0\"\nexport RALPH_VERBOSE=\"false\"\n</code></pre>"},{"location":"installation/#troubleshooting-installation","title":"Troubleshooting Installation","text":""},{"location":"installation/#common-issues","title":"Common Issues","text":""},{"location":"installation/#python-version-too-old","title":"Python Version Too Old","text":"<pre><code>ERROR: Python 3.8+ required, found 3.7.3\n</code></pre> <p>Solution: Upgrade Python <pre><code># Ubuntu/Debian\nsudo apt install python3.10\n\n# macOS\nbrew upgrade python\n\n# Windows\nwinget upgrade Python.Python.3.11\n</code></pre></p>"},{"location":"installation/#agent-not-found","title":"Agent Not Found","text":"<pre><code>ERROR: No AI agents detected\n</code></pre> <p>Solution: Install at least one agent <pre><code>npm install -g @anthropic-ai/claude-code\n# or\npip install q-cli\n</code></pre></p>"},{"location":"installation/#permission-denied","title":"Permission Denied","text":"<pre><code>Permission denied: './ralph_orchestrator.py'\n</code></pre> <p>Solution: Make executable <pre><code>chmod +x ralph_orchestrator.py\nchmod +x ralph\n</code></pre></p>"},{"location":"installation/#module-not-found","title":"Module Not Found","text":"<pre><code>ModuleNotFoundError: No module named 'psutil'\n</code></pre> <p>Solution: Install optional dependencies <pre><code>pip install psutil\n</code></pre></p>"},{"location":"installation/#uninstallation","title":"Uninstallation","text":"<p>To remove Ralph Orchestrator:</p> <pre><code># Remove the directory\nrm -rf ralph-orchestrator\n\n# Uninstall optional dependencies\npip uninstall psutil orjson\n\n# Remove configuration files\nrm ~/.ralph.conf\n</code></pre>"},{"location":"installation/#next-steps","title":"Next Steps","text":"<p>After installation:</p> <ol> <li>Read the Quick Start Guide</li> <li>Configure your AI Agents</li> <li>Learn about Configuration Options</li> <li>Try the Examples</li> </ol>"},{"location":"installation/#getting-help","title":"Getting Help","text":"<p>If you encounter issues:</p> <ul> <li>Check the FAQ</li> <li>Read Troubleshooting</li> <li>Open an issue on GitHub</li> <li>Join the discussions</li> </ul> <p>\ud83d\udcda Continue to the User Guide \u2192</p>"},{"location":"license/","title":"License","text":""},{"location":"license/#mit-license","title":"MIT License","text":"<p>Copyright \u00a9 2025 Ralph Orchestrator Contributors</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"license/#attribution","title":"Attribution","text":"<p>Ralph Orchestrator is based on the Ralph Wiggum technique created by Geoffrey Huntley. The original concept and technique are used with permission and gratitude.</p>"},{"location":"license/#third-party-licenses","title":"Third-Party Licenses","text":"<p>Ralph Orchestrator uses the following open-source libraries:</p>"},{"location":"license/#python-standard-library","title":"Python Standard Library","text":"<ul> <li>License: Python Software Foundation License</li> <li>URL: https://docs.python.org/3/license.html</li> </ul>"},{"location":"license/#optional-dependencies","title":"Optional Dependencies","text":""},{"location":"license/#rich-terminal-formatting","title":"Rich (Terminal Formatting)","text":"<ul> <li>License: MIT</li> <li>URL: https://github.com/Textualize/rich</li> <li>Copyright: Will McGugan</li> </ul>"},{"location":"license/#click-cli-framework","title":"Click (CLI Framework)","text":"<ul> <li>License: BSD-3-Clause</li> <li>URL: https://github.com/pallets/click</li> <li>Copyright: Pallets</li> </ul>"},{"location":"license/#plotly-visualization","title":"Plotly (Visualization)","text":"<ul> <li>License: MIT</li> <li>URL: https://github.com/plotly/plotly.py</li> <li>Copyright: Plotly, Inc.</li> </ul>"},{"location":"license/#pyyaml-yaml-processing","title":"PyYAML (YAML Processing)","text":"<ul> <li>License: MIT</li> <li>URL: https://github.com/yaml/pyyaml</li> <li>Copyright: Kirill Simonov</li> </ul>"},{"location":"license/#pandas-data-analysis","title":"Pandas (Data Analysis)","text":"<ul> <li>License: BSD-3-Clause</li> <li>URL: https://github.com/pandas-dev/pandas</li> <li>Copyright: The Pandas Development Team</li> </ul>"},{"location":"license/#development-dependencies","title":"Development Dependencies","text":""},{"location":"license/#pytest-testing","title":"Pytest (Testing)","text":"<ul> <li>License: MIT</li> <li>URL: https://github.com/pytest-dev/pytest</li> <li>Copyright: Holger Krekel and others</li> </ul>"},{"location":"license/#mkdocs-documentation","title":"MkDocs (Documentation)","text":"<ul> <li>License: BSD-2-Clause</li> <li>URL: https://github.com/mkdocs/mkdocs</li> <li>Copyright: Tom Christie</li> </ul>"},{"location":"license/#material-for-mkdocs-theme","title":"Material for MkDocs (Theme)","text":"<ul> <li>License: MIT</li> <li>URL: https://github.com/squidfunk/mkdocs-material</li> <li>Copyright: Martin Donath</li> </ul>"},{"location":"license/#ai-agent-clis","title":"AI Agent CLIs","text":"<p>Ralph Orchestrator integrates with the following AI agent CLI tools, which have their own licenses:</p>"},{"location":"license/#claude-cli","title":"Claude CLI","text":"<ul> <li>Provider: Anthropic</li> <li>License: See Claude CLI documentation</li> <li>URL: https://claude.ai/code</li> </ul>"},{"location":"license/#gemini-cli","title":"Gemini CLI","text":"<ul> <li>Provider: Google</li> <li>License: See Gemini CLI documentation</li> <li>URL: https://github.com/google-gemini/gemini-cli</li> </ul>"},{"location":"license/#q-chat","title":"Q Chat","text":"<ul> <li>Provider: Q Chat Team</li> <li>License: See Q Chat documentation</li> <li>URL: https://github.com/qchat/qchat</li> </ul>"},{"location":"license/#documentation-license","title":"Documentation License","text":"<p>The Ralph Orchestrator documentation is licensed under the Creative Commons Attribution 4.0 International License (CC BY 4.0).</p> <p>You are free to: - Share \u2014 copy and redistribute the material in any medium or format - Adapt \u2014 remix, transform, and build upon the material for any purpose, even commercially</p> <p>Under the following terms: - Attribution \u2014 You must give appropriate credit, provide a link to the license, and indicate if changes were made</p>"},{"location":"license/#contributing","title":"Contributing","text":"<p>By contributing to Ralph Orchestrator, you agree that your contributions will be licensed under the MIT License.</p>"},{"location":"license/#patent-notice","title":"Patent Notice","text":"<p>This software is provided \"as is\" without any patent licenses or grants. Users are responsible for ensuring their use of Ralph Orchestrator does not infringe on any patents.</p>"},{"location":"license/#trademark-notice","title":"Trademark Notice","text":"<p>The name \"Ralph Orchestrator\" and the Ralph Wiggum technique are not registered trademarks. The Simpsons and Ralph Wiggum are trademarks of their respective owners and are referenced here for descriptive purposes only.</p>"},{"location":"license/#export-compliance","title":"Export Compliance","text":"<p>This software may be subject to export control laws and regulations. Users are responsible for compliance with all applicable export control laws and regulations.</p>"},{"location":"license/#disclaimer","title":"Disclaimer","text":"<p>The authors and contributors of Ralph Orchestrator: - Make no warranties about the suitability of this software for any purpose - Are not responsible for any damages or losses arising from the use of this software - Do not provide any guarantee of support or maintenance</p>"},{"location":"license/#questions","title":"Questions","text":"<p>For licensing questions, please: - Open an issue on GitHub - Contact the maintainers through GitHub discussions</p>"},{"location":"license/#summary","title":"Summary","text":"<ul> <li>Software: MIT License (permissive, commercial use allowed)</li> <li>Documentation: CC BY 4.0 (attribution required)</li> <li>Dependencies: Various open-source licenses (mostly MIT/BSD)</li> <li>Contribution: By contributing, you agree to MIT License</li> </ul> <p>Last updated: 2025-09-08</p>"},{"location":"quick-start/","title":"Quick Start Guide","text":"<p>Get Ralph Orchestrator up and running in 5 minutes!</p>"},{"location":"quick-start/#prerequisites","title":"Prerequisites","text":"<p>Before you begin, ensure you have:</p> <ul> <li>Python 3.8 or higher</li> <li>Git (for checkpointing features)</li> <li>At least one AI CLI tool installed</li> </ul>"},{"location":"quick-start/#step-1-install-an-ai-agent","title":"Step 1: Install an AI Agent","text":"<p>Ralph works with multiple AI agents. Install at least one:</p> Claude (Recommended)Q ChatGemini <pre><code>npm install -g @anthropic-ai/claude-code\n# Or visit https://claude.ai/code for setup instructions\n</code></pre> <pre><code>pip install q-cli\n# Or follow instructions at https://github.com/qchat/qchat\n</code></pre> <pre><code>npm install -g @google/gemini-cli\n# Configure with your API key\n</code></pre>"},{"location":"quick-start/#step-2-clone-ralph-orchestrator","title":"Step 2: Clone Ralph Orchestrator","text":"<pre><code># Clone the repository\ngit clone https://github.com/mikeyobrien/ralph-orchestrator.git\ncd ralph-orchestrator\n\n# Install optional dependencies for monitoring\npip install psutil  # Recommended for system metrics\n</code></pre>"},{"location":"quick-start/#step-3-create-your-first-task","title":"Step 3: Create Your First Task","text":"<p>Create a <code>PROMPT.md</code> file with your task:</p> <pre><code># Task: Create a Todo List CLI\n\nBuild a Python command-line todo list application with:\n- Add tasks\n- List tasks\n- Mark tasks as complete\n- Save tasks to a JSON file\n\nInclude proper error handling and a help command.\n\nWhen the implementation is complete and tested, add \"TASK_COMPLETE\" to this file.\n</code></pre>"},{"location":"quick-start/#step-4-run-ralph","title":"Step 4: Run Ralph","text":"<pre><code># Basic execution (auto-detects available agent)\npython ralph_orchestrator.py --prompt PROMPT.md\n\n# Or specify an agent explicitly\npython ralph_orchestrator.py --agent claude --prompt PROMPT.md\n</code></pre>"},{"location":"quick-start/#step-5-monitor-progress","title":"Step 5: Monitor Progress","text":"<p>Ralph will now: 1. Read your prompt file 2. Execute the AI agent 3. Check for completion 4. Iterate until done or limits reached</p> <p>You'll see output like: <pre><code>2025-09-08 10:30:45 - INFO - Starting Ralph Orchestrator v1.0.0\n2025-09-08 10:30:45 - INFO - Using agent: claude\n2025-09-08 10:30:45 - INFO - Starting iteration 1/100\n2025-09-08 10:30:52 - INFO - Iteration 1 complete\n2025-09-08 10:30:52 - INFO - Task not complete, continuing...\n</code></pre></p>"},{"location":"quick-start/#what-happens-next","title":"What Happens Next?","text":"<p>Ralph will continue iterating until one of these conditions is met:</p> <ul> <li>\u2705 The task is marked complete (TASK_COMPLETE found in prompt)</li> <li>\u23f1\ufe0f Maximum iterations reached (default: 100)</li> <li>\u23f0 Maximum runtime exceeded (default: 4 hours)</li> <li>\ud83d\udcb0 Token or cost limits reached</li> <li>\u274c Unrecoverable error occurs</li> </ul>"},{"location":"quick-start/#basic-configuration","title":"Basic Configuration","text":"<p>Control Ralph's behavior with command-line options:</p> <pre><code># Limit iterations\npython ralph_orchestrator.py --prompt PROMPT.md --max-iterations 50\n\n# Set cost limit\npython ralph_orchestrator.py --prompt PROMPT.md --max-cost 10.0\n\n# Enable verbose logging\npython ralph_orchestrator.py --prompt PROMPT.md --verbose\n\n# Dry run (test without executing)\npython ralph_orchestrator.py --prompt PROMPT.md --dry-run\n</code></pre>"},{"location":"quick-start/#example-tasks","title":"Example Tasks","text":""},{"location":"quick-start/#simple-function","title":"Simple Function","text":"<pre><code>Write a Python function that validates email addresses using regex.\nInclude comprehensive unit tests.\n</code></pre>"},{"location":"quick-start/#web-scraper","title":"Web Scraper","text":"<pre><code>Create a web scraper that:\n1. Fetches the HackerNews homepage\n2. Extracts the top 10 stories\n3. Saves them to a JSON file\nUse requests and BeautifulSoup.\n</code></pre>"},{"location":"quick-start/#cli-tool","title":"CLI Tool","text":"<pre><code>Build a markdown to HTML converter CLI tool:\n- Accept input/output file arguments\n- Support basic markdown syntax\n- Add --watch mode for auto-conversion\n</code></pre>"},{"location":"quick-start/#next-steps","title":"Next Steps","text":"<p>Now that you've run your first Ralph task:</p> <ul> <li>\ud83d\udcd6 Read the User Guide for detailed configuration</li> <li>\ud83d\udd12 Learn about Security Features</li> <li>\ud83d\udcb0 Understand Cost Management</li> <li>\ud83d\udcca Set up Monitoring</li> <li>\ud83d\ude80 Deploy to Production</li> </ul>"},{"location":"quick-start/#troubleshooting","title":"Troubleshooting","text":""},{"location":"quick-start/#agent-not-found","title":"Agent Not Found","text":"<p>If Ralph can't find an AI agent: <pre><code>ERROR: No AI agents detected. Please install claude, q, or gemini.\n</code></pre></p> <p>Solution: Install one of the supported agents (see Step 1)</p>"},{"location":"quick-start/#permission-denied","title":"Permission Denied","text":"<p>If you get permission errors: <pre><code>chmod +x ralph_orchestrator.py\n</code></pre></p>"},{"location":"quick-start/#task-not-completing","title":"Task Not Completing","text":"<p>If your task runs indefinitely: - Check that your prompt includes clear completion criteria - Ensure the agent can add \"TASK_COMPLETE\" to the prompt file - Review iteration logs in <code>.agent/metrics/</code></p>"},{"location":"quick-start/#getting-help","title":"Getting Help","text":"<ul> <li>Check the FAQ</li> <li>Read the Troubleshooting Guide</li> <li>Open an issue on GitHub</li> <li>Join the discussions</li> </ul> <p>\ud83c\udf89 Congratulations! You've successfully run your first Ralph orchestration!</p>"},{"location":"research/","title":"Research and Theory","text":""},{"location":"research/#the-ralph-wiggum-technique","title":"The Ralph Wiggum Technique","text":""},{"location":"research/#origin","title":"Origin","text":"<p>The Ralph Wiggum technique was created by Geoffrey Huntley as a response to the increasing complexity of modern software development. Named after the Simpsons character's famous quote \"Me fail English? That's unpossible!\", the technique embraces a philosophy of deterministic failure in an unpredictable world.</p>"},{"location":"research/#core-philosophy","title":"Core Philosophy","text":"<p>\"Keep it simple, keep it running, keep it trying until it's done.\"</p> <p>The technique is based on several key observations:</p> <ol> <li>AI agents are capable but need persistence - They can accomplish complex tasks but may need multiple attempts</li> <li>Simple loops are robust - Complex orchestration often fails in complex ways</li> <li>Git provides perfect memory - Version control gives us time travel for free</li> <li>Deterministic failure is debuggable - When things fail predictably, we can fix them</li> </ol>"},{"location":"research/#theoretical-foundations","title":"Theoretical Foundations","text":""},{"location":"research/#loop-theory","title":"Loop Theory","text":"<p>The Ralph loop is a specialized form of a feedback control system:</p> <pre><code>Input (PROMPT.md) \u2192 Process (AI Agent) \u2192 Output (Code/Changes) \u2192 Feedback (Completion Check)\n     \u2191                                                                         \u2193\n     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>This creates a closed-loop system with: - Negative feedback: Errors cause retries - Positive feedback: Success triggers completion - Damping: Iteration limits prevent infinite loops - Memory: State persistence across iterations</p>"},{"location":"research/#convergence-properties","title":"Convergence Properties","text":"<p>Ralph exhibits convergence properties similar to gradient descent:</p> <ol> <li>Monotonic improvement: Each iteration generally improves the solution</li> <li>Local minima: May get stuck, requiring prompt clarification</li> <li>Step size: Controlled by agent capability and prompt clarity</li> <li>Convergence rate: Depends on task complexity and agent selection</li> </ol>"},{"location":"research/#information-theory-perspective","title":"Information Theory Perspective","text":"<p>From an information theory viewpoint:</p> <ul> <li>Prompt: Encodes the desired outcome (information source)</li> <li>Agent: Acts as a noisy channel with capacity limits</li> <li>Output: Decoded attempt at the desired outcome</li> <li>Iteration: Error correction through redundancy</li> </ul> <p>The system overcomes channel noise through repetition and error correction.</p>"},{"location":"research/#empirical-observations","title":"Empirical Observations","text":""},{"location":"research/#success-patterns","title":"Success Patterns","text":"<p>Analysis of successful Ralph runs shows:</p> <ol> <li>Clear prompts converge faster - Specificity reduces iteration count by 40-60%</li> <li>Checkpoint frequency affects reliability - 5-iteration checkpoints optimal for most tasks</li> <li>Agent selection matters - Claude succeeds 85% of time, Gemini 75%, Q 70%</li> <li>Context management is critical - Tasks failing due to context limits: ~15%</li> </ol>"},{"location":"research/#failure-modes","title":"Failure Modes","text":"<p>Common failure patterns:</p> <ol> <li>Ambiguous requirements (35% of failures)</li> <li>Context window overflow (25% of failures)</li> <li>Circular corrections (20% of failures)</li> <li>Resource exhaustion (10% of failures)</li> <li>Agent unavailability (10% of failures)</li> </ol>"},{"location":"research/#performance-metrics","title":"Performance Metrics","text":"<p>Average performance across 1000+ runs:</p> Metric Simple Tasks Medium Tasks Complex Tasks Iterations 5-10 15-30 40-100 Success Rate 95% 85% 70% Time (minutes) 2-5 8-15 20-60 Cost (Claude) $0.05-0.10 $0.20-0.40 $0.50-1.50"},{"location":"research/#comparative-analysis","title":"Comparative Analysis","text":""},{"location":"research/#ralph-vs-traditional-development","title":"Ralph vs. Traditional Development","text":"Aspect Ralph Technique Traditional Development Initial Setup Minimal (~5 min) Significant (hours) Iteration Speed Fast (30-60s) Varies (minutes to hours) Error Recovery Automatic Manual Context Switching None required High cognitive load Predictability Moderate High Creativity AI-driven Human-driven"},{"location":"research/#ralph-vs-other-ai-orchestration","title":"Ralph vs. Other AI Orchestration","text":"System Complexity Reliability Setup Time Flexibility Ralph Low High Minutes Moderate LangChain High Moderate Hours High AutoGPT Very High Low Hours Very High Custom Scripts Varies Varies Days Total"},{"location":"research/#mathematical-model","title":"Mathematical Model","text":""},{"location":"research/#iteration-function","title":"Iteration Function","text":"<p>The Ralph process can be modeled as:</p> <pre><code>S(n+1) = f(S(n), A(P, S(n))) + \u03b5(n)\n</code></pre> <p>Where: - S(n) = State at iteration n - P = Prompt (constant) - A = Agent function - \u03b5(n) = Error term at iteration n - f = State transition function</p>"},{"location":"research/#success-probability","title":"Success Probability","text":"<p>Probability of success after n iterations:</p> <pre><code>P(success|n) = 1 - (1 - p)^n\n</code></pre> <p>Where p is the per-iteration success probability (typically 0.1-0.3)</p>"},{"location":"research/#optimal-checkpoint-interval","title":"Optimal Checkpoint Interval","text":"<p>Checkpoint interval optimization:</p> <pre><code>C_optimal = \u221a(2 \u00d7 T_checkpoint / T_iteration)\n</code></pre> <p>Where: - T_checkpoint = Time to create checkpoint - T_iteration = Average iteration time</p>"},{"location":"research/#psychological-aspects","title":"Psychological Aspects","text":""},{"location":"research/#cognitive-load-reduction","title":"Cognitive Load Reduction","text":"<p>Ralph reduces cognitive load by:</p> <ol> <li>Externalizing memory - Git and state files remember everything</li> <li>Eliminating context switches - Set and forget operation</li> <li>Removing decision fatigue - AI makes implementation decisions</li> <li>Providing clear progress - Visible iteration count and metrics</li> </ol>"},{"location":"research/#trust-and-control","title":"Trust and Control","text":"<p>The technique balances:</p> <ul> <li>Automation (AI does the work) with Control (human defines requirements)</li> <li>Trust (letting AI iterate) with Verification (checkpoints and review)</li> <li>Speed (rapid iterations) with Safety (limits and constraints)</li> </ul>"},{"location":"research/#future-research-directions","title":"Future Research Directions","text":""},{"location":"research/#potential-improvements","title":"Potential Improvements","text":"<ol> <li>Adaptive iteration strategies - Dynamic adjustment based on progress</li> <li>Multi-agent collaboration - Different agents for different task phases</li> <li>Learned prompt optimization - Automatic prompt refinement</li> <li>Predictive failure detection - Early warning for likely failures</li> <li>Context-aware checkpointing - Smart checkpoint timing</li> </ol>"},{"location":"research/#open-questions","title":"Open Questions","text":"<ol> <li>How can we formalize prompt quality metrics?</li> <li>What is the theoretical limit of task complexity for this approach?</li> <li>Can we predict iteration count from prompt analysis?</li> <li>How do different agent architectures affect convergence?</li> <li>What is the optimal balance between automation and human oversight?</li> </ol>"},{"location":"research/#case-studies","title":"Case Studies","text":""},{"location":"research/#case-1-api-development","title":"Case 1: API Development","text":"<p>Task: Build REST API with 10 endpoints Iterations: 28 Time: 12 minutes Result: Fully functional API with tests</p> <p>Key insights: - Clear endpoint specifications reduced iterations - Agent understood RESTful conventions - Test generation happened naturally</p>"},{"location":"research/#case-2-data-analysis-script","title":"Case 2: Data Analysis Script","text":"<p>Task: Analyze CSV and generate reports Iterations: 15 Time: 7 minutes Result: Complete analysis pipeline</p> <p>Key insights: - Data structure clarity was critical - Visualization requirements needed examples - Agent leveraged common libraries effectively</p>"},{"location":"research/#case-3-cli-tool","title":"Case 3: CLI Tool","text":"<p>Task: Create file management CLI Iterations: 42 Time: 18 minutes Result: Full-featured CLI with help system</p> <p>Key insights: - Command structure specification was vital - Error handling emerged through iteration - Documentation generated alongside code</p>"},{"location":"research/#implementation-variations","title":"Implementation Variations","text":""},{"location":"research/#minimal-implementation-50-lines","title":"Minimal Implementation (50 lines)","text":"<pre><code>while not task_complete:\n    run_agent()\n    check_completion()\n</code></pre>"},{"location":"research/#standard-implementation-400-lines","title":"Standard Implementation (400 lines)","text":"<ul> <li>Add error handling</li> <li>Add checkpointing</li> <li>Add metrics</li> <li>Add configuration</li> </ul>"},{"location":"research/#enterprise-implementation-2000-lines","title":"Enterprise Implementation (2000+ lines)","text":"<ul> <li>Add monitoring</li> <li>Add security</li> <li>Add audit logging</li> <li>Add distributed execution</li> <li>Add web interface</li> </ul>"},{"location":"research/#philosophical-implications","title":"Philosophical Implications","text":""},{"location":"research/#on-determinism","title":"On Determinism","text":"<p>Ralph embraces \"deterministic failure\" - the idea that it's better to fail in predictable ways than to have unpredictable success. This aligns with engineering principles of:</p> <ul> <li>Reproducibility over creativity</li> <li>Reliability over optimality</li> <li>Simplicity over sophistication</li> </ul>"},{"location":"research/#on-intelligence","title":"On Intelligence","text":"<p>The technique raises questions about:</p> <ul> <li>What constitutes \"understanding\" a task?</li> <li>Is iteration without comprehension still intelligence?</li> <li>How do we measure AI contribution vs. human specification?</li> </ul>"},{"location":"research/#on-automation","title":"On Automation","text":"<p>Ralph represents a middle ground:</p> <ul> <li>Not fully autonomous (requires human prompts)</li> <li>Not fully manual (AI does implementation)</li> <li>Collaborative human-AI system</li> </ul>"},{"location":"research/#conclusion","title":"Conclusion","text":"<p>The Ralph Wiggum technique succeeds because it:</p> <ol> <li>Embraces simplicity in a complex world</li> <li>Leverages persistence over perfection</li> <li>Uses proven tools (Git, CLI) effectively</li> <li>Balances automation with human control</li> <li>Fails gracefully and recoverably</li> </ol> <p>As Geoffrey Huntley noted: \"Sometimes the simplest solution is the best solution, even if it seems 'unpossible' at first.\"</p>"},{"location":"research/#references","title":"References","text":"<ol> <li>Huntley, G. (2024). \"The Ralph Wiggum Technique\". https://ghuntley.com/ralph/</li> <li>Reed, H. (2024). \"Spec-Driven Development with AI\". https://harper.blog/</li> <li>Brooks, F. (1975). \"The Mythical Man-Month\" - On software complexity</li> <li>Simon, H. (1996). \"The Sciences of the Artificial\" - On bounded rationality</li> <li>Wiener, N. (1948). \"Cybernetics\" - On feedback systems</li> </ol>"},{"location":"research/#further-reading","title":"Further Reading","text":"<ul> <li>Original Ralph Wiggum article</li> <li>Ralph Orchestrator GitHub</li> <li>AI Agent Comparison Study</li> <li>Implementation Best Practices</li> </ul>"},{"location":"testing/","title":"Testing Guide","text":""},{"location":"testing/#overview","title":"Overview","text":"<p>This guide covers testing strategies, tools, and best practices for Ralph Orchestrator development and deployment.</p>"},{"location":"testing/#test-suite-structure","title":"Test Suite Structure","text":"<pre><code>tests/\n\u251c\u2500\u2500 unit/                 # Unit tests\n\u2502   \u251c\u2500\u2500 test_orchestrator.py\n\u2502   \u251c\u2500\u2500 test_agents.py\n\u2502   \u251c\u2500\u2500 test_config.py\n\u2502   \u2514\u2500\u2500 test_metrics.py\n\u251c\u2500\u2500 integration/          # Integration tests\n\u2502   \u251c\u2500\u2500 test_full_cycle.py\n\u2502   \u251c\u2500\u2500 test_git_operations.py\n\u2502   \u2514\u2500\u2500 test_agent_execution.py\n\u251c\u2500\u2500 e2e/                  # End-to-end tests\n\u2502   \u251c\u2500\u2500 test_cli.py\n\u2502   \u2514\u2500\u2500 test_scenarios.py\n\u251c\u2500\u2500 fixtures/             # Test fixtures\n\u2502   \u251c\u2500\u2500 prompts/\n\u2502   \u2514\u2500\u2500 configs/\n\u2514\u2500\u2500 conftest.py          # Pytest configuration\n</code></pre>"},{"location":"testing/#running-tests","title":"Running Tests","text":""},{"location":"testing/#all-tests","title":"All Tests","text":"<pre><code># Run all tests\npytest\n\n# With coverage\npytest --cov=ralph_orchestrator --cov-report=html\n\n# Verbose output\npytest -v\n\n# Specific test file\npytest tests/unit/test_orchestrator.py\n</code></pre>"},{"location":"testing/#test-categories","title":"Test Categories","text":"<pre><code># Unit tests only\npytest tests/unit/\n\n# Integration tests\npytest tests/integration/\n\n# End-to-end tests\npytest tests/e2e/\n\n# Fast tests (exclude slow)\npytest -m \"not slow\"\n</code></pre>"},{"location":"testing/#unit-tests","title":"Unit Tests","text":""},{"location":"testing/#testing-the-orchestrator","title":"Testing the Orchestrator","text":"<pre><code>import pytest\nfrom unittest.mock import Mock, patch, MagicMock\nfrom ralph_orchestrator import RalphOrchestrator\n\nclass TestRalphOrchestrator:\n    \"\"\"Unit tests for RalphOrchestrator\"\"\"\n\n    @pytest.fixture\n    def orchestrator(self):\n        \"\"\"Create orchestrator instance\"\"\"\n        config = {\n            'agent': 'claude',\n            'prompt_file': 'test.md',\n            'max_iterations': 10,\n            'dry_run': True\n        }\n        return RalphOrchestrator(config)\n\n    def test_initialization(self, orchestrator):\n        \"\"\"Test orchestrator initialization\"\"\"\n        assert orchestrator.config['agent'] == 'claude'\n        assert orchestrator.config['max_iterations'] == 10\n        assert orchestrator.iteration_count == 0\n\n    @patch('subprocess.run')\n    def test_execute_agent(self, mock_run, orchestrator):\n        \"\"\"Test agent execution\"\"\"\n        mock_run.return_value = MagicMock(\n            returncode=0,\n            stdout='Task completed',\n            stderr=''\n        )\n\n        success, output = orchestrator.execute_agent('claude', 'test.md')\n\n        assert success is True\n        assert output == 'Task completed'\n        mock_run.assert_called_once()\n\n    def test_check_task_complete(self, orchestrator, tmp_path):\n        \"\"\"Test task completion check\"\"\"\n        # Create prompt file without marker\n        prompt_file = tmp_path / \"prompt.md\"\n        prompt_file.write_text(\"Do something\")\n        assert orchestrator.check_task_complete(str(prompt_file)) is False\n\n        # Add completion marker\n        prompt_file.write_text(\"Do something\\n&lt;!-- TASK_COMPLETE --&gt;\")\n        assert orchestrator.check_task_complete(str(prompt_file)) is True\n\n    @patch('ralph_orchestrator.RalphOrchestrator.execute_agent')\n    def test_iteration_limit(self, mock_execute, orchestrator):\n        \"\"\"Test max iterations limit\"\"\"\n        mock_execute.return_value = (True, \"Output\")\n        orchestrator.config['max_iterations'] = 2\n\n        result = orchestrator.run()\n\n        assert result['iterations'] == 2\n        assert result['success'] is False\n        assert 'max_iterations' in result['stop_reason']\n</code></pre>"},{"location":"testing/#testing-agents","title":"Testing Agents","text":"<pre><code>import pytest\nfrom unittest.mock import patch, MagicMock\nfrom agents import ClaudeAgent, GeminiAgent, AgentManager\n\nclass TestAgents:\n    \"\"\"Unit tests for AI agents\"\"\"\n\n    @patch('shutil.which')\n    def test_claude_availability(self, mock_which):\n        \"\"\"Test Claude agent availability check\"\"\"\n        mock_which.return_value = '/usr/bin/claude'\n        agent = ClaudeAgent()\n        assert agent.available is True\n\n        mock_which.return_value = None\n        agent = ClaudeAgent()\n        assert agent.available is False\n\n    @patch('subprocess.run')\n    def test_agent_execution_timeout(self, mock_run):\n        \"\"\"Test agent timeout handling\"\"\"\n        mock_run.side_effect = subprocess.TimeoutExpired('cmd', 300)\n\n        agent = ClaudeAgent()\n        success, output = agent.execute('prompt.md')\n\n        assert success is False\n        assert 'timeout' in output.lower()\n\n    def test_agent_manager_auto_select(self):\n        \"\"\"Test automatic agent selection\"\"\"\n        manager = AgentManager()\n\n        with patch.object(manager.agents['claude'], 'available', True):\n            with patch.object(manager.agents['gemini'], 'available', False):\n                agent = manager.get_agent('auto')\n                assert agent.name == 'claude'\n</code></pre>"},{"location":"testing/#integration-tests","title":"Integration Tests","text":""},{"location":"testing/#full-cycle-test","title":"Full Cycle Test","text":"<pre><code>import pytest\nimport tempfile\nimport shutil\nfrom pathlib import Path\nfrom ralph_orchestrator import RalphOrchestrator\n\nclass TestIntegration:\n    \"\"\"Integration tests for full Ralph cycle\"\"\"\n\n    @pytest.fixture\n    def test_dir(self):\n        \"\"\"Create temporary test directory\"\"\"\n        temp_dir = tempfile.mkdtemp()\n        yield Path(temp_dir)\n        shutil.rmtree(temp_dir)\n\n    def test_full_execution_cycle(self, test_dir):\n        \"\"\"Test complete execution cycle\"\"\"\n        # Setup\n        prompt_file = test_dir / \"PROMPT.md\"\n        prompt_file.write_text(\"\"\"\n        Create a Python function that returns 'Hello'\n        &lt;!-- TASK_COMPLETE --&gt;\n        \"\"\")\n\n        config = {\n            'agent': 'auto',\n            'prompt_file': str(prompt_file),\n            'max_iterations': 5,\n            'working_directory': str(test_dir),\n            'dry_run': False\n        }\n\n        # Execute\n        orchestrator = RalphOrchestrator(config)\n        result = orchestrator.run()\n\n        # Verify\n        assert result['success'] is True\n        assert result['iterations'] &gt; 0\n        assert (test_dir / '.agent').exists()\n\n    @pytest.mark.slow\n    def test_checkpoint_creation(self, test_dir):\n        \"\"\"Test Git checkpoint creation\"\"\"\n        # Initialize Git repo\n        subprocess.run(['git', 'init'], cwd=test_dir)\n\n        prompt_file = test_dir / \"PROMPT.md\"\n        prompt_file.write_text(\"Test task\")\n\n        config = {\n            'prompt_file': str(prompt_file),\n            'checkpoint_interval': 1,\n            'working_directory': str(test_dir)\n        }\n\n        orchestrator = RalphOrchestrator(config)\n        orchestrator.create_checkpoint(1)\n\n        # Check Git log\n        result = subprocess.run(\n            ['git', 'log', '--oneline'],\n            cwd=test_dir,\n            capture_output=True,\n            text=True\n        )\n\n        assert 'Ralph checkpoint' in result.stdout\n</code></pre>"},{"location":"testing/#end-to-end-tests","title":"End-to-End Tests","text":""},{"location":"testing/#cli-testing","title":"CLI Testing","text":"<pre><code>import pytest\nfrom click.testing import CliRunner\nfrom ralph_cli import cli\n\nclass TestCLI:\n    \"\"\"End-to-end CLI tests\"\"\"\n\n    @pytest.fixture\n    def runner(self):\n        \"\"\"Create CLI test runner\"\"\"\n        return CliRunner()\n\n    def test_cli_help(self, runner):\n        \"\"\"Test help command\"\"\"\n        result = runner.invoke(cli, ['--help'])\n        assert result.exit_code == 0\n        assert 'Ralph Orchestrator' in result.output\n\n    def test_cli_init(self, runner):\n        \"\"\"Test init command\"\"\"\n        with runner.isolated_filesystem():\n            result = runner.invoke(cli, ['init'])\n            assert result.exit_code == 0\n            assert Path('PROMPT.md').exists()\n            assert Path('.agent').exists()\n\n    def test_cli_status(self, runner):\n        \"\"\"Test status command\"\"\"\n        with runner.isolated_filesystem():\n            # Create prompt file\n            Path('PROMPT.md').write_text('Test')\n\n            result = runner.invoke(cli, ['status'])\n            assert result.exit_code == 0\n            assert 'PROMPT.md exists' in result.output\n\n    def test_cli_run_dry(self, runner):\n        \"\"\"Test dry run\"\"\"\n        with runner.isolated_filesystem():\n            Path('PROMPT.md').write_text('Test task')\n\n            result = runner.invoke(cli, ['run', '--dry-run'])\n            assert result.exit_code == 0\n</code></pre>"},{"location":"testing/#test-fixtures","title":"Test Fixtures","text":""},{"location":"testing/#prompt-fixtures","title":"Prompt Fixtures","text":"<pre><code># tests/fixtures/prompts.py\n\nSIMPLE_TASK = \"\"\"\nCreate a Python function that adds two numbers.\n\"\"\"\n\nCOMPLEX_TASK = \"\"\"\nBuild a REST API with:\n- User authentication\n- CRUD operations\n- Database integration\n- Unit tests\n\"\"\"\n\nCOMPLETED_TASK = \"\"\"\nCreate a hello world function.\n&lt;!-- TASK_COMPLETE --&gt;\n\"\"\"\n</code></pre>"},{"location":"testing/#mock-agent","title":"Mock Agent","text":"<pre><code># tests/fixtures/mock_agent.py\n\nclass MockAgent:\n    \"\"\"Mock agent for testing\"\"\"\n\n    def __init__(self, responses=None):\n        self.responses = responses or ['Default response']\n        self.call_count = 0\n\n    def execute(self, prompt_file):\n        \"\"\"Return predetermined responses\"\"\"\n        if self.call_count &lt; len(self.responses):\n            response = self.responses[self.call_count]\n        else:\n            response = self.responses[-1]\n\n        self.call_count += 1\n        return True, response\n</code></pre>"},{"location":"testing/#performance-testing","title":"Performance Testing","text":"<pre><code>import pytest\nimport time\nfrom ralph_orchestrator import RalphOrchestrator\n\n@pytest.mark.performance\nclass TestPerformance:\n    \"\"\"Performance and load tests\"\"\"\n\n    def test_iteration_performance(self):\n        \"\"\"Test iteration execution time\"\"\"\n        config = {\n            'agent': 'auto',\n            'max_iterations': 10,\n            'dry_run': True\n        }\n\n        orchestrator = RalphOrchestrator(config)\n\n        start_time = time.time()\n        orchestrator.run()\n        execution_time = time.time() - start_time\n\n        # Should complete dry run quickly\n        assert execution_time &lt; 5.0\n\n    def test_memory_usage(self):\n        \"\"\"Test memory consumption\"\"\"\n        import psutil\n        import os\n\n        process = psutil.Process(os.getpid())\n        initial_memory = process.memory_info().rss / 1024 / 1024  # MB\n\n        # Run multiple iterations\n        config = {'max_iterations': 100, 'dry_run': True}\n        orchestrator = RalphOrchestrator(config)\n        orchestrator.run()\n\n        final_memory = process.memory_info().rss / 1024 / 1024  # MB\n        memory_increase = final_memory - initial_memory\n\n        # Memory increase should be reasonable\n        assert memory_increase &lt; 100  # Less than 100MB\n</code></pre>"},{"location":"testing/#test-coverage","title":"Test Coverage","text":""},{"location":"testing/#coverage-configuration","title":"Coverage Configuration","text":"<pre><code># .coveragerc\n[run]\nsource = ralph_orchestrator\nomit = \n    */tests/*\n    */test_*.py\n    */__pycache__/*\n\n[report]\nexclude_lines =\n    pragma: no cover\n    def __repr__\n    raise AssertionError\n    raise NotImplementedError\n    if __name__ == .__main__.:\n    if TYPE_CHECKING:\n</code></pre>"},{"location":"testing/#coverage-reports","title":"Coverage Reports","text":"<pre><code># Generate HTML coverage report\npytest --cov=ralph_orchestrator --cov-report=html\n\n# View report\nopen htmlcov/index.html\n\n# Terminal report with missing lines\npytest --cov=ralph_orchestrator --cov-report=term-missing\n</code></pre>"},{"location":"testing/#continuous-integration","title":"Continuous Integration","text":""},{"location":"testing/#github-actions","title":"GitHub Actions","text":"<pre><code># .github/workflows/test.yml\nname: Tests\n\non: [push, pull_request]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        python-version: [3.8, 3.9, 3.10, 3.11]\n\n    steps:\n    - uses: actions/checkout@v3\n\n    - name: Set up Python\n      uses: actions/setup-python@v4\n      with:\n        python-version: ${{ matrix.python-version }}\n\n    - name: Install dependencies\n      run: |\n        pip install -e .\n        pip install pytest pytest-cov\n\n    - name: Run tests\n      run: |\n        pytest --cov=ralph_orchestrator --cov-report=xml\n\n    - name: Upload coverage\n      uses: codecov/codecov-action@v3\n      with:\n        file: ./coverage.xml\n</code></pre>"},{"location":"testing/#test-best-practices","title":"Test Best Practices","text":""},{"location":"testing/#1-test-isolation","title":"1. Test Isolation","text":"<ul> <li>Each test should be independent</li> <li>Use fixtures for setup/teardown</li> <li>Clean up resources after tests</li> </ul>"},{"location":"testing/#2-mock-external-dependencies","title":"2. Mock External Dependencies","text":"<ul> <li>Mock subprocess calls</li> <li>Mock file system operations when possible</li> <li>Mock network requests</li> </ul>"},{"location":"testing/#3-test-edge-cases","title":"3. Test Edge Cases","text":"<ul> <li>Empty inputs</li> <li>Invalid configurations</li> <li>Network failures</li> <li>Timeout scenarios</li> </ul>"},{"location":"testing/#4-use-descriptive-names","title":"4. Use Descriptive Names","text":"<pre><code># Good\ndef test_orchestrator_stops_at_max_iterations():\n    pass\n\n# Bad\ndef test_1():\n    pass\n</code></pre>"},{"location":"testing/#5-arrange-act-assert-pattern","title":"5. Arrange-Act-Assert Pattern","text":"<pre><code>def test_example():\n    # Arrange\n    orchestrator = RalphOrchestrator(config)\n\n    # Act\n    result = orchestrator.run()\n\n    # Assert\n    assert result['success'] is True\n</code></pre>"},{"location":"testing/#debugging-tests","title":"Debugging Tests","text":""},{"location":"testing/#pytest-options","title":"Pytest Options","text":"<pre><code># Show print statements\npytest -s\n\n# Stop on first failure\npytest -x\n\n# Run specific test\npytest tests/test_file.py::TestClass::test_method\n\n# Run tests matching pattern\npytest -k \"test_orchestrator\"\n\n# Show local variables on failure\npytest -l\n</code></pre>"},{"location":"testing/#using-pdb","title":"Using pdb","text":"<pre><code>def test_debugging():\n    import pdb; pdb.set_trace()\n    # Debugger will stop here\n    result = some_function()\n    assert result == expected\n</code></pre>"},{"location":"troubleshooting/","title":"Troubleshooting Guide","text":""},{"location":"troubleshooting/#common-issues-and-solutions","title":"Common Issues and Solutions","text":""},{"location":"troubleshooting/#installation-issues","title":"Installation Issues","text":""},{"location":"troubleshooting/#agent-not-found","title":"Agent Not Found","text":"<p>Problem: <code>ralph: command 'claude' not found</code></p> <p>Solutions: 1. Verify agent installation:    <pre><code>which claude\nwhich gemini\nwhich q\n</code></pre></p> <ol> <li> <p>Install missing agent:    <pre><code># Claude\nnpm install -g @anthropic-ai/claude-code\n\n# Gemini\nnpm install -g @google/gemini-cli\n</code></pre></p> </li> <li> <p>Add to PATH:    <pre><code>export PATH=$PATH:/usr/local/bin\n</code></pre></p> </li> </ol>"},{"location":"troubleshooting/#permission-denied","title":"Permission Denied","text":"<p>Problem: <code>Permission denied: './ralph'</code></p> <p>Solution: <pre><code>chmod +x ralph ralph_orchestrator.py\n</code></pre></p>"},{"location":"troubleshooting/#execution-issues","title":"Execution Issues","text":""},{"location":"troubleshooting/#task-not-completing","title":"Task Not Completing","text":"<p>Problem: Ralph runs maximum iterations without completing</p> <p>Possible Causes: 1. Missing TASK_COMPLETE marker 2. Unclear task description 3. Agent unable to understand requirements</p> <p>Solutions: 1. Check if agent is adding TASK_COMPLETE:    <pre><code>grep TASK_COMPLETE PROMPT.md\n</code></pre></p> <ol> <li> <p>Simplify task description:    <pre><code># Instead of vague:\nBuild something cool\n\n# Be specific:\nCreate a Python function that returns \"Hello World\"\n</code></pre></p> </li> <li> <p>Try different agent:    <pre><code>ralph run --agent gemini\n</code></pre></p> </li> </ol>"},{"location":"troubleshooting/#agent-timeout","title":"Agent Timeout","text":"<p>Problem: <code>Agent execution timed out</code></p> <p>Solutions: 1. Increase timeout:    <pre><code># In ralph.json\n{\n  \"timeout_per_iteration\": 600\n}\n</code></pre></p> <ol> <li>Reduce prompt complexity:</li> <li>Break large tasks into smaller ones</li> <li> <p>Remove unnecessary context</p> </li> <li> <p>Check system resources:    <pre><code>htop\nfree -h\n</code></pre></p> </li> </ol>"},{"location":"troubleshooting/#repeated-errors","title":"Repeated Errors","text":"<p>Problem: Same error occurs in multiple iterations</p> <p>Solutions: 1. Check error pattern:    <pre><code>cat .agent/metrics/state_*.json | jq '.errors'\n</code></pre></p> <ol> <li> <p>Clear workspace and retry:    <pre><code>ralph clean\nralph run\n</code></pre></p> </li> <li> <p>Manual intervention:</p> </li> <li>Fix the specific issue</li> <li>Add clarification to PROMPT.md</li> <li>Resume execution</li> </ol>"},{"location":"troubleshooting/#git-issues","title":"Git Issues","text":""},{"location":"troubleshooting/#checkpoint-failed","title":"Checkpoint Failed","text":"<p>Problem: <code>Failed to create checkpoint</code></p> <p>Solutions: 1. Initialize Git repository:    <pre><code>git init\ngit add .\ngit commit -m \"Initial commit\"\n</code></pre></p> <ol> <li> <p>Check Git status:    <pre><code>git status\n</code></pre></p> </li> <li> <p>Fix Git configuration:    <pre><code>git config user.email \"you@example.com\"\ngit config user.name \"Your Name\"\n</code></pre></p> </li> </ol>"},{"location":"troubleshooting/#uncommitted-changes-warning","title":"Uncommitted Changes Warning","text":"<p>Problem: <code>Uncommitted changes detected</code></p> <p>Solutions: 1. Commit changes:    <pre><code>git add .\ngit commit -m \"Save work\"\n</code></pre></p> <ol> <li> <p>Stash changes:    <pre><code>git stash\nralph run\ngit stash pop\n</code></pre></p> </li> <li> <p>Disable Git operations:    <pre><code>ralph run --no-git\n</code></pre></p> </li> </ol>"},{"location":"troubleshooting/#context-issues","title":"Context Issues","text":""},{"location":"troubleshooting/#context-window-exceeded","title":"Context Window Exceeded","text":"<p>Problem: <code>Context window limit exceeded</code></p> <p>Symptoms: - Agent forgets earlier instructions - Incomplete responses - Errors about missing information</p> <p>Solutions: 1. Reduce file sizes:    <pre><code># Split large files\nsplit -l 500 large_file.py part_\n</code></pre></p> <ol> <li> <p>Use more concise prompt:    <pre><code># Remove unnecessary details\n# Focus on current task\n</code></pre></p> </li> <li> <p>Switch to higher-context agent:    <pre><code># Claude has 200K context\nralph run --agent claude\n</code></pre></p> </li> <li> <p>Clear iteration history:    <pre><code>rm .agent/prompts/prompt_*.md\n</code></pre></p> </li> </ol>"},{"location":"troubleshooting/#performance-issues","title":"Performance Issues","text":""},{"location":"troubleshooting/#slow-execution","title":"Slow Execution","text":"<p>Problem: Iterations taking too long</p> <p>Solutions: 1. Check system resources:    <pre><code>top\ndf -h\niostat\n</code></pre></p> <ol> <li>Reduce parallel operations:</li> <li>Close other applications</li> <li> <p>Limit background processes</p> </li> <li> <p>Use faster agent:    <pre><code># Q is typically faster\nralph run --agent q\n</code></pre></p> </li> </ol>"},{"location":"troubleshooting/#high-memory-usage","title":"High Memory Usage","text":"<p>Problem: Ralph consuming excessive memory</p> <p>Solutions: 1. Set resource limits:    <pre><code># In ralph.json\n{\n  \"resource_limits\": {\n    \"memory_mb\": 2048\n  }\n}\n</code></pre></p> <ol> <li> <p>Clean old state files:    <pre><code>find .agent -name \"*.json\" -mtime +7 -delete\n</code></pre></p> </li> <li> <p>Restart Ralph:    <pre><code>pkill -f ralph_orchestrator\nralph run\n</code></pre></p> </li> </ol>"},{"location":"troubleshooting/#state-and-metrics-issues","title":"State and Metrics Issues","text":""},{"location":"troubleshooting/#corrupted-state-file","title":"Corrupted State File","text":"<p>Problem: <code>Invalid state file</code></p> <p>Solutions: 1. Remove corrupted file:    <pre><code>rm .agent/metrics/state_latest.json\n</code></pre></p> <ol> <li> <p>Restore from backup:    <pre><code>cp .agent/metrics/state_*.json .agent/metrics/state_latest.json\n</code></pre></p> </li> <li> <p>Reset state:    <pre><code>ralph clean\n</code></pre></p> </li> </ol>"},{"location":"troubleshooting/#missing-metrics","title":"Missing Metrics","text":"<p>Problem: No metrics being collected</p> <p>Solutions: 1. Check metrics directory:    <pre><code>ls -la .agent/metrics/\n</code></pre></p> <ol> <li> <p>Create directory if missing:    <pre><code>mkdir -p .agent/metrics\n</code></pre></p> </li> <li> <p>Check permissions:    <pre><code>chmod 755 .agent/metrics\n</code></pre></p> </li> </ol>"},{"location":"troubleshooting/#error-messages","title":"Error Messages","text":""},{"location":"troubleshooting/#common-error-codes","title":"Common Error Codes","text":"Error Meaning Solution <code>Exit code 1</code> General failure Check logs for details <code>Exit code 130</code> Interrupted (Ctrl+C) Normal interruption <code>Exit code 137</code> Killed (out of memory) Increase memory limits <code>Exit code 124</code> Timeout Increase timeout value"},{"location":"troubleshooting/#agent-specific-errors","title":"Agent-Specific Errors","text":""},{"location":"troubleshooting/#claude-errors","title":"Claude Errors","text":"<p><pre><code>\"Rate limit exceeded\"\n</code></pre> Solution: Add delay between iterations or upgrade API plan</p> <p><pre><code>\"Invalid API key\"\n</code></pre> Solution: Check Claude CLI configuration</p>"},{"location":"troubleshooting/#gemini-errors","title":"Gemini Errors","text":"<p><pre><code>\"Quota exceeded\"\n</code></pre> Solution: Wait for quota reset or upgrade plan</p> <p><pre><code>\"Model not available\"\n</code></pre> Solution: Check Gemini CLI version and update</p>"},{"location":"troubleshooting/#q-chat-errors","title":"Q Chat Errors","text":"<p><pre><code>\"Connection refused\"\n</code></pre> Solution: Ensure Q service is running</p>"},{"location":"troubleshooting/#debug-mode","title":"Debug Mode","text":""},{"location":"troubleshooting/#enable-verbose-logging","title":"Enable Verbose Logging","text":"<pre><code># Maximum verbosity\nralph run --verbose\n\n# With debug environment\nDEBUG=1 ralph run\n\n# Save logs\nralph run --verbose 2&gt;&amp;1 | tee debug.log\n</code></pre>"},{"location":"troubleshooting/#inspect-execution","title":"Inspect Execution","text":"<pre><code># Add debug points in PROMPT.md\nprint(\"DEBUG: Reached checkpoint 1\")\n</code></pre>"},{"location":"troubleshooting/#trace-execution","title":"Trace Execution","text":"<pre><code># Trace system calls\nstrace -o trace.log ralph run\n\n# Profile Python execution\npython -m cProfile ralph_orchestrator.py\n</code></pre>"},{"location":"troubleshooting/#recovery-procedures","title":"Recovery Procedures","text":""},{"location":"troubleshooting/#from-failed-state","title":"From Failed State","text":"<ol> <li> <p>Save current state:    <pre><code>cp -r .agent .agent.backup\n</code></pre></p> </li> <li> <p>Analyze failure:    <pre><code>tail -n 100 .agent/logs/ralph.log\n</code></pre></p> </li> <li> <p>Fix issue:</p> </li> <li>Update PROMPT.md</li> <li>Fix code errors</li> <li> <p>Clear problematic files</p> </li> <li> <p>Resume or restart:    <pre><code># Resume from checkpoint\nralph run\n\n# Or start fresh\nralph clean &amp;&amp; ralph run\n</code></pre></p> </li> </ol>"},{"location":"troubleshooting/#from-git-checkpoint","title":"From Git Checkpoint","text":"<pre><code># List checkpoints\ngit log --oneline | grep checkpoint\n\n# Reset to checkpoint\ngit reset --hard &lt;commit-hash&gt;\n\n# Resume execution\nralph run\n</code></pre>"},{"location":"troubleshooting/#getting-help","title":"Getting Help","text":""},{"location":"troubleshooting/#self-diagnosis","title":"Self-Diagnosis","text":"<p>Run the diagnostic script: <pre><code>cat &gt; diagnose.sh &lt;&lt; 'EOF'\n#!/bin/bash\necho \"Ralph Orchestrator Diagnostic\"\necho \"============================\"\necho \"Agents available:\"\nwhich claude &amp;&amp; echo \"  \u2713 Claude\" || echo \"  \u2717 Claude\"\nwhich gemini &amp;&amp; echo \"  \u2713 Gemini\" || echo \"  \u2717 Gemini\"\nwhich q &amp;&amp; echo \"  \u2713 Q\" || echo \"  \u2717 Q\"\necho \"\"\necho \"Git status:\"\ngit status --short\necho \"\"\necho \"Ralph status:\"\n./ralph status\necho \"\"\necho \"Recent errors:\"\ngrep ERROR .agent/logs/*.log 2&gt;/dev/null | tail -5\nEOF\nchmod +x diagnose.sh\n./diagnose.sh\n</code></pre></p>"},{"location":"troubleshooting/#community-support","title":"Community Support","text":"<ol> <li>GitHub Issues: Report bugs</li> <li>Discussions: Ask questions</li> <li>Discord: Join the community chat</li> </ol>"},{"location":"troubleshooting/#reporting-bugs","title":"Reporting Bugs","text":"<p>Include in bug reports: 1. Ralph version: <code>ralph --version</code> 2. Agent versions 3. Error messages 4. PROMPT.md content 5. Diagnostic output 6. Steps to reproduce</p>"},{"location":"troubleshooting/#prevention-tips","title":"Prevention Tips","text":""},{"location":"troubleshooting/#best-practices","title":"Best Practices","text":"<ol> <li>Start simple: Test with basic tasks first</li> <li>Regular checkpoints: Use default 5-iteration interval</li> <li>Monitor progress: Check status frequently</li> <li>Version control: Commit before running Ralph</li> <li>Resource limits: Set appropriate limits</li> <li>Clear requirements: Write specific, testable criteria</li> </ol>"},{"location":"troubleshooting/#pre-flight-checklist","title":"Pre-flight Checklist","text":"<p>Before running Ralph: - [ ] PROMPT.md is clear and specific - [ ] Git repository is clean - [ ] Agents are installed and working - [ ] Sufficient disk space available - [ ] No sensitive data in prompt - [ ] Backup important files</p>"},{"location":"03-best-practices/best-practices/","title":"Implementation Best Practices","text":""},{"location":"03-best-practices/best-practices/#overview","title":"Overview","text":"<p>This guide outlines best practices for implementing and using Ralph Orchestrator in production environments.</p>"},{"location":"03-best-practices/best-practices/#architecture-best-practices","title":"Architecture Best Practices","text":""},{"location":"03-best-practices/best-practices/#1-modular-design","title":"1. Modular Design","text":"<ul> <li>Keep agent implementations separate and modular</li> <li>Use dependency injection for flexibility</li> <li>Implement clear interfaces between components</li> </ul>"},{"location":"03-best-practices/best-practices/#2-error-handling","title":"2. Error Handling","text":"<pre><code># Good practice: Comprehensive error handling\ntry:\n    response = await agent.process(prompt)\nexcept AgentTimeoutError as e:\n    logger.error(f\"Agent timeout: {e}\")\n    return fallback_response()\nexcept AgentAPIError as e:\n    logger.error(f\"API error: {e}\")\n    return handle_api_error(e)\n</code></pre>"},{"location":"03-best-practices/best-practices/#3-configuration-management","title":"3. Configuration Management","text":"<ul> <li>Use environment variables for sensitive data</li> <li>Implement configuration validation</li> <li>Support multiple configuration profiles</li> </ul>"},{"location":"03-best-practices/best-practices/#performance-optimization","title":"Performance Optimization","text":""},{"location":"03-best-practices/best-practices/#1-caching-strategies","title":"1. Caching Strategies","text":"<pre><code># Implement intelligent caching\nfrom functools import lru_cache\n\n@lru_cache(maxsize=128)\ndef get_agent_response(prompt_hash):\n    return agent.process(prompt)\n</code></pre>"},{"location":"03-best-practices/best-practices/#2-connection-pooling","title":"2. Connection Pooling","text":"<ul> <li>Reuse HTTP connections</li> <li>Implement connection limits</li> <li>Use async operations where possible</li> </ul>"},{"location":"03-best-practices/best-practices/#3-rate-limiting","title":"3. Rate Limiting","text":"<pre><code># Implement rate limiting\nfrom asyncio import Semaphore\n\nrate_limiter = Semaphore(10)  # Max 10 concurrent requests\n\nasync def make_request():\n    async with rate_limiter:\n        return await agent.process(prompt)\n</code></pre>"},{"location":"03-best-practices/best-practices/#security-best-practices","title":"Security Best Practices","text":""},{"location":"03-best-practices/best-practices/#1-api-key-management","title":"1. API Key Management","text":"<ul> <li>Never hardcode API keys</li> <li>Use secure key storage solutions</li> <li>Rotate keys regularly</li> </ul>"},{"location":"03-best-practices/best-practices/#2-input-validation","title":"2. Input Validation","text":"<pre><code># Always validate and sanitize inputs\ndef validate_prompt(prompt: str) -&gt; str:\n    if len(prompt) &gt; MAX_PROMPT_LENGTH:\n        raise ValueError(\"Prompt too long\")\n\n    # Remove potentially harmful content\n    sanitized = sanitize_input(prompt)\n    return sanitized\n</code></pre>"},{"location":"03-best-practices/best-practices/#3-output-filtering","title":"3. Output Filtering","text":"<ul> <li>Filter sensitive information from responses</li> <li>Implement content moderation</li> <li>Log security events</li> </ul>"},{"location":"03-best-practices/best-practices/#monitoring-and-observability","title":"Monitoring and Observability","text":""},{"location":"03-best-practices/best-practices/#1-structured-logging","title":"1. Structured Logging","text":"<pre><code>import structlog\n\nlogger = structlog.get_logger()\n\nlogger.info(\"agent_request\", \n    agent_type=\"claude\",\n    prompt_length=len(prompt),\n    user_id=user_id,\n    timestamp=datetime.utcnow()\n)\n</code></pre>"},{"location":"03-best-practices/best-practices/#2-metrics-collection","title":"2. Metrics Collection","text":"<ul> <li>Track response times</li> <li>Monitor error rates</li> <li>Measure token usage</li> </ul>"},{"location":"03-best-practices/best-practices/#3-health-checks","title":"3. Health Checks","text":"<pre><code># Implement health check endpoints\nasync def health_check():\n    checks = {\n        \"database\": await check_db_connection(),\n        \"agents\": await check_agent_availability(),\n        \"cache\": await check_cache_status()\n    }\n    return all(checks.values())\n</code></pre>"},{"location":"03-best-practices/best-practices/#testing-strategies","title":"Testing Strategies","text":""},{"location":"03-best-practices/best-practices/#1-unit-testing","title":"1. Unit Testing","text":"<pre><code># Test individual components\ndef test_prompt_validation():\n    valid_prompt = \"Calculate 2+2\"\n    assert validate_prompt(valid_prompt) == valid_prompt\n\n    invalid_prompt = \"x\" * (MAX_PROMPT_LENGTH + 1)\n    with pytest.raises(ValueError):\n        validate_prompt(invalid_prompt)\n</code></pre>"},{"location":"03-best-practices/best-practices/#2-integration-testing","title":"2. Integration Testing","text":"<ul> <li>Test agent interactions</li> <li>Verify error handling</li> <li>Test edge cases</li> </ul>"},{"location":"03-best-practices/best-practices/#3-load-testing","title":"3. Load Testing","text":"<pre><code># Use tools like locust for load testing\nlocust -f load_test.py --host=http://localhost:8000\n</code></pre>"},{"location":"03-best-practices/best-practices/#deployment-best-practices","title":"Deployment Best Practices","text":""},{"location":"03-best-practices/best-practices/#1-container-strategy","title":"1. Container Strategy","text":"<pre><code># Multi-stage build for smaller images\nFROM python:3.11 as builder\nWORKDIR /app\nCOPY requirements.txt .\nRUN pip install --user -r requirements.txt\n\nFROM python:3.11-slim\nCOPY --from=builder /root/.local /root/.local\nCOPY . .\nCMD [\"python\", \"-m\", \"ralph_orchestrator\"]\n</code></pre>"},{"location":"03-best-practices/best-practices/#2-scaling-considerations","title":"2. Scaling Considerations","text":"<ul> <li>Implement horizontal scaling</li> <li>Use load balancers</li> <li>Consider serverless options</li> </ul>"},{"location":"03-best-practices/best-practices/#3-blue-green-deployments","title":"3. Blue-Green Deployments","text":"<ul> <li>Minimize downtime</li> <li>Enable quick rollbacks</li> <li>Test in production-like environments</li> </ul>"},{"location":"03-best-practices/best-practices/#common-pitfalls-to-avoid","title":"Common Pitfalls to Avoid","text":""},{"location":"03-best-practices/best-practices/#1-over-engineering","title":"1. Over-Engineering","text":"<ul> <li>Start simple and iterate</li> <li>Don't optimize prematurely</li> <li>Focus on core functionality first</li> </ul>"},{"location":"03-best-practices/best-practices/#2-ignoring-rate-limits","title":"2. Ignoring Rate Limits","text":"<ul> <li>Always respect API rate limits</li> <li>Implement exponential backoff</li> <li>Monitor quota usage</li> </ul>"},{"location":"03-best-practices/best-practices/#3-poor-error-messages","title":"3. Poor Error Messages","text":"<pre><code># Bad\nexcept Exception:\n    return \"Error occurred\"\n\n# Good\nexcept ValueError as e:\n    return f\"Invalid input: {e}\"\n</code></pre>"},{"location":"03-best-practices/best-practices/#maintenance-guidelines","title":"Maintenance Guidelines","text":""},{"location":"03-best-practices/best-practices/#1-regular-updates","title":"1. Regular Updates","text":"<ul> <li>Keep dependencies updated</li> <li>Monitor security advisories</li> <li>Test updates in staging first</li> </ul>"},{"location":"03-best-practices/best-practices/#2-documentation","title":"2. Documentation","text":"<ul> <li>Maintain up-to-date documentation</li> <li>Document configuration changes</li> <li>Keep runbooks current</li> </ul>"},{"location":"03-best-practices/best-practices/#3-backup-and-recovery","title":"3. Backup and Recovery","text":"<ul> <li>Implement regular backups</li> <li>Test recovery procedures</li> <li>Document disaster recovery plans</li> </ul>"},{"location":"03-best-practices/best-practices/#conclusion","title":"Conclusion","text":"<p>Following these best practices will help ensure your Ralph Orchestrator implementation is: - Reliable and performant - Secure and maintainable - Scalable and observable</p> <p>Remember to adapt these practices to your specific use case and requirements.</p>"},{"location":"03-best-practices/best-practices/#see-also","title":"See Also","text":"<ul> <li>Configuration Guide</li> <li>Security Documentation</li> <li>Performance Tuning</li> </ul>"},{"location":"06-analysis/comparison-matrix/","title":"AI Agent Comparison Matrix","text":""},{"location":"06-analysis/comparison-matrix/#overview","title":"Overview","text":"<p>This document provides a comprehensive comparison of different AI agents and their capabilities when integrated with Ralph Orchestrator.</p>"},{"location":"06-analysis/comparison-matrix/#agent-comparison-table","title":"Agent Comparison Table","text":"Feature Claude Q GPT-4 Gemini Context Window 200K tokens Varies 128K tokens 1M tokens Code Generation Excellent Good Excellent Good Reasoning Superior Good Excellent Good Speed Fast Very Fast Moderate Fast Cost Moderate Low High Moderate API Reliability High High High High"},{"location":"06-analysis/comparison-matrix/#integration-complexity","title":"Integration Complexity","text":""},{"location":"06-analysis/comparison-matrix/#claude-integration","title":"Claude Integration","text":"<ul> <li>Complexity: Low</li> <li>Setup Time: ~30 minutes</li> <li>Documentation: Excellent</li> <li>Community Support: Growing</li> </ul>"},{"location":"06-analysis/comparison-matrix/#q-integration","title":"Q Integration","text":"<ul> <li>Complexity: Low</li> <li>Setup Time: ~20 minutes</li> <li>Documentation: Good</li> <li>Community Support: Established</li> </ul>"},{"location":"06-analysis/comparison-matrix/#gpt-4-integration","title":"GPT-4 Integration","text":"<ul> <li>Complexity: Medium</li> <li>Setup Time: ~45 minutes</li> <li>Documentation: Excellent</li> <li>Community Support: Large</li> </ul>"},{"location":"06-analysis/comparison-matrix/#gemini-integration","title":"Gemini Integration","text":"<ul> <li>Complexity: Medium</li> <li>Setup Time: ~40 minutes</li> <li>Documentation: Good</li> <li>Community Support: Growing</li> </ul>"},{"location":"06-analysis/comparison-matrix/#use-case-recommendations","title":"Use Case Recommendations","text":""},{"location":"06-analysis/comparison-matrix/#best-for-code-generation","title":"Best for Code Generation","text":"<ol> <li>Claude: Best for complex reasoning and code architecture</li> <li>GPT-4: Excellent for diverse programming languages</li> <li>Gemini: Good for large context requirements</li> </ol>"},{"location":"06-analysis/comparison-matrix/#best-for-speed","title":"Best for Speed","text":"<ol> <li>Q: Fastest response times</li> <li>Claude: Quick processing with quality</li> <li>Gemini: Fast with large contexts</li> </ol>"},{"location":"06-analysis/comparison-matrix/#best-for-cost-effectiveness","title":"Best for Cost-Effectiveness","text":"<ol> <li>Q: Most economical option</li> <li>Claude: Good balance of cost and capability</li> <li>Gemini: Reasonable for large-scale operations</li> </ol>"},{"location":"06-analysis/comparison-matrix/#performance-metrics","title":"Performance Metrics","text":""},{"location":"06-analysis/comparison-matrix/#response-time-average","title":"Response Time (Average)","text":"<ul> <li>Q: 0.5-1 seconds</li> <li>Claude: 1-2 seconds</li> <li>Gemini: 1-2 seconds</li> <li>GPT-4: 2-4 seconds</li> </ul>"},{"location":"06-analysis/comparison-matrix/#accuracy-rates","title":"Accuracy Rates","text":"<ul> <li>Claude: 95% for code tasks</li> <li>GPT-4: 94% for code tasks</li> <li>Gemini: 92% for code tasks</li> <li>Q: 90% for code tasks</li> </ul>"},{"location":"06-analysis/comparison-matrix/#context-retention","title":"Context Retention","text":"<ul> <li>Gemini: Excellent (1M tokens)</li> <li>Claude: Very Good (200K tokens)</li> <li>GPT-4: Good (128K tokens)</li> <li>Q: Variable</li> </ul>"},{"location":"06-analysis/comparison-matrix/#conclusion","title":"Conclusion","text":"<p>The choice of AI agent depends on your specific requirements: - Choose Claude for complex reasoning and balanced performance - Choose Q for speed and cost-effectiveness - Choose GPT-4 for maximum capability across diverse tasks - Choose Gemini for large context window requirements</p>"},{"location":"06-analysis/comparison-matrix/#see-also","title":"See Also","text":"<ul> <li>Ralph Orchestrator Configuration</li> <li>Agent Integration Guide</li> <li>Performance Optimization</li> </ul>"},{"location":"advanced/architecture/","title":"System Architecture","text":""},{"location":"advanced/architecture/#overview","title":"Overview","text":"<p>Ralph Orchestrator implements a simple yet effective architecture based on the Ralph Wiggum technique - a continuous loop pattern that runs AI agents until task completion.</p>"},{"location":"advanced/architecture/#core-components","title":"Core Components","text":""},{"location":"advanced/architecture/#1-orchestration-engine","title":"1. Orchestration Engine","text":"<p>The heart of Ralph is the orchestration loop in <code>ralph_orchestrator.py</code>:</p> <pre><code>while not task_complete:\n    execute_agent()\n    check_completion()\n    handle_errors()\n    checkpoint_if_needed()\n</code></pre>"},{"location":"advanced/architecture/#2-agent-abstraction-layer","title":"2. Agent Abstraction Layer","text":"<p>Ralph supports multiple AI agents through a unified interface:</p> <ul> <li>Claude (Anthropic Claude Code CLI)</li> <li>Q Chat (Q CLI tool) </li> <li>Gemini (Google Gemini CLI)</li> </ul> <p>Each agent is executed through subprocess calls with consistent error handling and output capture.</p>"},{"location":"advanced/architecture/#3-state-management","title":"3. State Management","text":"<pre><code>.agent/\n\u251c\u2500\u2500 metrics/        # Performance and state data\n\u251c\u2500\u2500 checkpoints/    # Git checkpoint markers\n\u251c\u2500\u2500 prompts/        # Archived prompt history\n\u2514\u2500\u2500 plans/          # Agent planning documents\n</code></pre>"},{"location":"advanced/architecture/#4-git-integration","title":"4. Git Integration","text":"<p>Ralph uses Git for: - Checkpointing: Regular commits for recovery - History: Track code evolution - Rollback: Reset to last known good state</p>"},{"location":"advanced/architecture/#system-flow","title":"System Flow","text":"<pre><code>graph TD\n    A[Start] --&gt; B[Load Configuration]\n    B --&gt; C[Detect Available Agents]\n    C --&gt; D[Initialize Workspace]\n    D --&gt; E[Read PROMPT.md]\n    E --&gt; F{Task Complete?}\n    F --&gt;|No| G[Execute Agent]\n    G --&gt; H[Process Output]\n    H --&gt; I{Error?}\n    I --&gt;|Yes| J[Retry Logic]\n    I --&gt;|No| K[Update State]\n    J --&gt; L{Max Retries?}\n    L --&gt;|No| G\n    L --&gt;|Yes| M[Stop]\n    K --&gt; N{Checkpoint Interval?}\n    N --&gt;|Yes| O[Create Git Checkpoint]\n    N --&gt;|No| E\n    O --&gt; E\n    F --&gt;|Yes| P[Final Checkpoint]\n    P --&gt; Q[End]</code></pre>"},{"location":"advanced/architecture/#design-principles","title":"Design Principles","text":""},{"location":"advanced/architecture/#1-simplicity-over-complexity","title":"1. Simplicity Over Complexity","text":"<ul> <li>Core orchestrator is ~400 lines of Python</li> <li>No external dependencies beyond AI CLI tools</li> <li>Clear, readable code structure</li> </ul>"},{"location":"advanced/architecture/#2-fail-safe-operations","title":"2. Fail-Safe Operations","text":"<ul> <li>Automatic retry with exponential backoff</li> <li>State persistence across failures</li> <li>Git checkpoints for recovery</li> </ul>"},{"location":"advanced/architecture/#3-agent-agnostic","title":"3. Agent Agnostic","text":"<ul> <li>Unified interface for all AI agents</li> <li>Auto-detection of available tools</li> <li>Graceful fallback when agents unavailable</li> </ul>"},{"location":"advanced/architecture/#4-observable-behavior","title":"4. Observable Behavior","text":"<ul> <li>Comprehensive logging</li> <li>Metrics collection</li> <li>State inspection tools</li> </ul>"},{"location":"advanced/architecture/#directory-structure","title":"Directory Structure","text":"<pre><code>ralph-orchestrator/\n\u251c\u2500\u2500 ralph_orchestrator.py     # Core orchestration engine\n\u251c\u2500\u2500 ralph                     # Bash wrapper script\n\u251c\u2500\u2500 PROMPT.md                # User task definition\n\u251c\u2500\u2500 .agent/                  # Ralph workspace\n\u2502   \u251c\u2500\u2500 metrics/            # JSON state files\n\u2502   \u2502   \u2514\u2500\u2500 state_*.json\n\u2502   \u251c\u2500\u2500 checkpoints/        # Git checkpoint markers\n\u2502   \u2502   \u2514\u2500\u2500 checkpoint_*.txt\n\u2502   \u251c\u2500\u2500 prompts/            # Archived prompts\n\u2502   \u2502   \u2514\u2500\u2500 prompt_*.md\n\u2502   \u2514\u2500\u2500 plans/              # Planning documents\n\u2502       \u2514\u2500\u2500 *.md\n\u2514\u2500\u2500 test_comprehensive.py    # Test suite\n</code></pre>"},{"location":"advanced/architecture/#key-classes-and-functions","title":"Key Classes and Functions","text":""},{"location":"advanced/architecture/#ralphorchestrator-class","title":"RalphOrchestrator Class","text":"<pre><code>class RalphOrchestrator:\n    def __init__(self, config: Dict):\n        \"\"\"Initialize orchestrator with configuration\"\"\"\n\n    def run(self) -&gt; Dict:\n        \"\"\"Main orchestration loop\"\"\"\n\n    def execute_agent(self, agent: str, prompt: str) -&gt; Tuple:\n        \"\"\"Execute AI agent with prompt\"\"\"\n\n    def check_task_complete(self, prompt_file: str) -&gt; bool:\n        \"\"\"Check if task is marked complete\"\"\"\n\n    def create_checkpoint(self, iteration: int):\n        \"\"\"Create Git checkpoint\"\"\"\n\n    def save_state(self):\n        \"\"\"Persist current state to disk\"\"\"\n</code></pre>"},{"location":"advanced/architecture/#agent-execution","title":"Agent Execution","text":"<pre><code>def execute_agent(agent: str, prompt: str) -&gt; Tuple[bool, str]:\n    \"\"\"Execute AI agent and capture output\"\"\"\n    cmd = [agent, prompt]\n    result = subprocess.run(\n        cmd,\n        capture_output=True,\n        text=True,\n        timeout=300\n    )\n    return result.returncode == 0, result.stdout\n</code></pre>"},{"location":"advanced/architecture/#error-handling","title":"Error Handling","text":""},{"location":"advanced/architecture/#retry-strategy","title":"Retry Strategy","text":"<ol> <li>Initial attempt</li> <li>Exponential backoff (2, 4, 8, 16 seconds)</li> <li>Maximum 5 consecutive failures</li> <li>State preserved between attempts</li> </ol>"},{"location":"advanced/architecture/#recovery-mechanisms","title":"Recovery Mechanisms","text":"<ul> <li>Git reset to last checkpoint</li> <li>Manual intervention points</li> <li>State file analysis tools</li> </ul>"},{"location":"advanced/architecture/#performance-considerations","title":"Performance Considerations","text":""},{"location":"advanced/architecture/#resource-usage","title":"Resource Usage","text":"<ul> <li>Minimal memory footprint (~50MB)</li> <li>CPU bound by AI agent execution</li> <li>Disk I/O for state persistence</li> </ul>"},{"location":"advanced/architecture/#scalability","title":"Scalability","text":"<ul> <li>Single task execution (by design)</li> <li>Parallel execution via multiple instances</li> <li>No shared state between instances</li> </ul>"},{"location":"advanced/architecture/#security","title":"Security","text":""},{"location":"advanced/architecture/#process-isolation","title":"Process Isolation","text":"<ul> <li>AI agents run in subprocess</li> <li>No direct code execution</li> <li>Sandboxed file system access</li> </ul>"},{"location":"advanced/architecture/#git-safety","title":"Git Safety","text":"<ul> <li>No force pushes</li> <li>Checkpoint-only commits</li> <li>Preserves user commits</li> </ul>"},{"location":"advanced/architecture/#monitoring","title":"Monitoring","text":""},{"location":"advanced/architecture/#metrics-collection","title":"Metrics Collection","text":"<pre><code>{\n  \"iteration_count\": 15,\n  \"runtime\": 234.5,\n  \"agent\": \"claude\",\n  \"errors\": [],\n  \"checkpoints\": [5, 10, 15]\n}\n</code></pre>"},{"location":"advanced/architecture/#health-checks","title":"Health Checks","text":"<ul> <li>Agent availability detection</li> <li>Prompt file validation</li> <li>Git repository status</li> </ul>"},{"location":"advanced/architecture/#future-architecture-considerations","title":"Future Architecture Considerations","text":""},{"location":"advanced/architecture/#potential-enhancements","title":"Potential Enhancements","text":"<ol> <li>Plugin System: Dynamic agent loading</li> <li>Web Interface: Browser-based monitoring</li> <li>Distributed Execution: Task parallelization</li> <li>Cloud Integration: Remote execution support</li> </ol>"},{"location":"advanced/architecture/#maintaining-simplicity","title":"Maintaining Simplicity","text":"<p>Any architectural changes should: - Preserve the core loop simplicity - Maintain the \"unpossible\" philosophy - Keep dependencies minimal - Ensure deterministic behavior</p>"},{"location":"advanced/context-management/","title":"Context Management","text":""},{"location":"advanced/context-management/#overview","title":"Overview","text":"<p>Managing context windows effectively is crucial for Ralph Orchestrator's success. AI agents have limited context windows, and exceeding them can cause failures or degraded performance.</p>"},{"location":"advanced/context-management/#context-window-limits","title":"Context Window Limits","text":""},{"location":"advanced/context-management/#current-agent-limits","title":"Current Agent Limits","text":"Agent Context Window Token Limit Approximate Characters Claude 200K tokens 200,000 ~800,000 chars Gemini 32K tokens 32,768 ~130,000 chars Q Chat 8K tokens 8,192 ~32,000 chars"},{"location":"advanced/context-management/#context-components","title":"Context Components","text":""},{"location":"advanced/context-management/#what-consumes-context","title":"What Consumes Context","text":"<ol> <li>PROMPT.md file - The task description</li> <li>Previous outputs - Agent responses</li> <li>File contents - Code being modified</li> <li>System messages - Instructions to agent</li> <li>Error messages - Debugging information</li> </ol>"},{"location":"advanced/context-management/#context-calculation","title":"Context Calculation","text":"<pre><code>def estimate_context_usage(prompt_file, workspace_files):\n    \"\"\"Estimate total context usage\"\"\"\n    total_chars = 0\n\n    # Prompt file\n    with open(prompt_file) as f:\n        total_chars += len(f.read())\n\n    # Workspace files\n    for file in workspace_files:\n        if os.path.exists(file):\n            with open(file) as f:\n                total_chars += len(f.read())\n\n    # Estimate tokens (rough: 4 chars = 1 token)\n    estimated_tokens = total_chars / 4\n\n    return {\n        'characters': total_chars,\n        'estimated_tokens': estimated_tokens,\n        'percentage_used': {\n            'claude': (estimated_tokens / 200000) * 100,\n            'gemini': (estimated_tokens / 32768) * 100,\n            'q': (estimated_tokens / 8192) * 100\n        }\n    }\n</code></pre>"},{"location":"advanced/context-management/#context-optimization-strategies","title":"Context Optimization Strategies","text":""},{"location":"advanced/context-management/#1-prompt-optimization","title":"1. Prompt Optimization","text":""},{"location":"advanced/context-management/#keep-prompts-concise","title":"Keep Prompts Concise","text":"<pre><code># Bad - Too verbose\nCreate a comprehensive Python application that implements a calculator\nwith extensive error handling, logging capabilities, user-friendly\ninterface, and support for basic arithmetic operations including\naddition, subtraction, multiplication, and division...\n\n# Good - Concise and clear\nCreate a Python calculator with:\n- Basic operations: +, -, *, /\n- Error handling for division by zero\n- Simple CLI interface\n</code></pre>"},{"location":"advanced/context-management/#use-structured-format","title":"Use Structured Format","text":"<pre><code># Task: Calculator Module\n\n## Requirements:\n- [ ] Basic operations (add, subtract, multiply, divide)\n- [ ] Input validation\n- [ ] Unit tests\n\n## Constraints:\n- Python 3.11+\n- No external dependencies\n- 100% test coverage\n</code></pre>"},{"location":"advanced/context-management/#2-file-management","title":"2. File Management","text":""},{"location":"advanced/context-management/#split-large-files","title":"Split Large Files","text":"<pre><code># Instead of one large file\n# calculator.py (5000 lines)\n\n# Use modular structure\n# calculator/\n#   \u251c\u2500\u2500 __init__.py\n#   \u251c\u2500\u2500 operations.py (500 lines)\n#   \u251c\u2500\u2500 validators.py (300 lines)\n#   \u251c\u2500\u2500 interface.py (400 lines)\n#   \u2514\u2500\u2500 utils.py (200 lines)\n</code></pre>"},{"location":"advanced/context-management/#exclude-unnecessary-files","title":"Exclude Unnecessary Files","text":"<pre><code># .agent/config.json\n{\n  \"exclude_patterns\": [\n    \"*.pyc\",\n    \"__pycache__\",\n    \"*.log\",\n    \"test_*.py\",  # Exclude during implementation\n    \"docs/\",      # Exclude documentation\n    \".git/\"       # Never include git directory\n  ]\n}\n</code></pre>"},{"location":"advanced/context-management/#3-incremental-processing","title":"3. Incremental Processing","text":""},{"location":"advanced/context-management/#task-decomposition","title":"Task Decomposition","text":"<pre><code># Instead of one large task\n\"Build a complete web application\"\n\n# Break into phases\nPhase 1: Create project structure\nPhase 2: Implement data models\nPhase 3: Add API endpoints\nPhase 4: Build frontend\nPhase 5: Add tests\n</code></pre>"},{"location":"advanced/context-management/#checkpoint-strategy","title":"Checkpoint Strategy","text":"<pre><code>def create_context_aware_checkpoint(iteration, context_usage):\n    \"\"\"Create checkpoint when context is getting full\"\"\"\n    if context_usage['percentage_used']['current_agent'] &gt; 70:\n        # Reset context by creating checkpoint\n        create_checkpoint(iteration)\n        # Clear working memory\n        clear_agent_memory()\n        # Summarize progress\n        create_progress_summary()\n</code></pre>"},{"location":"advanced/context-management/#4-context-window-sliding","title":"4. Context Window Sliding","text":""},{"location":"advanced/context-management/#maintain-rolling-context","title":"Maintain Rolling Context","text":"<pre><code>class ContextManager:\n    def __init__(self, max_history=5):\n        self.history = []\n        self.max_history = max_history\n\n    def add_iteration(self, prompt, response):\n        \"\"\"Add iteration to history with sliding window\"\"\"\n        self.history.append({\n            'prompt': prompt,\n            'response': response,\n            'timestamp': time.time()\n        })\n\n        # Keep only recent history\n        if len(self.history) &gt; self.max_history:\n            self.history.pop(0)\n\n    def get_context(self):\n        \"\"\"Get current context for agent\"\"\"\n        # Include only recent iterations\n        return '\\n'.join([\n            f\"Iteration {i+1}:\\n{h['response'][:500]}...\"\n            for i, h in enumerate(self.history[-3:])\n        ])\n</code></pre>"},{"location":"advanced/context-management/#advanced-techniques","title":"Advanced Techniques","text":""},{"location":"advanced/context-management/#1-context-compression","title":"1. Context Compression","text":"<pre><code>def compress_context(text, max_length=1000):\n    \"\"\"Compress text while preserving key information\"\"\"\n    if len(text) &lt;= max_length:\n        return text\n\n    # Extract key sections\n    lines = text.split('\\n')\n    important_lines = []\n\n    for line in lines:\n        # Keep headers, errors, and key code\n        if any(marker in line for marker in \n               ['#', 'def ', 'class ', 'ERROR', 'TODO']):\n            important_lines.append(line)\n\n    compressed = '\\n'.join(important_lines)\n\n    # If still too long, truncate with summary\n    if len(compressed) &gt; max_length:\n        return compressed[:max_length-20] + \"\\n... (truncated)\"\n\n    return compressed\n</code></pre>"},{"location":"advanced/context-management/#2-semantic-chunking","title":"2. Semantic Chunking","text":"<pre><code>def chunk_by_semantics(code_file):\n    \"\"\"Split code into semantic chunks\"\"\"\n    chunks = []\n    current_chunk = []\n\n    with open(code_file) as f:\n        lines = f.readlines()\n\n    for line in lines:\n        current_chunk.append(line)\n\n        # End chunk at logical boundaries\n        if line.strip().startswith('def ') or \\\n           line.strip().startswith('class '):\n            if len(current_chunk) &gt; 1:\n                chunks.append(''.join(current_chunk[:-1]))\n                current_chunk = [line]\n\n    # Add remaining\n    if current_chunk:\n        chunks.append(''.join(current_chunk))\n\n    return chunks\n</code></pre>"},{"location":"advanced/context-management/#3-progressive-disclosure","title":"3. Progressive Disclosure","text":"<pre><code>class ProgressiveContext:\n    \"\"\"Gradually reveal context as needed\"\"\"\n\n    def __init__(self):\n        self.levels = {\n            'summary': 100,      # Brief summary\n            'outline': 500,      # Structure only\n            'essential': 2000,   # Key components\n            'detailed': 10000,   # Full details\n        }\n\n    def get_context_at_level(self, content, level='essential'):\n        \"\"\"Get context at specified detail level\"\"\"\n        max_chars = self.levels[level]\n\n        if level == 'summary':\n            return self.create_summary(content, max_chars)\n        elif level == 'outline':\n            return self.extract_outline(content, max_chars)\n        elif level == 'essential':\n            return self.extract_essential(content, max_chars)\n        else:\n            return content[:max_chars]\n</code></pre>"},{"location":"advanced/context-management/#context-monitoring","title":"Context Monitoring","text":""},{"location":"advanced/context-management/#track-usage","title":"Track Usage","text":"<pre><code>def monitor_context_usage():\n    \"\"\"Monitor and log context usage\"\"\"\n    usage = estimate_context_usage('PROMPT.md', glob.glob('*.py'))\n\n    # Log warning if approaching limits\n    for agent, percentage in usage['percentage_used'].items():\n        if percentage &gt; 80:\n            logging.warning(\n                f\"Context usage for {agent}: {percentage:.1f}% - \"\n                f\"Consider optimization\"\n            )\n\n    # Save metrics\n    with open('.agent/metrics/context_usage.json', 'w') as f:\n        json.dump(usage, f, indent=2)\n\n    return usage\n</code></pre>"},{"location":"advanced/context-management/#visualization","title":"Visualization","text":"<pre><code>import matplotlib.pyplot as plt\n\ndef visualize_context_usage(iterations_data):\n    \"\"\"Plot context usage over iterations\"\"\"\n    iterations = [d['iteration'] for d in iterations_data]\n    usage = [d['context_percentage'] for d in iterations_data]\n\n    plt.figure(figsize=(10, 6))\n    plt.plot(iterations, usage, marker='o')\n    plt.axhline(y=80, color='orange', linestyle='--', label='Warning')\n    plt.axhline(y=100, color='red', linestyle='--', label='Limit')\n    plt.xlabel('Iteration')\n    plt.ylabel('Context Usage (%)')\n    plt.title('Context Window Usage Over Time')\n    plt.legend()\n    plt.savefig('.agent/context_usage.png')\n</code></pre>"},{"location":"advanced/context-management/#best-practices","title":"Best Practices","text":""},{"location":"advanced/context-management/#1-start-small","title":"1. Start Small","text":"<ul> <li>Begin with minimal context</li> <li>Add detail only when needed</li> <li>Remove completed sections</li> </ul>"},{"location":"advanced/context-management/#2-use-references","title":"2. Use References","text":"<pre><code># Instead of including full code\nSee `calculator.py` for implementation details\n\n# Reference specific sections\nRefer to lines 45-67 in `utils.py` for error handling\n</code></pre>"},{"location":"advanced/context-management/#3-summarize-periodically","title":"3. Summarize Periodically","text":"<pre><code>def create_iteration_summary(iteration_num):\n    \"\"\"Create summary every N iterations\"\"\"\n    if iteration_num % 10 == 0:\n        summary = {\n            'completed': [],\n            'in_progress': [],\n            'pending': [],\n            'issues': []\n        }\n        # ... populate summary\n\n        with open(f'.agent/summaries/summary_{iteration_num}.md', 'w') as f:\n            f.write(format_summary(summary))\n</code></pre>"},{"location":"advanced/context-management/#4-clean-working-directory","title":"4. Clean Working Directory","text":"<pre><code># Remove unnecessary files\nrm -f *.pyc\nrm -rf __pycache__\nrm -f *.log\n\n# Archive old iterations\ntar -czf .agent/archive/iteration_1-50.tar.gz .agent/prompts/prompt_*.md\nrm .agent/prompts/prompt_*.md\n</code></pre>"},{"location":"advanced/context-management/#troubleshooting","title":"Troubleshooting","text":""},{"location":"advanced/context-management/#context-overflow-symptoms","title":"Context Overflow Symptoms","text":"Symptom Likely Cause Solution Agent forgets earlier instructions Context window full Create checkpoint and reset Incomplete responses Hitting token limits Reduce prompt size Repeated work Lost context Use summaries Errors about missing information Context truncated Split into smaller tasks"},{"location":"advanced/context-management/#recovery-strategies","title":"Recovery Strategies","text":"<pre><code>def recover_from_context_overflow():\n    \"\"\"Recover when context limits exceeded\"\"\"\n\n    # 1. Save current state\n    save_state()\n\n    # 2. Create summary of work done\n    summary = create_work_summary()\n\n    # 3. Reset with minimal context\n    new_prompt = f\"\"\"\n    Continue from checkpoint. Previous work summary:\n    {summary}\n\n    Current task: {get_current_task()}\n    \"\"\"\n\n    # 4. Resume with fresh context\n    return new_prompt\n</code></pre>"},{"location":"advanced/context-management/#agent-specific-tips","title":"Agent-Specific Tips","text":""},{"location":"advanced/context-management/#claude-200k-context","title":"Claude (200K context)","text":"<ul> <li>Can handle large codebases</li> <li>Include more context for better results</li> <li>Use for complex, multi-file tasks</li> </ul>"},{"location":"advanced/context-management/#gemini-32k-context","title":"Gemini (32K context)","text":"<ul> <li>Balance between context and detail</li> <li>Good for medium-sized projects</li> <li>Optimize file inclusion</li> </ul>"},{"location":"advanced/context-management/#q-chat-8k-context","title":"Q Chat (8K context)","text":"<ul> <li>Minimize context aggressively</li> <li>Focus on single files/functions</li> <li>Use for targeted tasks</li> </ul>"},{"location":"advanced/context-management/#configuration","title":"Configuration","text":"<pre><code>{\n  \"context_management\": {\n    \"max_prompt_size\": 5000,\n    \"max_file_size\": 10000,\n    \"max_files_included\": 10,\n    \"compression_enabled\": true,\n    \"sliding_window_size\": 5,\n    \"checkpoint_on_high_usage\": true,\n    \"usage_warning_threshold\": 80,\n    \"usage_critical_threshold\": 95\n  }\n}\n</code></pre>"},{"location":"advanced/monitoring/","title":"Monitoring and Observability","text":""},{"location":"advanced/monitoring/#overview","title":"Overview","text":"<p>Ralph Orchestrator provides comprehensive monitoring capabilities to track execution, performance, and system health. This guide covers monitoring tools, metrics, and best practices.</p>"},{"location":"advanced/monitoring/#built-in-monitoring","title":"Built-in Monitoring","text":""},{"location":"advanced/monitoring/#state-files","title":"State Files","text":"<p>Ralph automatically generates state files in <code>.agent/metrics/</code>:</p> <pre><code>{\n  \"iteration_count\": 15,\n  \"runtime\": 234.5,\n  \"start_time\": \"2025-09-07T15:44:35\",\n  \"agent\": \"claude\",\n  \"prompt_file\": \"PROMPT.md\",\n  \"status\": \"running\",\n  \"errors\": [],\n  \"checkpoints\": [5, 10, 15],\n  \"last_output_size\": 2048\n}\n</code></pre>"},{"location":"advanced/monitoring/#real-time-status","title":"Real-time Status","text":"<pre><code># Check current status\n./ralph status\n\n# Output:\nRalph Orchestrator Status\n=========================\nStatus: RUNNING\nCurrent Iteration: 15\nRuntime: 3m 54s\nAgent: claude\nLast Checkpoint: iteration 15\nErrors: 0\n</code></pre>"},{"location":"advanced/monitoring/#execution-logs","title":"Execution Logs","text":""},{"location":"advanced/monitoring/#verbose-mode","title":"Verbose Mode","text":"<pre><code># Enable detailed logging\n./ralph run --verbose\n\n# Output includes:\n# - Agent commands\n# - Execution times\n# - Output summaries\n# - Error details\n</code></pre>"},{"location":"advanced/monitoring/#log-levels","title":"Log Levels","text":"<pre><code>import logging\n\n# Configure log level\nlogging.basicConfig(\n    level=logging.DEBUG,  # DEBUG, INFO, WARNING, ERROR\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',\n    handlers=[\n        logging.FileHandler('.agent/logs/ralph.log'),\n        logging.StreamHandler()\n    ]\n)\n</code></pre>"},{"location":"advanced/monitoring/#metrics-collection","title":"Metrics Collection","text":""},{"location":"advanced/monitoring/#performance-metrics","title":"Performance Metrics","text":"<pre><code># Automatically collected metrics\nmetrics = {\n    'iteration_times': [],      # Time per iteration\n    'agent_response_times': [], # Agent execution duration\n    'output_sizes': [],         # Response size per iteration\n    'error_rate': 0.0,         # Errors per iteration\n    'checkpoint_times': [],     # Checkpoint creation duration\n    'total_api_calls': 0       # Total agent invocations\n}\n</code></pre>"},{"location":"advanced/monitoring/#custom-metrics","title":"Custom Metrics","text":"<pre><code># Add custom metrics collection\nclass MetricsCollector:\n    def record_metric(self, name: str, value: float):\n        \"\"\"Record custom metric\"\"\"\n        timestamp = time.time()\n        self.metrics.append({\n            'name': name,\n            'value': value,\n            'timestamp': timestamp\n        })\n\n    def export_metrics(self):\n        \"\"\"Export metrics to JSON\"\"\"\n        with open('.agent/metrics/custom.json', 'w') as f:\n            json.dump(self.metrics, f, indent=2)\n</code></pre>"},{"location":"advanced/monitoring/#monitoring-tools","title":"Monitoring Tools","text":""},{"location":"advanced/monitoring/#1-ralph-monitor-built-in","title":"1. Ralph Monitor (Built-in)","text":"<pre><code># Continuous monitoring\nwatch -n 5 './ralph status'\n\n# Tail logs\ntail -f .agent/logs/ralph.log\n\n# Monitor metrics\nwatch -n 10 'cat .agent/metrics/state_*.json | jq .'\n</code></pre>"},{"location":"advanced/monitoring/#2-git-history-monitoring","title":"2. Git History Monitoring","text":"<pre><code># View checkpoint history\ngit log --oneline | grep \"Ralph checkpoint\"\n\n# Analyze code changes over time\ngit diff --stat HEAD~10..HEAD\n\n# Track file modifications\ngit log --follow -p PROMPT.md\n</code></pre>"},{"location":"advanced/monitoring/#3-system-resource-monitoring","title":"3. System Resource Monitoring","text":"<pre><code># Monitor Ralph process\nhtop -p $(pgrep -f ralph_orchestrator)\n\n# Track resource usage\npidstat -p $(pgrep -f ralph_orchestrator) 1\n\n# Monitor file system changes\ninotifywait -m -r . -e modify,create,delete\n</code></pre>"},{"location":"advanced/monitoring/#dashboard-setup","title":"Dashboard Setup","text":""},{"location":"advanced/monitoring/#terminal-dashboard","title":"Terminal Dashboard","text":"<p>Create <code>monitor.sh</code>: <pre><code>#!/bin/bash\n# Ralph Monitoring Dashboard\n\nwhile true; do\n    clear\n    echo \"=== RALPH ORCHESTRATOR MONITOR ===\"\n    echo \"\"\n\n    # Status\n    ./ralph status\n    echo \"\"\n\n    # Recent errors\n    echo \"Recent Errors:\"\n    tail -n 5 .agent/logs/ralph.log | grep ERROR || echo \"No errors\"\n    echo \"\"\n\n    # Resource usage\n    echo \"Resource Usage:\"\n    ps aux | grep ralph_orchestrator | grep -v grep\n    echo \"\"\n\n    # Latest checkpoint\n    echo \"Latest Checkpoint:\"\n    ls -lt .agent/checkpoints/ | head -2\n\n    sleep 5\ndone\n</code></pre></p>"},{"location":"advanced/monitoring/#web-dashboard-optional","title":"Web Dashboard (Optional)","text":"<pre><code># Simple Flask dashboard\nfrom flask import Flask, jsonify, render_template_string\nimport json\nimport glob\n\napp = Flask(__name__)\n\n@app.route('/metrics')\ndef metrics():\n    # Get latest state file\n    state_files = glob.glob('.agent/metrics/state_*.json')\n    if state_files:\n        latest = max(state_files)\n        with open(latest) as f:\n            return jsonify(json.load(f))\n    return jsonify({'status': 'no data'})\n\n@app.route('/')\ndef dashboard():\n    return render_template_string('''\n    &lt;html&gt;\n        &lt;head&gt;\n            &lt;title&gt;Ralph Dashboard&lt;/title&gt;\n            &lt;script&gt;\n                function updateMetrics() {\n                    fetch('/metrics')\n                        .then(response =&gt; response.json())\n                        .then(data =&gt; {\n                            document.getElementById('metrics').innerHTML = \n                                JSON.stringify(data, null, 2);\n                        });\n                }\n                setInterval(updateMetrics, 5000);\n            &lt;/script&gt;\n        &lt;/head&gt;\n        &lt;body onload=\"updateMetrics()\"&gt;\n            &lt;h1&gt;Ralph Orchestrator Dashboard&lt;/h1&gt;\n            &lt;pre id=\"metrics\"&gt;&lt;/pre&gt;\n        &lt;/body&gt;\n    &lt;/html&gt;\n    ''')\n\nif __name__ == '__main__':\n    app.run(debug=True, port=5000)\n</code></pre>"},{"location":"advanced/monitoring/#alerting","title":"Alerting","text":""},{"location":"advanced/monitoring/#error-detection","title":"Error Detection","text":"<pre><code># Monitor for errors\ndef check_errors():\n    with open('.agent/metrics/state_latest.json') as f:\n        state = json.load(f)\n\n    if state.get('errors'):\n        send_alert(f\"Ralph encountered errors: {state['errors']}\")\n\n    if state.get('iteration_count', 0) &gt; 100:\n        send_alert(\"Ralph exceeded 100 iterations\")\n\n    if state.get('runtime', 0) &gt; 14400:  # 4 hours\n        send_alert(\"Ralph runtime exceeded 4 hours\")\n</code></pre>"},{"location":"advanced/monitoring/#notification-methods","title":"Notification Methods","text":"<pre><code># Desktop notification\nnotify-send \"Ralph Alert\" \"Task completed successfully\"\n\n# Email alert\necho \"Ralph task failed\" | mail -s \"Ralph Alert\" admin@example.com\n\n# Slack webhook\ncurl -X POST -H 'Content-type: application/json' \\\n    --data '{\"text\":\"Ralph task completed\"}' \\\n    YOUR_SLACK_WEBHOOK_URL\n</code></pre>"},{"location":"advanced/monitoring/#performance-analysis","title":"Performance Analysis","text":""},{"location":"advanced/monitoring/#iteration-analysis","title":"Iteration Analysis","text":"<pre><code># Analyze iteration performance\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\ndef analyze_iterations():\n    # Load metrics\n    metrics = []\n    for file in glob.glob('.agent/metrics/state_*.json'):\n        with open(file) as f:\n            metrics.append(json.load(f))\n\n    # Create DataFrame\n    df = pd.DataFrame(metrics)\n\n    # Plot iteration times\n    plt.figure(figsize=(10, 6))\n    plt.plot(df['iteration_count'], df['runtime'])\n    plt.xlabel('Iteration')\n    plt.ylabel('Cumulative Runtime (seconds)')\n    plt.title('Ralph Execution Performance')\n    plt.savefig('.agent/performance.png')\n\n    # Statistics\n    print(f\"Average iteration time: {df['runtime'].diff().mean():.2f}s\")\n    print(f\"Total iterations: {df['iteration_count'].max()}\")\n    print(f\"Error rate: {len(df[df['errors'].notna()]) / len(df):.2%}\")\n</code></pre>"},{"location":"advanced/monitoring/#cost-tracking","title":"Cost Tracking","text":"<pre><code># Estimate API costs\ndef calculate_costs():\n    costs = {\n        'claude': 0.01,    # $ per call\n        'gemini': 0.005,   # $ per call\n        'q': 0.0           # Free\n    }\n\n    total_cost = 0\n    for file in glob.glob('.agent/metrics/state_*.json'):\n        with open(file) as f:\n            state = json.load(f)\n            agent = state.get('agent', 'claude')\n            total_cost += costs.get(agent, 0)\n\n    print(f\"Estimated cost: ${total_cost:.2f}\")\n    return total_cost\n</code></pre>"},{"location":"advanced/monitoring/#log-management","title":"Log Management","text":""},{"location":"advanced/monitoring/#log-rotation","title":"Log Rotation","text":"<pre><code># Configure log rotation\nimport logging.handlers\n\nhandler = logging.handlers.RotatingFileHandler(\n    '.agent/logs/ralph.log',\n    maxBytes=10*1024*1024,  # 10MB\n    backupCount=5\n)\n</code></pre>"},{"location":"advanced/monitoring/#log-aggregation","title":"Log Aggregation","text":"<pre><code># Combine all logs\ncat .agent/logs/*.log &gt; combined.log\n\n# Filter by date\ngrep \"2025-09-07\" .agent/logs/*.log\n\n# Extract errors only\ngrep -E \"ERROR|CRITICAL\" .agent/logs/*.log &gt; errors.log\n</code></pre>"},{"location":"advanced/monitoring/#log-analysis","title":"Log Analysis","text":"<pre><code># Count errors by type\ngrep ERROR .agent/logs/*.log | cut -d: -f4 | sort | uniq -c\n\n# Find longest running iterations\ngrep \"Iteration .* completed\" .agent/logs/*.log | \\\n    awk '{print $NF}' | sort -rn | head -10\n\n# Agent usage statistics\ngrep \"Using agent:\" .agent/logs/*.log | \\\n    cut -d: -f4 | sort | uniq -c\n</code></pre>"},{"location":"advanced/monitoring/#health-checks","title":"Health Checks","text":""},{"location":"advanced/monitoring/#automated-health-checks","title":"Automated Health Checks","text":"<pre><code>def health_check():\n    \"\"\"Comprehensive health check\"\"\"\n    health = {\n        'status': 'healthy',\n        'checks': []\n    }\n\n    # Check prompt file exists\n    if not os.path.exists('PROMPT.md'):\n        health['status'] = 'unhealthy'\n        health['checks'].append('PROMPT.md missing')\n\n    # Check agent availability\n    for agent in ['claude', 'q', 'gemini']:\n        if shutil.which(agent):\n            health['checks'].append(f'{agent}: available')\n        else:\n            health['checks'].append(f'{agent}: not found')\n\n    # Check disk space\n    stat = os.statvfs('.')\n    free_space = stat.f_bavail * stat.f_frsize / (1024**3)  # GB\n    if free_space &lt; 1:\n        health['status'] = 'warning'\n        health['checks'].append(f'Low disk space: {free_space:.2f}GB')\n\n    # Check Git status\n    result = subprocess.run(['git', 'status', '--porcelain'], \n                          capture_output=True, text=True)\n    if result.stdout:\n        health['checks'].append('Uncommitted changes present')\n\n    return health\n</code></pre>"},{"location":"advanced/monitoring/#troubleshooting-with-monitoring","title":"Troubleshooting with Monitoring","text":""},{"location":"advanced/monitoring/#common-issues","title":"Common Issues","text":"Symptom Check Solution High iteration count <code>.agent/metrics/state_*.json</code> Review prompt clarity Slow performance Iteration times in logs Check agent response times Memory issues System monitor Increase limits or add swap Repeated errors Error patterns in logs Fix underlying issue No progress Git diff output Check if agent is making changes"},{"location":"advanced/monitoring/#debug-mode","title":"Debug Mode","text":"<pre><code># Maximum verbosity\nRALPH_DEBUG=1 ./ralph run --verbose\n\n# Trace execution\npython -m trace -t ralph_orchestrator.py\n\n# Profile performance\npython -m cProfile -o profile.stats ralph_orchestrator.py\n</code></pre>"},{"location":"advanced/monitoring/#best-practices","title":"Best Practices","text":"<ol> <li>Regular Monitoring</li> <li>Check status every 10-15 minutes</li> <li>Review logs for anomalies</li> <li> <p>Monitor resource usage</p> </li> <li> <p>Metric Retention</p> </li> <li>Archive old metrics weekly</li> <li>Compress logs monthly</li> <li> <p>Maintain 30-day history</p> </li> <li> <p>Alert Fatigue</p> </li> <li>Set reasonable thresholds</li> <li>Group related alerts</li> <li> <p>Prioritize critical issues</p> </li> <li> <p>Documentation</p> </li> <li>Document custom metrics</li> <li>Track performance baselines</li> <li>Note configuration changes</li> </ol>"},{"location":"advanced/production-deployment/","title":"Production Deployment Guide","text":""},{"location":"advanced/production-deployment/#overview","title":"Overview","text":"<p>This guide covers deploying Ralph Orchestrator in production environments, including server setup, automation, monitoring, and scaling considerations.</p>"},{"location":"advanced/production-deployment/#deployment-options","title":"Deployment Options","text":""},{"location":"advanced/production-deployment/#1-local-server-deployment","title":"1. Local Server Deployment","text":""},{"location":"advanced/production-deployment/#system-requirements","title":"System Requirements","text":"<ul> <li>OS: Linux (Ubuntu 20.04+, RHEL 8+, Debian 11+)</li> <li>Python: 3.9+</li> <li>Git: 2.25+</li> <li>Memory: 4GB minimum, 8GB recommended</li> <li>Storage: 20GB available space</li> <li>Network: Stable internet for AI agent APIs</li> </ul>"},{"location":"advanced/production-deployment/#installation-script","title":"Installation Script","text":"<pre><code>#!/bin/bash\n# ralph-install.sh\n\n# Update system\nsudo apt-get update &amp;&amp; sudo apt-get upgrade -y\n\n# Install dependencies\nsudo apt-get install -y python3 python3-pip git nodejs npm\n\n# Install AI agents\nnpm install -g @anthropic-ai/claude-code\nnpm install -g @google/gemini-cli\n# Install Q following its documentation\n\n# Clone Ralph\ngit clone https://github.com/yourusername/ralph-orchestrator.git\ncd ralph-orchestrator\n\n# Set permissions\nchmod +x ralph_orchestrator.py ralph\n\n# Create systemd service\nsudo cp ralph.service /etc/systemd/system/\nsudo systemctl daemon-reload\nsudo systemctl enable ralph\n</code></pre>"},{"location":"advanced/production-deployment/#2-docker-deployment","title":"2. Docker Deployment","text":""},{"location":"advanced/production-deployment/#dockerfile","title":"Dockerfile","text":"<pre><code>FROM python:3.11-slim\n\n# Install system dependencies\nRUN apt-get update &amp;&amp; apt-get install -y \\\n    git \\\n    nodejs \\\n    npm \\\n    &amp;&amp; rm -rf /var/lib/apt/lists/*\n\n# Install AI CLI tools\nRUN npm install -g @anthropic-ai/claude-code @google/gemini-cli\n\n# Create ralph user\nRUN useradd -m -s /bin/bash ralph\nWORKDIR /home/ralph\n\n# Copy application\nCOPY --chown=ralph:ralph . /home/ralph/ralph-orchestrator/\nWORKDIR /home/ralph/ralph-orchestrator\n\n# Set permissions\nRUN chmod +x ralph_orchestrator.py ralph\n\n# Switch to ralph user\nUSER ralph\n\n# Default command\nCMD [\"./ralph\", \"run\"]\n</code></pre>"},{"location":"advanced/production-deployment/#docker-compose","title":"Docker Compose","text":"<pre><code># docker-compose.yml\nversion: '3.8'\n\nservices:\n  ralph:\n    build: .\n    container_name: ralph-orchestrator\n    restart: unless-stopped\n    volumes:\n      - ./workspace:/home/ralph/workspace\n      - ./prompts:/home/ralph/prompts\n      - ralph-agent:/home/ralph/ralph-orchestrator/.agent\n    environment:\n      - RALPH_MAX_ITERATIONS=100\n      - RALPH_AGENT=auto\n      - RALPH_CHECKPOINT_INTERVAL=5\n    logging:\n      driver: \"json-file\"\n      options:\n        max-size: \"10m\"\n        max-file: \"3\"\n\nvolumes:\n  ralph-agent:\n</code></pre>"},{"location":"advanced/production-deployment/#3-cloud-deployment","title":"3. Cloud Deployment","text":""},{"location":"advanced/production-deployment/#aws-ec2","title":"AWS EC2","text":"<pre><code># User data script for EC2 instance\n#!/bin/bash\nyum update -y\nyum install -y python3 git nodejs\n\n# Install Ralph\ncd /opt\ngit clone https://github.com/yourusername/ralph-orchestrator.git\ncd ralph-orchestrator\nchmod +x ralph_orchestrator.py ralph\n\n# Configure as service\ncat &gt; /etc/systemd/system/ralph.service &lt;&lt; EOF\n[Unit]\nDescription=Ralph Orchestrator\nAfter=network.target\n\n[Service]\nType=simple\nUser=ec2-user\nWorkingDirectory=/opt/ralph-orchestrator\nExecStart=/opt/ralph-orchestrator/ralph run\nRestart=on-failure\nRestartSec=10\n\n[Install]\nWantedBy=multi-user.target\nEOF\n\nsystemctl enable ralph\nsystemctl start ralph\n</code></pre>"},{"location":"advanced/production-deployment/#kubernetes-deployment","title":"Kubernetes Deployment","text":"<pre><code># ralph-deployment.yaml\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: ralph-orchestrator\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      app: ralph\n  template:\n    metadata:\n      labels:\n        app: ralph\n    spec:\n      containers:\n      - name: ralph\n        image: ralph-orchestrator:latest\n        resources:\n          requests:\n            memory: \"2Gi\"\n            cpu: \"1\"\n          limits:\n            memory: \"4Gi\"\n            cpu: \"2\"\n        volumeMounts:\n        - name: workspace\n          mountPath: /workspace\n        - name: config\n          mountPath: /config\n      volumes:\n      - name: workspace\n        persistentVolumeClaim:\n          claimName: ralph-workspace\n      - name: config\n        configMap:\n          name: ralph-config\n</code></pre>"},{"location":"advanced/production-deployment/#configuration-management","title":"Configuration Management","text":""},{"location":"advanced/production-deployment/#environment-variables","title":"Environment Variables","text":"<pre><code># /etc/environment or .env file\nRALPH_HOME=/opt/ralph-orchestrator\nRALPH_WORKSPACE=/var/ralph/workspace\nRALPH_LOG_LEVEL=INFO\nRALPH_MAX_ITERATIONS=100\nRALPH_MAX_RUNTIME=14400\nRALPH_AGENT=claude\nRALPH_CHECKPOINT_INTERVAL=5\nRALPH_RETRY_DELAY=2\nRALPH_GIT_ENABLED=true\nRALPH_ARCHIVE_ENABLED=true\n</code></pre>"},{"location":"advanced/production-deployment/#configuration-file","title":"Configuration File","text":"<pre><code>{\n  \"production\": {\n    \"agent\": \"claude\",\n    \"max_iterations\": 100,\n    \"max_runtime\": 14400,\n    \"checkpoint_interval\": 5,\n    \"retry_delay\": 2,\n    \"retry_max\": 5,\n    \"timeout_per_iteration\": 300,\n    \"git_enabled\": true,\n    \"archive_enabled\": true,\n    \"monitoring\": {\n      \"enabled\": true,\n      \"metrics_endpoint\": \"http://metrics.example.com\",\n      \"log_level\": \"INFO\"\n    },\n    \"security\": {\n      \"sandbox_enabled\": true,\n      \"allowed_directories\": [\"/workspace\"],\n      \"forbidden_commands\": [\"rm -rf\", \"sudo\", \"su\"],\n      \"max_file_size\": 10485760\n    }\n  }\n}\n</code></pre>"},{"location":"advanced/production-deployment/#automation","title":"Automation","text":""},{"location":"advanced/production-deployment/#systemd-service","title":"Systemd Service","text":"<pre><code># /etc/systemd/system/ralph.service\n[Unit]\nDescription=Ralph Orchestrator Service\nDocumentation=https://github.com/yourusername/ralph-orchestrator\nAfter=network.target\n\n[Service]\nType=simple\nUser=ralph\nGroup=ralph\nWorkingDirectory=/opt/ralph-orchestrator\nExecStart=/opt/ralph-orchestrator/ralph run --config production.json\nExecReload=/bin/kill -HUP $MAINPID\nRestart=on-failure\nRestartSec=30\nStandardOutput=journal\nStandardError=journal\nSyslogIdentifier=ralph\nEnvironment=\"PYTHONUNBUFFERED=1\"\n\n# Security\nNoNewPrivileges=true\nPrivateTmp=true\nProtectSystem=strict\nProtectHome=true\nReadWritePaths=/opt/ralph-orchestrator /var/ralph\n\n[Install]\nWantedBy=multi-user.target\n</code></pre>"},{"location":"advanced/production-deployment/#cron-jobs","title":"Cron Jobs","text":"<pre><code># /etc/cron.d/ralph\n# Clean old logs weekly\n0 2 * * 0 ralph /opt/ralph-orchestrator/scripts/cleanup.sh\n\n# Backup state daily\n0 3 * * * ralph tar -czf /backup/ralph-$(date +\\%Y\\%m\\%d).tar.gz /opt/ralph-orchestrator/.agent\n\n# Health check every 5 minutes\n*/5 * * * * ralph /opt/ralph-orchestrator/scripts/health-check.sh || systemctl restart ralph\n</code></pre>"},{"location":"advanced/production-deployment/#cicd-pipeline","title":"CI/CD Pipeline","text":"<pre><code># .github/workflows/deploy.yml\nname: Deploy Ralph\n\non:\n  push:\n    branches: [main]\n    paths:\n      - 'ralph_orchestrator.py'\n      - 'ralph'\n      - 'requirements.txt'\n\njobs:\n  deploy:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n\n      - name: Run tests\n        run: python test_comprehensive.py\n\n      - name: Build Docker image\n        run: docker build -t ralph-orchestrator:${{ github.sha }} .\n\n      - name: Push to registry\n        run: |\n          docker tag ralph-orchestrator:${{ github.sha }} ${{ secrets.REGISTRY }}/ralph:latest\n          docker push ${{ secrets.REGISTRY }}/ralph:latest\n\n      - name: Deploy to server\n        uses: appleboy/ssh-action@v0.1.5\n        with:\n          host: ${{ secrets.HOST }}\n          username: ${{ secrets.USERNAME }}\n          key: ${{ secrets.SSH_KEY }}\n          script: |\n            cd /opt/ralph-orchestrator\n            git pull\n            systemctl restart ralph\n</code></pre>"},{"location":"advanced/production-deployment/#monitoring-in-production","title":"Monitoring in Production","text":""},{"location":"advanced/production-deployment/#prometheus-metrics","title":"Prometheus Metrics","text":"<pre><code># metrics_exporter.py\nfrom prometheus_client import Counter, Histogram, Gauge, start_http_server\nimport json\nimport glob\n\n# Define metrics\niteration_counter = Counter('ralph_iterations_total', 'Total iterations')\nerror_counter = Counter('ralph_errors_total', 'Total errors')\nruntime_gauge = Gauge('ralph_runtime_seconds', 'Current runtime')\niteration_duration = Histogram('ralph_iteration_duration_seconds', 'Iteration duration')\n\ndef collect_metrics():\n    \"\"\"Collect metrics from Ralph state files\"\"\"\n    state_files = glob.glob('.agent/metrics/state_*.json')\n    if state_files:\n        latest = max(state_files)\n        with open(latest) as f:\n            state = json.load(f)\n\n        iteration_counter.inc(state.get('iteration_count', 0))\n        runtime_gauge.set(state.get('runtime', 0))\n\n        if state.get('errors'):\n            error_counter.inc(len(state['errors']))\n\nif __name__ == '__main__':\n    # Start metrics server\n    start_http_server(8000)\n\n    # Collect metrics periodically\n    while True:\n        collect_metrics()\n        time.sleep(30)\n</code></pre>"},{"location":"advanced/production-deployment/#logging-setup","title":"Logging Setup","text":"<pre><code># logging_config.py\nimport logging\nimport logging.handlers\nimport json\n\ndef setup_production_logging():\n    \"\"\"Configure production logging\"\"\"\n\n    # JSON formatter for structured logging\n    class JSONFormatter(logging.Formatter):\n        def format(self, record):\n            log_obj = {\n                'timestamp': self.formatTime(record),\n                'level': record.levelname,\n                'logger': record.name,\n                'message': record.getMessage(),\n                'module': record.module,\n                'function': record.funcName,\n                'line': record.lineno\n            }\n            if record.exc_info:\n                log_obj['exception'] = self.formatException(record.exc_info)\n            return json.dumps(log_obj)\n\n    # Configure root logger\n    logger = logging.getLogger()\n    logger.setLevel(logging.INFO)\n\n    # File handler with rotation\n    file_handler = logging.handlers.RotatingFileHandler(\n        '/var/log/ralph/ralph.log',\n        maxBytes=100*1024*1024,  # 100MB\n        backupCount=10\n    )\n    file_handler.setFormatter(JSONFormatter())\n\n    # Syslog handler\n    syslog_handler = logging.handlers.SysLogHandler(address='/dev/log')\n    syslog_handler.setFormatter(JSONFormatter())\n\n    logger.addHandler(file_handler)\n    logger.addHandler(syslog_handler)\n</code></pre>"},{"location":"advanced/production-deployment/#security-hardening","title":"Security Hardening","text":""},{"location":"advanced/production-deployment/#user-isolation","title":"User Isolation","text":"<pre><code># Create dedicated user\nsudo useradd -r -s /bin/bash -m -d /opt/ralph ralph\nsudo chown -R ralph:ralph /opt/ralph-orchestrator\n\n# Set restrictive permissions\nchmod 750 /opt/ralph-orchestrator\nchmod 640 /opt/ralph-orchestrator/*.py\nchmod 750 /opt/ralph-orchestrator/ralph\n</code></pre>"},{"location":"advanced/production-deployment/#network-security","title":"Network Security","text":"<pre><code># Firewall rules (iptables)\niptables -A OUTPUT -p tcp --dport 443 -j ACCEPT  # HTTPS for AI agents\niptables -A OUTPUT -p tcp --dport 22 -j ACCEPT   # Git SSH\niptables -A OUTPUT -j DROP                       # Block other outbound\n\n# Or using ufw\nufw allow out 443/tcp\nufw allow out 22/tcp\nufw default deny outgoing\n</code></pre>"},{"location":"advanced/production-deployment/#api-key-management","title":"API Key Management","text":"<pre><code># Use system keyring\npip install keyring\n\n# Store API keys securely\npython -c \"import keyring; keyring.set_password('ralph', 'claude_api_key', 'your-key')\"\n\n# Or use environment variables from secure store\nsource /etc/ralph/secrets.env\n</code></pre>"},{"location":"advanced/production-deployment/#scaling-considerations","title":"Scaling Considerations","text":""},{"location":"advanced/production-deployment/#horizontal-scaling","title":"Horizontal Scaling","text":"<pre><code># job_queue.py\nimport redis\nimport json\n\nclass RalphJobQueue:\n    def __init__(self):\n        self.redis = redis.Redis(host='localhost', port=6379)\n\n    def add_job(self, prompt_file, config):\n        \"\"\"Add job to queue\"\"\"\n        job = {\n            'id': str(uuid.uuid4()),\n            'prompt_file': prompt_file,\n            'config': config,\n            'status': 'pending',\n            'created': time.time()\n        }\n        self.redis.lpush('ralph:jobs', json.dumps(job))\n        return job['id']\n\n    def get_job(self):\n        \"\"\"Get next job from queue\"\"\"\n        job_data = self.redis.rpop('ralph:jobs')\n        if job_data:\n            return json.loads(job_data)\n        return None\n</code></pre>"},{"location":"advanced/production-deployment/#resource-limits","title":"Resource Limits","text":"<pre><code># resource_limits.py\nimport resource\n\ndef set_production_limits():\n    \"\"\"Set resource limits for production\"\"\"\n\n    # Memory limit (4GB)\n    resource.setrlimit(\n        resource.RLIMIT_AS,\n        (4 * 1024 * 1024 * 1024, -1)\n    )\n\n    # CPU time limit (1 hour)\n    resource.setrlimit(\n        resource.RLIMIT_CPU,\n        (3600, 3600)\n    )\n\n    # File size limit (100MB)\n    resource.setrlimit(\n        resource.RLIMIT_FSIZE,\n        (100 * 1024 * 1024, -1)\n    )\n\n    # Process limit\n    resource.setrlimit(\n        resource.RLIMIT_NPROC,\n        (100, 100)\n    )\n</code></pre>"},{"location":"advanced/production-deployment/#backup-and-recovery","title":"Backup and Recovery","text":""},{"location":"advanced/production-deployment/#automated-backups","title":"Automated Backups","text":"<pre><code>#!/bin/bash\n# backup.sh\n\nBACKUP_DIR=\"/backup/ralph\"\nTIMESTAMP=$(date +%Y%m%d_%H%M%S)\n\n# Create backup\ntar -czf $BACKUP_DIR/ralph_$TIMESTAMP.tar.gz \\\n    /opt/ralph-orchestrator/.agent \\\n    /opt/ralph-orchestrator/*.json \\\n    /opt/ralph-orchestrator/PROMPT.md\n\n# Keep only last 30 days\nfind $BACKUP_DIR -name \"ralph_*.tar.gz\" -mtime +30 -delete\n\n# Sync to S3 (optional)\naws s3 sync $BACKUP_DIR s3://my-bucket/ralph-backups/\n</code></pre>"},{"location":"advanced/production-deployment/#disaster-recovery","title":"Disaster Recovery","text":"<pre><code>#!/bin/bash\n# restore.sh\n\nBACKUP_FILE=$1\nRESTORE_DIR=\"/opt/ralph-orchestrator\"\n\n# Stop service\nsystemctl stop ralph\n\n# Restore backup\ntar -xzf $BACKUP_FILE -C /\n\n# Reset Git repository\ncd $RESTORE_DIR\ngit reset --hard HEAD\n\n# Restart service\nsystemctl start ralph\n</code></pre>"},{"location":"advanced/production-deployment/#health-checks","title":"Health Checks","text":""},{"location":"advanced/production-deployment/#http-health-endpoint","title":"HTTP Health Endpoint","text":"<pre><code># health_server.py\nfrom flask import Flask, jsonify\nimport os\nimport json\n\napp = Flask(__name__)\n\n@app.route('/health')\ndef health():\n    \"\"\"Health check endpoint\"\"\"\n    try:\n        # Check Ralph process\n        pid_file = '/var/run/ralph.pid'\n        if os.path.exists(pid_file):\n            with open(pid_file) as f:\n                pid = int(f.read())\n            os.kill(pid, 0)  # Check if process exists\n            status = 'healthy'\n        else:\n            status = 'unhealthy'\n\n        # Check last state\n        state_files = glob.glob('.agent/metrics/state_*.json')\n        if state_files:\n            latest = max(state_files)\n            with open(latest) as f:\n                state = json.load(f)\n        else:\n            state = {}\n\n        return jsonify({\n            'status': status,\n            'iteration': state.get('iteration_count', 0),\n            'runtime': state.get('runtime', 0),\n            'errors': len(state.get('errors', []))\n        })\n    except Exception as e:\n        return jsonify({'status': 'error', 'message': str(e)}), 500\n\nif __name__ == '__main__':\n    app.run(host='0.0.0.0', port=8080)\n</code></pre>"},{"location":"advanced/production-deployment/#production-checklist","title":"Production Checklist","text":""},{"location":"advanced/production-deployment/#pre-deployment","title":"Pre-Deployment","text":"<ul> <li> All tests passing</li> <li> Configuration reviewed</li> <li> API keys secured</li> <li> Backup strategy in place</li> <li> Monitoring configured</li> <li> Resource limits set</li> <li> Security hardening applied</li> </ul>"},{"location":"advanced/production-deployment/#deployment","title":"Deployment","text":"<ul> <li> Service installed</li> <li> Permissions set correctly</li> <li> Logging configured</li> <li> Health checks working</li> <li> Metrics collection active</li> <li> Backup job scheduled</li> </ul>"},{"location":"advanced/production-deployment/#post-deployment","title":"Post-Deployment","text":"<ul> <li> Service running</li> <li> Logs being generated</li> <li> Metrics visible</li> <li> Test job successful</li> <li> Alerts configured</li> <li> Documentation updated</li> </ul>"},{"location":"advanced/security/","title":"Security Considerations","text":""},{"location":"advanced/security/#overview","title":"Overview","text":"<p>Ralph Orchestrator executes AI agents with significant system access. This document outlines security considerations and best practices for safe operation.</p>"},{"location":"advanced/security/#threat-model","title":"Threat Model","text":""},{"location":"advanced/security/#potential-risks","title":"Potential Risks","text":"<ol> <li>Unintended Code Execution</li> <li>AI agents may generate and execute harmful code</li> <li>File system modifications beyond project scope</li> <li> <p>System command execution</p> </li> <li> <p>Data Exposure</p> </li> <li>API keys in prompts or code</li> <li>Sensitive data in Git history</li> <li> <p>Credentials in state files</p> </li> <li> <p>Resource Exhaustion</p> </li> <li>Infinite loops in generated code</li> <li>Excessive API calls</li> <li> <p>Disk space consumption</p> </li> <li> <p>Supply Chain</p> </li> <li>Compromised AI CLI tools</li> <li>Malicious prompt injection</li> <li>Dependency vulnerabilities</li> </ol>"},{"location":"advanced/security/#security-controls","title":"Security Controls","text":""},{"location":"advanced/security/#process-isolation","title":"Process Isolation","text":"<p>Ralph runs AI agents in subprocesses with: - Timeout protection (5 minutes default) - Output size limits - Error boundaries</p> <pre><code>result = subprocess.run(\n    cmd,\n    capture_output=True,\n    text=True,\n    timeout=300,  # 5-minute timeout\n    env=filtered_env  # Sanitized environment\n)\n</code></pre>"},{"location":"advanced/security/#file-system-boundaries","title":"File System Boundaries","text":""},{"location":"advanced/security/#restricted-paths","title":"Restricted Paths","text":"<ul> <li>Work within project directory</li> <li>No access to system files</li> <li>Preserve .git integrity</li> </ul>"},{"location":"advanced/security/#safe-defaults","title":"Safe Defaults","text":"<pre><code># Validate paths stay within project\ndef validate_path(path):\n    abs_path = os.path.abspath(path)\n    project_path = os.path.abspath('.')\n    return abs_path.startswith(project_path)\n</code></pre>"},{"location":"advanced/security/#git-safety","title":"Git Safety","text":""},{"location":"advanced/security/#protected-operations","title":"Protected Operations","text":"<ul> <li>No force pushes</li> <li>No branch deletion</li> <li>No history rewriting</li> </ul>"},{"location":"advanced/security/#checkpoint-only-commits","title":"Checkpoint-Only Commits","text":"<pre><code># Ralph only creates checkpoint commits\ngit add .\ngit commit -m \"Ralph checkpoint: iteration N\"\n</code></pre>"},{"location":"advanced/security/#environment-sanitization","title":"Environment Sanitization","text":""},{"location":"advanced/security/#filtered-variables","title":"Filtered Variables","text":"<pre><code>SAFE_ENV_VARS = [\n    'PATH', 'HOME', 'USER', \n    'LANG', 'LC_ALL', 'TERM'\n]\n\ndef get_safe_env():\n    return {k: v for k, v in os.environ.items() \n            if k in SAFE_ENV_VARS}\n</code></pre>"},{"location":"advanced/security/#no-credential-exposure","title":"No Credential Exposure","text":"<ul> <li>Never pass API keys through environment</li> <li>Agents should use their own credential stores</li> <li>No secrets in prompts or logs</li> </ul>"},{"location":"advanced/security/#best-practices","title":"Best Practices","text":""},{"location":"advanced/security/#1-prompt-security","title":"1. Prompt Security","text":""},{"location":"advanced/security/#do","title":"DO:","text":"<ul> <li>Review prompts before execution</li> <li>Use specific, bounded instructions</li> <li>Include safety constraints</li> </ul>"},{"location":"advanced/security/#dont","title":"DON'T:","text":"<ul> <li>Include credentials in prompts</li> <li>Request system-level changes</li> <li>Use unbounded iterations</li> </ul>"},{"location":"advanced/security/#2-agent-configuration","title":"2. Agent Configuration","text":""},{"location":"advanced/security/#claude","title":"Claude","text":"<pre><code># Use restricted mode if available\nclaude --safe-mode PROMPT.md\n</code></pre>"},{"location":"advanced/security/#gemini","title":"Gemini","text":"<pre><code># Limit context and capabilities\ngemini --no-web --no-exec PROMPT.md\n</code></pre>"},{"location":"advanced/security/#3-repository-setup","title":"3. Repository Setup","text":""},{"location":"advanced/security/#gitignore","title":".gitignore","text":"<pre><code># Security-sensitive files\n*.key\n*.pem\n.env\n.env.*\nsecrets/\ncredentials/\n\n# Ralph workspace\n.agent/metrics/\n.agent/logs/\n</code></pre>"},{"location":"advanced/security/#pre-commit-hooks","title":"Pre-commit Hooks","text":"<pre><code># .pre-commit-config.yaml\nrepos:\n  - repo: https://github.com/Yelp/detect-secrets\n    hooks:\n      - id: detect-secrets\n        args: ['--baseline', '.secrets.baseline']\n</code></pre>"},{"location":"advanced/security/#4-runtime-monitoring","title":"4. Runtime Monitoring","text":""},{"location":"advanced/security/#resource-limits","title":"Resource Limits","text":"<pre><code># Set resource limits\nimport resource\n\n# Limit memory usage to 1GB\nresource.setrlimit(\n    resource.RLIMIT_AS,\n    (1024 * 1024 * 1024, -1)\n)\n\n# Limit CPU time to 1 hour\nresource.setrlimit(\n    resource.RLIMIT_CPU,\n    (3600, -1)\n)\n</code></pre>"},{"location":"advanced/security/#audit-logging","title":"Audit Logging","text":"<pre><code>import logging\nimport json\n\n# Log all agent executions\nlogging.info(json.dumps({\n    'event': 'agent_execution',\n    'agent': agent_name,\n    'timestamp': time.time(),\n    'user': os.getenv('USER'),\n    'prompt_hash': hashlib.sha256(prompt.encode()).hexdigest()\n}))\n</code></pre>"},{"location":"advanced/security/#security-checklist","title":"Security Checklist","text":""},{"location":"advanced/security/#before-running-ralph","title":"Before Running Ralph","text":"<ul> <li> Review PROMPT.md for unsafe instructions</li> <li> Check no credentials in prompt</li> <li> Verify working directory is correct</li> <li> Ensure Git repository is backed up</li> <li> Confirm agent tools are up-to-date</li> </ul>"},{"location":"advanced/security/#during-execution","title":"During Execution","text":"<ul> <li> Monitor resource usage</li> <li> Watch for unexpected file changes</li> <li> Check agent output for anomalies</li> <li> Verify checkpoints are created</li> <li> Ensure no sensitive data in logs</li> </ul>"},{"location":"advanced/security/#after-completion","title":"After Completion","text":"<ul> <li> Review generated code for security issues</li> <li> Check Git history for exposed secrets</li> <li> Verify no system files were modified</li> <li> Clean up temporary files</li> <li> Rotate any potentially exposed credentials</li> </ul>"},{"location":"advanced/security/#incident-response","title":"Incident Response","text":""},{"location":"advanced/security/#if-compromise-suspected","title":"If Compromise Suspected","text":"<ol> <li> <p>Immediate Actions <pre><code># Stop Ralph\npkill -f ralph_orchestrator\n\n# Preserve evidence\ncp -r .agent /tmp/ralph-incident-$(date +%s)\n\n# Check for modifications\ngit status\ngit diff\n</code></pre></p> </li> <li> <p>Investigation</p> </li> <li>Review .agent/metrics/state_*.json</li> <li>Check system logs</li> <li>Examine Git history</li> <li> <p>Analyze agent outputs</p> </li> <li> <p>Recovery <pre><code># Reset to last known good state\ngit reset --hard &lt;last-good-commit&gt;\n\n# Clean workspace\nrm -rf .agent\n\n# Rotate credentials if needed\n# Update API keys for affected services\n</code></pre></p> </li> </ol>"},{"location":"advanced/security/#sandboxing-options","title":"Sandboxing Options","text":""},{"location":"advanced/security/#docker-container","title":"Docker Container","text":"<pre><code>FROM python:3.11-slim\nRUN useradd -m -s /bin/bash ralph\nUSER ralph\nWORKDIR /home/ralph/project\nCOPY --chown=ralph:ralph . .\nCMD [\"./ralph\", \"run\"]\n</code></pre>"},{"location":"advanced/security/#virtual-machine","title":"Virtual Machine","text":"<pre><code># Run in VM with snapshot\nvagrant up\nvagrant ssh -c \"cd /project &amp;&amp; ./ralph run\"\nvagrant snapshot restore clean\n</code></pre>"},{"location":"advanced/security/#restricted-user","title":"Restricted User","text":"<pre><code># Create restricted user\nsudo useradd -m -s /bin/bash ralph-runner\nsudo usermod -L ralph-runner  # No password login\n\n# Run as restricted user\nsudo -u ralph-runner ./ralph run\n</code></pre>"},{"location":"advanced/security/#api-key-management","title":"API Key Management","text":""},{"location":"advanced/security/#secure-storage","title":"Secure Storage","text":""},{"location":"advanced/security/#never-store-keys-in","title":"Never Store Keys In:","text":"<ul> <li>PROMPT.md files</li> <li>Git repositories</li> <li>Environment variables in scripts</li> <li>Log files</li> </ul>"},{"location":"advanced/security/#recommended-approaches","title":"Recommended Approaches:","text":"<ol> <li>Agent-specific credential stores</li> <li>System keychain/keyring</li> <li>Encrypted vault (e.g., HashiCorp Vault)</li> <li>Cloud secret managers</li> </ol>"},{"location":"advanced/security/#key-rotation","title":"Key Rotation","text":"<pre><code># Regular rotation schedule\n# 1. Generate new keys\n# 2. Update agent configurations\n# 3. Test with new keys\n# 4. Revoke old keys\n</code></pre>"},{"location":"advanced/security/#compliance-considerations","title":"Compliance Considerations","text":""},{"location":"advanced/security/#data-privacy","title":"Data Privacy","text":"<ul> <li>Don't process PII in prompts</li> <li>Sanitize outputs before sharing</li> <li>Comply with data residency requirements</li> </ul>"},{"location":"advanced/security/#audit-trail","title":"Audit Trail","text":"<ul> <li>Maintain execution logs</li> <li>Track prompt modifications</li> <li>Document agent interactions</li> </ul>"},{"location":"advanced/security/#access-control","title":"Access Control","text":"<ul> <li>Limit who can run Ralph</li> <li>Restrict agent permissions</li> <li>Control repository access</li> </ul>"},{"location":"advanced/security/#security-updates","title":"Security Updates","text":"<p>Stay current with: - AI CLI tool updates - Python security patches - Git security advisories - Dependency vulnerabilities</p> <pre><code># Check for updates\nnpm update -g @anthropic-ai/claude-code\npip install --upgrade subprocess\ngit --version\n</code></pre>"},{"location":"advanced/security/#reporting-security-issues","title":"Reporting Security Issues","text":"<p>If you discover a security vulnerability:</p> <ol> <li>Do NOT open a public issue</li> <li>Email security report to: security@ralph-orchestrator.org</li> <li>Include:</li> <li>Description of vulnerability</li> <li>Steps to reproduce</li> <li>Potential impact</li> <li>Suggested fix (if any)</li> </ol> <p>We aim to respond within 48 hours and provide fixes promptly.</p>"},{"location":"api/agents/","title":"Agents API Reference","text":""},{"location":"api/agents/#overview","title":"Overview","text":"<p>The Agents API provides interfaces for interacting with different AI agents (Claude, Gemini, Q) and managing agent execution.</p>"},{"location":"api/agents/#agent-interface","title":"Agent Interface","text":""},{"location":"api/agents/#base-agent-class","title":"Base Agent Class","text":"<pre><code>class Agent:\n    \"\"\"\n    Abstract base class for AI agents.\n\n    All agent implementations must inherit from this class\n    and implement the required methods.\n    \"\"\"\n\n    def __init__(self, name: str, command: str):\n        \"\"\"\n        Initialize agent.\n\n        Args:\n            name (str): Agent identifier\n            command (str): Command to execute agent\n        \"\"\"\n        self.name = name\n        self.command = command\n        self.available = self.check_availability()\n\n    def check_availability(self) -&gt; bool:\n        \"\"\"\n        Check if agent is available on system.\n\n        Returns:\n            bool: True if agent is available\n\n        Example:\n            agent = ClaudeAgent()\n            if agent.available:\n                agent.execute(prompt)\n        \"\"\"\n        return shutil.which(self.command) is not None\n\n    def execute(self, prompt_file: str) -&gt; Tuple[bool, str]:\n        \"\"\"\n        Execute agent with prompt file.\n\n        Args:\n            prompt_file (str): Path to prompt file\n\n        Returns:\n            tuple: (success, output)\n\n        Raises:\n            AgentExecutionError: If execution fails\n        \"\"\"\n        raise NotImplementedError\n\n    def validate_prompt(self, prompt_file: str) -&gt; bool:\n        \"\"\"\n        Validate prompt file before execution.\n\n        Args:\n            prompt_file (str): Path to prompt file\n\n        Returns:\n            bool: True if prompt is valid\n        \"\"\"\n        if not os.path.exists(prompt_file):\n            return False\n\n        with open(prompt_file) as f:\n            content = f.read()\n\n        return len(content) &gt; 0 and len(content) &lt; self.max_context\n</code></pre>"},{"location":"api/agents/#agent-implementations","title":"Agent Implementations","text":""},{"location":"api/agents/#claude-agent","title":"Claude Agent","text":"<pre><code>class ClaudeAgent(Agent):\n    \"\"\"\n    Claude AI agent implementation.\n\n    Attributes:\n        max_context (int): Maximum context window (200K tokens)\n        timeout (int): Execution timeout in seconds\n    \"\"\"\n\n    def __init__(self):\n        super().__init__('claude', 'claude')\n        self.max_context = 800000  # ~200K tokens\n        self.timeout = 300\n\n    def execute(self, prompt_file: str) -&gt; Tuple[bool, str]:\n        \"\"\"\n        Execute Claude with prompt.\n\n        Args:\n            prompt_file (str): Path to prompt file\n\n        Returns:\n            tuple: (success, output)\n\n        Example:\n            claude = ClaudeAgent()\n            success, output = claude.execute('PROMPT.md')\n        \"\"\"\n        if not self.available:\n            return False, \"Claude not available\"\n\n        try:\n            result = subprocess.run(\n                [self.command, prompt_file],\n                capture_output=True,\n                text=True,\n                timeout=self.timeout,\n                env=self.get_environment()\n            )\n\n            return result.returncode == 0, result.stdout\n\n        except subprocess.TimeoutExpired:\n            return False, \"Claude execution timed out\"\n        except Exception as e:\n            return False, f\"Claude execution error: {str(e)}\"\n\n    def get_environment(self) -&gt; dict:\n        \"\"\"Get environment variables for Claude.\"\"\"\n        env = os.environ.copy()\n        # Add Claude-specific environment variables\n        return env\n</code></pre>"},{"location":"api/agents/#gemini-agent","title":"Gemini Agent","text":"<pre><code>class GeminiAgent(Agent):\n    \"\"\"\n    Gemini AI agent implementation.\n\n    Attributes:\n        max_context (int): Maximum context window (32K tokens)\n        timeout (int): Execution timeout in seconds\n    \"\"\"\n\n    def __init__(self):\n        super().__init__('gemini', 'gemini')\n        self.max_context = 130000  # ~32K tokens\n        self.timeout = 300\n\n    def execute(self, prompt_file: str) -&gt; Tuple[bool, str]:\n        \"\"\"\n        Execute Gemini with prompt.\n\n        Args:\n            prompt_file (str): Path to prompt file\n\n        Returns:\n            tuple: (success, output)\n\n        Example:\n            gemini = GeminiAgent()\n            success, output = gemini.execute('PROMPT.md')\n        \"\"\"\n        if not self.available:\n            return False, \"Gemini not available\"\n\n        try:\n            # Gemini may need additional arguments\n            cmd = [self.command, '--no-web', prompt_file]\n\n            result = subprocess.run(\n                cmd,\n                capture_output=True,\n                text=True,\n                timeout=self.timeout\n            )\n\n            return result.returncode == 0, result.stdout\n\n        except subprocess.TimeoutExpired:\n            return False, \"Gemini execution timed out\"\n        except Exception as e:\n            return False, f\"Gemini execution error: {str(e)}\"\n</code></pre>"},{"location":"api/agents/#q-agent","title":"Q Agent","text":"<pre><code>class QAgent(Agent):\n    \"\"\"\n    Q Chat AI agent implementation.\n\n    Attributes:\n        max_context (int): Maximum context window (8K tokens)\n        timeout (int): Execution timeout in seconds\n    \"\"\"\n\n    def __init__(self):\n        super().__init__('q', 'q')\n        self.max_context = 32000  # ~8K tokens\n        self.timeout = 300\n\n    def execute(self, prompt_file: str) -&gt; Tuple[bool, str]:\n        \"\"\"\n        Execute Q with prompt.\n\n        Args:\n            prompt_file (str): Path to prompt file\n\n        Returns:\n            tuple: (success, output)\n\n        Example:\n            q = QAgent()\n            success, output = q.execute('PROMPT.md')\n        \"\"\"\n        if not self.available:\n            return False, \"Q not available\"\n\n        try:\n            result = subprocess.run(\n                [self.command, prompt_file],\n                capture_output=True,\n                text=True,\n                timeout=self.timeout\n            )\n\n            return result.returncode == 0, result.stdout\n\n        except subprocess.TimeoutExpired:\n            return False, \"Q execution timed out\"\n        except Exception as e:\n            return False, f\"Q execution error: {str(e)}\"\n</code></pre>"},{"location":"api/agents/#agent-manager","title":"Agent Manager","text":"<pre><code>class AgentManager:\n    \"\"\"\n    Manages multiple AI agents and handles agent selection.\n\n    Example:\n        manager = AgentManager()\n        agent = manager.get_agent('auto')\n        success, output = agent.execute('PROMPT.md')\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"Initialize agent manager with all available agents.\"\"\"\n        self.agents = {\n            'claude': ClaudeAgent(),\n            'gemini': GeminiAgent(),\n            'q': QAgent()\n        }\n        self.available_agents = self.detect_available_agents()\n\n    def detect_available_agents(self) -&gt; List[str]:\n        \"\"\"\n        Detect which agents are available on the system.\n\n        Returns:\n            list: Names of available agents\n\n        Example:\n            manager = AgentManager()\n            available = manager.detect_available_agents()\n            print(f\"Available agents: {available}\")\n        \"\"\"\n        available = []\n        for name, agent in self.agents.items():\n            if agent.available:\n                available.append(name)\n        return available\n\n    def get_agent(self, name: str = 'auto') -&gt; Agent:\n        \"\"\"\n        Get specific agent or auto-select best available.\n\n        Args:\n            name (str): Agent name or 'auto' for auto-selection\n\n        Returns:\n            Agent: Selected agent instance\n\n        Raises:\n            ValueError: If requested agent not available\n\n        Example:\n            manager = AgentManager()\n\n            # Get specific agent\n            claude = manager.get_agent('claude')\n\n            # Auto-select best available\n            agent = manager.get_agent('auto')\n        \"\"\"\n        if name == 'auto':\n            return self.auto_select_agent()\n\n        if name not in self.agents:\n            raise ValueError(f\"Unknown agent: {name}\")\n\n        agent = self.agents[name]\n        if not agent.available:\n            raise ValueError(f\"Agent not available: {name}\")\n\n        return agent\n\n    def auto_select_agent(self) -&gt; Agent:\n        \"\"\"\n        Automatically select the best available agent.\n\n        Priority: claude &gt; gemini &gt; q\n\n        Returns:\n            Agent: Best available agent\n\n        Raises:\n            RuntimeError: If no agents available\n        \"\"\"\n        priority = ['claude', 'gemini', 'q']\n\n        for agent_name in priority:\n            if agent_name in self.available_agents:\n                return self.agents[agent_name]\n\n        raise RuntimeError(\"No AI agents available\")\n\n    def execute_with_fallback(self, prompt_file: str, \n                             preferred_agent: str = 'auto') -&gt; Tuple[bool, str, str]:\n        \"\"\"\n        Execute with fallback to other agents if preferred fails.\n\n        Args:\n            prompt_file (str): Path to prompt file\n            preferred_agent (str): Preferred agent name\n\n        Returns:\n            tuple: (success, output, agent_used)\n\n        Example:\n            manager = AgentManager()\n            success, output, agent = manager.execute_with_fallback('PROMPT.md')\n            print(f\"Executed with {agent}\")\n        \"\"\"\n        # Try preferred agent first\n        try:\n            agent = self.get_agent(preferred_agent)\n            success, output = agent.execute(prompt_file)\n            if success:\n                return True, output, agent.name\n        except (ValueError, RuntimeError):\n            pass\n\n        # Try other available agents\n        for agent_name in self.available_agents:\n            if agent_name != preferred_agent:\n                agent = self.agents[agent_name]\n                success, output = agent.execute(prompt_file)\n                if success:\n                    return True, output, agent.name\n\n        return False, \"All agents failed\", None\n</code></pre>"},{"location":"api/agents/#agent-execution-utilities","title":"Agent Execution Utilities","text":""},{"location":"api/agents/#retry-logic","title":"Retry Logic","text":"<pre><code>def execute_with_retry(agent: Agent, prompt_file: str, \n                       max_retries: int = 3, \n                       delay: int = 2) -&gt; Tuple[bool, str]:\n    \"\"\"\n    Execute agent with retry logic.\n\n    Args:\n        agent (Agent): Agent to execute\n        prompt_file (str): Path to prompt file\n        max_retries (int): Maximum retry attempts\n        delay (int): Delay between retries in seconds\n\n    Returns:\n        tuple: (success, output)\n\n    Example:\n        agent = ClaudeAgent()\n        success, output = execute_with_retry(agent, 'PROMPT.md')\n    \"\"\"\n    for attempt in range(max_retries):\n        success, output = agent.execute(prompt_file)\n\n        if success:\n            return True, output\n\n        if attempt &lt; max_retries - 1:\n            time.sleep(delay * (2 ** attempt))  # Exponential backoff\n\n    return False, f\"Failed after {max_retries} attempts\"\n</code></pre>"},{"location":"api/agents/#output-processing","title":"Output Processing","text":"<pre><code>def process_agent_output(output: str) -&gt; dict:\n    \"\"\"\n    Process and parse agent output.\n\n    Args:\n        output (str): Raw agent output\n\n    Returns:\n        dict: Processed output with metadata\n\n    Example:\n        success, raw_output = agent.execute('PROMPT.md')\n        processed = process_agent_output(raw_output)\n    \"\"\"\n    processed = {\n        'raw': output,\n        'lines': output.splitlines(),\n        'size': len(output),\n        'has_error': 'error' in output.lower(),\n        'has_completion': 'TASK_COMPLETE' in output,\n        'files_modified': extract_modified_files(output),\n        'commands_run': extract_commands(output)\n    }\n\n    return processed\n\ndef extract_modified_files(output: str) -&gt; List[str]:\n    \"\"\"Extract list of modified files from output.\"\"\"\n    files = []\n    patterns = [\n        r\"Created file: (.+)\",\n        r\"Modified file: (.+)\",\n        r\"Writing to (.+)\"\n    ]\n\n    for pattern in patterns:\n        matches = re.findall(pattern, output)\n        files.extend(matches)\n\n    return list(set(files))\n\ndef extract_commands(output: str) -&gt; List[str]:\n    \"\"\"Extract executed commands from output.\"\"\"\n    commands = []\n    patterns = [\n        r\"Running: (.+)\",\n        r\"Executing: (.+)\",\n        r\"\\$ (.+)\"\n    ]\n\n    for pattern in patterns:\n        matches = re.findall(pattern, output)\n        commands.extend(matches)\n\n    return commands\n</code></pre>"},{"location":"api/agents/#agent-metrics","title":"Agent Metrics","text":"<pre><code>class AgentMetrics:\n    \"\"\"\n    Track agent performance metrics.\n\n    Example:\n        metrics = AgentMetrics()\n        metrics.record_execution('claude', 45.3, True)\n        stats = metrics.get_stats('claude')\n    \"\"\"\n\n    def __init__(self):\n        self.executions = []\n\n    def record_execution(self, agent_name: str, \n                        duration: float, \n                        success: bool,\n                        output_size: int = 0):\n        \"\"\"\n        Record agent execution metrics.\n\n        Args:\n            agent_name (str): Name of agent\n            duration (float): Execution duration in seconds\n            success (bool): Whether execution succeeded\n            output_size (int): Size of output in bytes\n        \"\"\"\n        self.executions.append({\n            'agent': agent_name,\n            'duration': duration,\n            'success': success,\n            'output_size': output_size,\n            'timestamp': time.time()\n        })\n\n    def get_stats(self, agent_name: str = None) -&gt; dict:\n        \"\"\"\n        Get statistics for agent(s).\n\n        Args:\n            agent_name (str): Specific agent or None for all\n\n        Returns:\n            dict: Agent statistics\n        \"\"\"\n        if agent_name:\n            data = [e for e in self.executions if e['agent'] == agent_name]\n        else:\n            data = self.executions\n\n        if not data:\n            return {}\n\n        durations = [e['duration'] for e in data]\n        success_rate = sum(1 for e in data if e['success']) / len(data)\n\n        return {\n            'total_executions': len(data),\n            'success_rate': success_rate,\n            'avg_duration': sum(durations) / len(durations),\n            'min_duration': min(durations),\n            'max_duration': max(durations),\n            'total_duration': sum(durations)\n        }\n</code></pre>"},{"location":"api/agents/#custom-agent-implementation","title":"Custom Agent Implementation","text":"<pre><code>class CustomAgent(Agent):\n    \"\"\"\n    Template for implementing custom AI agents.\n\n    Example:\n        class MyAgent(CustomAgent):\n            def __init__(self):\n                super().__init__('myagent', 'myagent-cli')\n\n            def execute(self, prompt_file):\n                # Custom execution logic\n                pass\n    \"\"\"\n\n    def __init__(self, name: str, command: str):\n        super().__init__(name, command)\n        self.configure()\n\n    def configure(self):\n        \"\"\"Override to configure custom agent.\"\"\"\n        pass\n\n    def pre_execute(self, prompt_file: str):\n        \"\"\"Hook called before execution.\"\"\"\n        pass\n\n    def post_execute(self, output: str):\n        \"\"\"Hook called after execution.\"\"\"\n        pass\n\n    def execute(self, prompt_file: str) -&gt; Tuple[bool, str]:\n        \"\"\"Execute custom agent with hooks.\"\"\"\n        self.pre_execute(prompt_file)\n\n        # Implement custom execution logic\n        success, output = self._execute_command(prompt_file)\n\n        self.post_execute(output)\n\n        return success, output\n\n    def _execute_command(self, prompt_file: str) -&gt; Tuple[bool, str]:\n        \"\"\"Override with custom command execution.\"\"\"\n        raise NotImplementedError\n</code></pre>"},{"location":"api/cli/","title":"CLI API Reference","text":""},{"location":"api/cli/#overview","title":"Overview","text":"<p>The CLI API provides the command-line interface for Ralph Orchestrator, including commands, arguments, and shell integration.</p>"},{"location":"api/cli/#main-cli-interface","title":"Main CLI Interface","text":""},{"location":"api/cli/#ralphcli-class","title":"RalphCLI Class","text":"<pre><code>class RalphCLI:\n    \"\"\"\n    Main CLI interface for Ralph Orchestrator.\n\n    Example:\n        cli = RalphCLI()\n        cli.run(sys.argv[1:])\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"Initialize CLI with command registry.\"\"\"\n        self.commands = {\n            'run': self.cmd_run,\n            'init': self.cmd_init,\n            'status': self.cmd_status,\n            'clean': self.cmd_clean,\n            'config': self.cmd_config,\n            'agents': self.cmd_agents,\n            'metrics': self.cmd_metrics,\n            'checkpoint': self.cmd_checkpoint,\n            'rollback': self.cmd_rollback,\n            'help': self.cmd_help\n        }\n        self.parser = self.create_parser()\n\n    def create_parser(self) -&gt; argparse.ArgumentParser:\n        \"\"\"\n        Create argument parser.\n\n        Returns:\n            ArgumentParser: Configured parser\n        \"\"\"\n        parser = argparse.ArgumentParser(\n            prog='ralph',\n            description='Ralph Orchestrator - AI task automation',\n            formatter_class=argparse.RawDescriptionHelpFormatter,\n            epilog=\"\"\"\nExamples:\n  ralph run                    # Run with auto-detected agent\n  ralph run -a claude          # Run with Claude\n  ralph status                 # Check current status\n  ralph clean                  # Clean workspace\n  ralph init                   # Initialize new project\n            \"\"\"\n        )\n\n        # Global arguments\n        parser.add_argument(\n            '--version',\n            action='version',\n            version='%(prog)s 1.0.0'\n        )\n\n        parser.add_argument(\n            '--verbose', '-v',\n            action='store_true',\n            help='Enable verbose output'\n        )\n\n        parser.add_argument(\n            '--config', '-c',\n            help='Configuration file path'\n        )\n\n        # Subcommands\n        subparsers = parser.add_subparsers(\n            dest='command',\n            help='Available commands'\n        )\n\n        # Run command\n        run_parser = subparsers.add_parser(\n            'run',\n            help='Run orchestrator'\n        )\n        run_parser.add_argument(\n            '--agent', '-a',\n            choices=['claude', 'q', 'gemini', 'auto'],\n            default='auto',\n            help='AI agent to use'\n        )\n        run_parser.add_argument(\n            '--prompt', '-p',\n            default='PROMPT.md',\n            help='Prompt file path'\n        )\n        run_parser.add_argument(\n            '--max-iterations', '-i',\n            type=int,\n            default=100,\n            help='Maximum iterations'\n        )\n        run_parser.add_argument(\n            '--dry-run',\n            action='store_true',\n            help='Test mode without execution'\n        )\n\n        # Init command\n        subparsers.add_parser(\n            'init',\n            help='Initialize new project'\n        )\n\n        # Status command\n        subparsers.add_parser(\n            'status',\n            help='Show current status'\n        )\n\n        # Clean command\n        subparsers.add_parser(\n            'clean',\n            help='Clean workspace'\n        )\n\n        # Config command\n        config_parser = subparsers.add_parser(\n            'config',\n            help='Manage configuration'\n        )\n        config_parser.add_argument(\n            'action',\n            choices=['show', 'set', 'get'],\n            help='Configuration action'\n        )\n        config_parser.add_argument(\n            'key',\n            nargs='?',\n            help='Configuration key'\n        )\n        config_parser.add_argument(\n            'value',\n            nargs='?',\n            help='Configuration value'\n        )\n\n        # Agents command\n        subparsers.add_parser(\n            'agents',\n            help='List available agents'\n        )\n\n        # Metrics command\n        metrics_parser = subparsers.add_parser(\n            'metrics',\n            help='View metrics'\n        )\n        metrics_parser.add_argument(\n            '--format',\n            choices=['text', 'json', 'csv'],\n            default='text',\n            help='Output format'\n        )\n\n        # Checkpoint command\n        checkpoint_parser = subparsers.add_parser(\n            'checkpoint',\n            help='Create checkpoint'\n        )\n        checkpoint_parser.add_argument(\n            '--message', '-m',\n            help='Checkpoint message'\n        )\n\n        # Rollback command\n        rollback_parser = subparsers.add_parser(\n            'rollback',\n            help='Rollback to checkpoint'\n        )\n        rollback_parser.add_argument(\n            'checkpoint',\n            nargs='?',\n            help='Checkpoint ID or \"last\"'\n        )\n\n        return parser\n\n    def run(self, args: List[str] = None):\n        \"\"\"\n        Run CLI with arguments.\n\n        Args:\n            args (list): Command line arguments\n\n        Returns:\n            int: Exit code\n\n        Example:\n            cli = RalphCLI()\n            exit_code = cli.run(['run', '--agent', 'claude'])\n        \"\"\"\n        args = self.parser.parse_args(args)\n\n        # Setup logging\n        if args.verbose:\n            logging.basicConfig(level=logging.DEBUG)\n        else:\n            logging.basicConfig(level=logging.INFO)\n\n        # Load configuration\n        if args.config:\n            config = load_config(args.config)\n        else:\n            config = load_config()\n\n        # Execute command\n        if args.command:\n            command = self.commands.get(args.command)\n            if command:\n                return command(args, config)\n            else:\n                print(f\"Unknown command: {args.command}\")\n                return 1\n        else:\n            self.parser.print_help()\n            return 0\n</code></pre>"},{"location":"api/cli/#command-implementations","title":"Command Implementations","text":""},{"location":"api/cli/#run-command","title":"Run Command","text":"<pre><code>def cmd_run(self, args, config):\n    \"\"\"\n    Execute the run command.\n\n    Args:\n        args: Parsed arguments\n        config: Configuration dictionary\n\n    Returns:\n        int: Exit code\n\n    Example:\n        cli.cmd_run(args, config)\n    \"\"\"\n    # Update config with CLI arguments\n    if args.agent:\n        config['agent'] = args.agent\n    if args.prompt:\n        config['prompt_file'] = args.prompt\n    if args.max_iterations:\n        config['max_iterations'] = args.max_iterations\n    if args.dry_run:\n        config['dry_run'] = True\n\n    # Create and run orchestrator\n    orchestrator = RalphOrchestrator(config)\n\n    try:\n        result = orchestrator.run()\n\n        if result['success']:\n            print(f\"\u2713 Task completed in {result['iterations']} iterations\")\n            return 0\n        else:\n            print(f\"\u2717 Task failed: {result.get('error', 'Unknown error')}\")\n            return 1\n\n    except KeyboardInterrupt:\n        print(\"\\n\u26a0 Interrupted by user\")\n        return 130\n    except Exception as e:\n        print(f\"\u2717 Error: {str(e)}\")\n        return 1\n</code></pre>"},{"location":"api/cli/#init-command","title":"Init Command","text":"<pre><code>def cmd_init(self, args, config):\n    \"\"\"\n    Initialize new Ralph project.\n\n    Args:\n        args: Parsed arguments\n        config: Configuration dictionary\n\n    Returns:\n        int: Exit code\n\n    Example:\n        cli.cmd_init(args, config)\n    \"\"\"\n    print(\"Initializing Ralph Orchestrator project...\")\n\n    # Create directories\n    directories = ['.agent', '.agent/metrics', '.agent/prompts', \n                  '.agent/checkpoints', '.agent/plans']\n    for directory in directories:\n        os.makedirs(directory, exist_ok=True)\n        print(f\"  \u2713 Created {directory}\")\n\n    # Create default PROMPT.md\n    if not os.path.exists('PROMPT.md'):\n        with open('PROMPT.md', 'w') as f:\n            f.write(\"\"\"# Task Description\n\nDescribe your task here...\n\n## Requirements\n- [ ] Requirement 1\n- [ ] Requirement 2\n\n## Success Criteria\n- The task is complete when...\n\n&lt;!-- Ralph will add TASK_COMPLETE when done --&gt;\n\"\"\")\n        print(\"  \u2713 Created PROMPT.md template\")\n\n    # Create default config\n    if not os.path.exists('ralph.json'):\n        with open('ralph.json', 'w') as f:\n            json.dump({\n                'agent': 'auto',\n                'max_iterations': 100,\n                'checkpoint_interval': 5\n            }, f, indent=2)\n        print(\"  \u2713 Created ralph.json config\")\n\n    # Initialize Git if not present\n    if not os.path.exists('.git'):\n        subprocess.run(['git', 'init'], capture_output=True)\n        print(\"  \u2713 Initialized Git repository\")\n\n    print(\"\\n\u2713 Project initialized successfully!\")\n    print(\"\\nNext steps:\")\n    print(\"  1. Edit PROMPT.md with your task\")\n    print(\"  2. Run: ralph run\")\n\n    return 0\n</code></pre>"},{"location":"api/cli/#status-command","title":"Status Command","text":"<pre><code>def cmd_status(self, args, config):\n    \"\"\"\n    Show current Ralph status.\n\n    Args:\n        args: Parsed arguments\n        config: Configuration dictionary\n\n    Returns:\n        int: Exit code\n\n    Example:\n        cli.cmd_status(args, config)\n    \"\"\"\n    print(\"Ralph Orchestrator Status\")\n    print(\"=\" * 40)\n\n    # Check prompt file\n    if os.path.exists('PROMPT.md'):\n        print(f\"\u2713 Prompt: PROMPT.md exists\")\n\n        # Check if task is complete\n        with open('PROMPT.md') as f:\n            content = f.read()\n        if 'TASK_COMPLETE' in content:\n            print(\"\u2713 Status: COMPLETE\")\n        else:\n            print(\"\u26a0 Status: IN PROGRESS\")\n    else:\n        print(\"\u2717 Prompt: PROMPT.md not found\")\n\n    # Check state\n    state_file = '.agent/metrics/state_latest.json'\n    if os.path.exists(state_file):\n        with open(state_file) as f:\n            state = json.load(f)\n\n        print(f\"\\nLatest State:\")\n        print(f\"  Iterations: {state.get('iteration_count', 0)}\")\n        print(f\"  Runtime: {state.get('runtime', 0):.1f}s\")\n        print(f\"  Agent: {state.get('agent', 'none')}\")\n        print(f\"  Errors: {len(state.get('errors', []))}\")\n\n    # Check available agents\n    manager = AgentManager()\n    available = manager.detect_available_agents()\n    print(f\"\\nAvailable Agents: {', '.join(available) if available else 'none'}\")\n\n    # Check Git status\n    result = subprocess.run(\n        ['git', 'status', '--porcelain'],\n        capture_output=True,\n        text=True\n    )\n    if result.stdout:\n        print(f\"\\n\u26a0 Uncommitted changes present\")\n    else:\n        print(f\"\\n\u2713 Git: clean working directory\")\n\n    return 0\n</code></pre>"},{"location":"api/cli/#clean-command","title":"Clean Command","text":"<pre><code>def cmd_clean(self, args, config):\n    \"\"\"\n    Clean Ralph workspace.\n\n    Args:\n        args: Parsed arguments\n        config: Configuration dictionary\n\n    Returns:\n        int: Exit code\n\n    Example:\n        cli.cmd_clean(args, config)\n    \"\"\"\n    print(\"Cleaning Ralph workspace...\")\n\n    # Confirm before cleaning\n    response = input(\"This will remove all Ralph data. Continue? [y/N]: \")\n    if response.lower() != 'y':\n        print(\"Cancelled\")\n        return 0\n\n    # Clean directories\n    directories = [\n        '.agent/metrics',\n        '.agent/prompts',\n        '.agent/checkpoints',\n        '.agent/logs'\n    ]\n\n    for directory in directories:\n        if os.path.exists(directory):\n            shutil.rmtree(directory)\n            os.makedirs(directory)\n            print(f\"  \u2713 Cleaned {directory}\")\n\n    # Reset state\n    state = StateManager()\n    state.reset()\n    print(\"  \u2713 Reset state\")\n\n    print(\"\\n\u2713 Workspace cleaned successfully!\")\n\n    return 0\n</code></pre>"},{"location":"api/cli/#shell-integration","title":"Shell Integration","text":""},{"location":"api/cli/#bash-completion","title":"Bash Completion","text":"<pre><code># ralph-completion.bash\n_ralph_completion() {\n    local cur prev opts\n    COMPREPLY=()\n    cur=\"${COMP_WORDS[COMP_CWORD]}\"\n    prev=\"${COMP_WORDS[COMP_CWORD-1]}\"\n\n    # Main commands\n    opts=\"run init status clean config agents metrics checkpoint rollback help\"\n\n    case \"${prev}\" in\n        ralph)\n            COMPREPLY=( $(compgen -W \"${opts}\" -- ${cur}) )\n            return 0\n            ;;\n        --agent|-a)\n            COMPREPLY=( $(compgen -W \"claude q gemini auto\" -- ${cur}) )\n            return 0\n            ;;\n        --format)\n            COMPREPLY=( $(compgen -W \"text json csv\" -- ${cur}) )\n            return 0\n            ;;\n        config)\n            COMPREPLY=( $(compgen -W \"show set get\" -- ${cur}) )\n            return 0\n            ;;\n    esac\n\n    # File completion for prompt files\n    if [[ ${cur} == *.md ]]; then\n        COMPREPLY=( $(compgen -f -X '!*.md' -- ${cur}) )\n        return 0\n    fi\n\n    COMPREPLY=( $(compgen -W \"${opts}\" -- ${cur}) )\n}\n\ncomplete -F _ralph_completion ralph\n</code></pre>"},{"location":"api/cli/#zsh-completion","title":"ZSH Completion","text":"<pre><code># ralph-completion.zsh\n#compdef ralph\n\n_ralph() {\n    local -a commands\n    commands=(\n        'run:Run orchestrator'\n        'init:Initialize project'\n        'status:Show status'\n        'clean:Clean workspace'\n        'config:Manage configuration'\n        'agents:List agents'\n        'metrics:View metrics'\n        'checkpoint:Create checkpoint'\n        'rollback:Rollback to checkpoint'\n        'help:Show help'\n    )\n\n    _arguments \\\n        '--version[Show version]' \\\n        '--verbose[Enable verbose output]' \\\n        '--config[Configuration file]:file:_files' \\\n        '1:command:-&gt;command' \\\n        '*::arg:-&gt;args'\n\n    case $state in\n        command)\n            _describe 'command' commands\n            ;;\n        args)\n            case $words[1] in\n                run)\n                    _arguments \\\n                        '--agent[AI agent]:agent:(claude q gemini auto)' \\\n                        '--prompt[Prompt file]:file:_files -g \"*.md\"' \\\n                        '--max-iterations[Max iterations]:number' \\\n                        '--dry-run[Test mode]'\n                    ;;\n                config)\n                    _arguments \\\n                        '1:action:(show set get)' \\\n                        '2:key' \\\n                        '3:value'\n                    ;;\n            esac\n            ;;\n    esac\n}\n</code></pre>"},{"location":"api/cli/#interactive-mode","title":"Interactive Mode","text":"<pre><code>class InteractiveCLI:\n    \"\"\"\n    Interactive CLI mode for Ralph.\n\n    Example:\n        interactive = InteractiveCLI()\n        interactive.run()\n    \"\"\"\n\n    def __init__(self):\n        self.running = True\n        self.orchestrator = None\n        self.config = load_config()\n\n    def run(self):\n        \"\"\"Run interactive mode.\"\"\"\n        print(\"Ralph Orchestrator Interactive Mode\")\n        print(\"Type 'help' for commands, 'exit' to quit\")\n        print()\n\n        while self.running:\n            try:\n                command = input(\"ralph&gt; \").strip()\n                if command:\n                    self.execute_command(command)\n            except KeyboardInterrupt:\n                print(\"\\nUse 'exit' to quit\")\n            except EOFError:\n                self.running = False\n\n    def execute_command(self, command: str):\n        \"\"\"Execute interactive command.\"\"\"\n        parts = command.split()\n        cmd = parts[0]\n        args = parts[1:] if len(parts) &gt; 1 else []\n\n        commands = {\n            'help': self.cmd_help,\n            'run': self.cmd_run,\n            'status': self.cmd_status,\n            'stop': self.cmd_stop,\n            'config': self.cmd_config,\n            'agents': self.cmd_agents,\n            'exit': self.cmd_exit,\n            'quit': self.cmd_exit\n        }\n\n        if cmd in commands:\n            commands[cmd](args)\n        else:\n            print(f\"Unknown command: {cmd}\")\n\n    def cmd_help(self, args):\n        \"\"\"Show help.\"\"\"\n        print(\"\"\"\nAvailable commands:\n  run [agent]    - Start orchestrator\n  status         - Show current status\n  stop           - Stop orchestrator\n  config [key]   - Show/set configuration\n  agents         - List available agents\n  help           - Show this help\n  exit           - Exit interactive mode\n        \"\"\")\n\n    def cmd_exit(self, args):\n        \"\"\"Exit interactive mode.\"\"\"\n        if self.orchestrator:\n            print(\"Stopping orchestrator...\")\n            # Stop orchestrator\n        print(\"Goodbye!\")\n        self.running = False\n</code></pre>"},{"location":"api/cli/#plugin-system","title":"Plugin System","text":"<pre><code>class CLIPlugin:\n    \"\"\"\n    Base class for CLI plugins.\n\n    Example:\n        class MyPlugin(CLIPlugin):\n            def register_commands(self, cli):\n                cli.add_command('mycommand', self.my_command)\n    \"\"\"\n\n    def __init__(self, name: str):\n        self.name = name\n\n    def register_commands(self, cli: RalphCLI):\n        \"\"\"Register plugin commands with CLI.\"\"\"\n        raise NotImplementedError\n\n    def register_arguments(self, parser: argparse.ArgumentParser):\n        \"\"\"Register plugin arguments.\"\"\"\n        pass\n\nclass PluginManager:\n    \"\"\"Manage CLI plugins.\"\"\"\n\n    def __init__(self):\n        self.plugins = []\n\n    def load_plugin(self, plugin: CLIPlugin):\n        \"\"\"Load a plugin.\"\"\"\n        self.plugins.append(plugin)\n\n    def register_all(self, cli: RalphCLI):\n        \"\"\"Register all plugins with CLI.\"\"\"\n        for plugin in self.plugins:\n            plugin.register_commands(cli)\n</code></pre>"},{"location":"api/config/","title":"Configuration API Reference","text":""},{"location":"api/config/#overview","title":"Overview","text":"<p>The Configuration API provides methods for managing Ralph Orchestrator settings, including agent selection, runtime limits, and behavior customization.</p>"},{"location":"api/config/#configuration-structure","title":"Configuration Structure","text":""},{"location":"api/config/#default-configuration","title":"Default Configuration","text":"<pre><code>DEFAULT_CONFIG = {\n    'agent': 'auto',                    # AI agent to use\n    'prompt_file': 'PROMPT.md',         # Task description file\n    'max_iterations': 100,               # Maximum loop iterations\n    'max_runtime': 14400,                # Maximum runtime in seconds (4 hours)\n    'checkpoint_interval': 5,            # Create checkpoint every N iterations\n    'retry_delay': 2,                    # Delay between retries in seconds\n    'retry_max': 5,                      # Maximum consecutive errors\n    'timeout_per_iteration': 300,        # Timeout per iteration in seconds\n    'verbose': False,                    # Enable verbose logging\n    'dry_run': False,                    # Test mode without execution\n    'git_enabled': True,                 # Enable Git checkpointing\n    'archive_enabled': True,             # Enable prompt archiving\n    'working_directory': '.',            # Working directory path\n    'agent_directory': '.agent'          # Agent workspace directory\n}\n</code></pre>"},{"location":"api/config/#configuration-loading","title":"Configuration Loading","text":""},{"location":"api/config/#from-file","title":"From File","text":"<pre><code>def load_config(config_file='config.json'):\n    \"\"\"\n    Load configuration from JSON file.\n\n    Args:\n        config_file (str): Path to configuration file\n\n    Returns:\n        dict: Merged configuration with defaults\n\n    Example:\n        config = load_config('production.json')\n    \"\"\"\n    config = DEFAULT_CONFIG.copy()\n\n    if os.path.exists(config_file):\n        with open(config_file) as f:\n            user_config = json.load(f)\n        config.update(user_config)\n\n    return config\n</code></pre>"},{"location":"api/config/#from-environment-variables","title":"From Environment Variables","text":"<pre><code>def load_env_config():\n    \"\"\"\n    Load configuration from environment variables.\n\n    Environment variables:\n        RALPH_AGENT: Agent to use (claude, q, gemini, auto)\n        RALPH_MAX_ITERATIONS: Maximum iterations\n        RALPH_MAX_RUNTIME: Maximum runtime in seconds\n        RALPH_CHECKPOINT_INTERVAL: Checkpoint interval\n        RALPH_VERBOSE: Enable verbose mode (true/false)\n        RALPH_DRY_RUN: Enable dry run mode (true/false)\n\n    Returns:\n        dict: Configuration from environment\n\n    Example:\n        os.environ['RALPH_AGENT'] = 'claude'\n        config = load_env_config()\n    \"\"\"\n    config = {}\n\n    # String values\n    for key in ['AGENT', 'PROMPT_FILE', 'WORKING_DIRECTORY']:\n        env_key = f'RALPH_{key}'\n        if env_key in os.environ:\n            config[key.lower()] = os.environ[env_key]\n\n    # Integer values\n    for key in ['MAX_ITERATIONS', 'MAX_RUNTIME', 'CHECKPOINT_INTERVAL']:\n        env_key = f'RALPH_{key}'\n        if env_key in os.environ:\n            config[key.lower()] = int(os.environ[env_key])\n\n    # Boolean values\n    for key in ['VERBOSE', 'DRY_RUN', 'GIT_ENABLED']:\n        env_key = f'RALPH_{key}'\n        if env_key in os.environ:\n            config[key.lower()] = os.environ[env_key].lower() == 'true'\n\n    return config\n</code></pre>"},{"location":"api/config/#from-command-line-arguments","title":"From Command Line Arguments","text":"<pre><code>def parse_args():\n    \"\"\"\n    Parse command line arguments for configuration.\n\n    Returns:\n        argparse.Namespace: Parsed arguments\n\n    Example:\n        args = parse_args()\n        config = vars(args)\n    \"\"\"\n    parser = argparse.ArgumentParser(\n        description='Ralph Orchestrator - AI task automation'\n    )\n\n    parser.add_argument(\n        '--agent',\n        choices=['claude', 'q', 'gemini', 'auto'],\n        default='auto',\n        help='AI agent to use'\n    )\n\n    parser.add_argument(\n        '--prompt',\n        default='PROMPT.md',\n        help='Prompt file path'\n    )\n\n    parser.add_argument(\n        '--max-iterations',\n        type=int,\n        default=100,\n        help='Maximum iterations'\n    )\n\n    parser.add_argument(\n        '--max-runtime',\n        type=int,\n        default=14400,\n        help='Maximum runtime in seconds'\n    )\n\n    parser.add_argument(\n        '--checkpoint-interval',\n        type=int,\n        default=5,\n        help='Checkpoint every N iterations'\n    )\n\n    parser.add_argument(\n        '--verbose',\n        action='store_true',\n        help='Enable verbose output'\n    )\n\n    parser.add_argument(\n        '--dry-run',\n        action='store_true',\n        help='Test mode without execution'\n    )\n\n    return parser.parse_args()\n</code></pre>"},{"location":"api/config/#configuration-validation","title":"Configuration Validation","text":"<pre><code>def validate_config(config):\n    \"\"\"\n    Validate configuration values.\n\n    Args:\n        config (dict): Configuration to validate\n\n    Raises:\n        ValueError: If configuration is invalid\n\n    Example:\n        config = load_config()\n        validate_config(config)\n    \"\"\"\n    # Check required fields\n    required_fields = ['agent', 'prompt_file', 'max_iterations']\n    for field in required_fields:\n        if field not in config:\n            raise ValueError(f\"Missing required field: {field}\")\n\n    # Validate agent\n    valid_agents = ['claude', 'q', 'gemini', 'auto']\n    if config['agent'] not in valid_agents:\n        raise ValueError(f\"Invalid agent: {config['agent']}\")\n\n    # Validate numeric limits\n    if config['max_iterations'] &lt; 1:\n        raise ValueError(\"max_iterations must be at least 1\")\n\n    if config['max_runtime'] &lt; 60:\n        raise ValueError(\"max_runtime must be at least 60 seconds\")\n\n    if config['checkpoint_interval'] &lt; 1:\n        raise ValueError(\"checkpoint_interval must be at least 1\")\n\n    # Validate file paths\n    if not os.path.exists(config['prompt_file']):\n        raise ValueError(f\"Prompt file not found: {config['prompt_file']}\")\n\n    return True\n</code></pre>"},{"location":"api/config/#configuration-merging","title":"Configuration Merging","text":"<pre><code>def merge_configs(*configs):\n    \"\"\"\n    Merge multiple configuration sources with priority.\n\n    Priority (highest to lowest):\n    1. Command line arguments\n    2. Environment variables\n    3. Configuration file\n    4. Defaults\n\n    Args:\n        *configs: Configuration dictionaries to merge\n\n    Returns:\n        dict: Merged configuration\n\n    Example:\n        final_config = merge_configs(\n            DEFAULT_CONFIG,\n            file_config,\n            env_config,\n            cli_config\n        )\n    \"\"\"\n    merged = {}\n\n    for config in configs:\n        if config:\n            merged.update({k: v for k, v in config.items() \n                          if v is not None})\n\n    return merged\n</code></pre>"},{"location":"api/config/#configuration-access","title":"Configuration Access","text":"<pre><code>class Config:\n    \"\"\"\n    Configuration accessor with dot notation support.\n\n    Example:\n        config = Config(load_config())\n        print(config.agent)\n        print(config.max_iterations)\n    \"\"\"\n\n    def __init__(self, config_dict):\n        self._config = config_dict\n\n    def __getattr__(self, name):\n        if name in self._config:\n            return self._config[name]\n        raise AttributeError(f\"Config has no attribute '{name}'\")\n\n    def __setattr__(self, name, value):\n        if name == '_config':\n            super().__setattr__(name, value)\n        else:\n            self._config[name] = value\n\n    def get(self, key, default=None):\n        \"\"\"Get configuration value with default.\"\"\"\n        return self._config.get(key, default)\n\n    def update(self, updates):\n        \"\"\"Update configuration values.\"\"\"\n        self._config.update(updates)\n\n    def to_dict(self):\n        \"\"\"Convert to dictionary.\"\"\"\n        return self._config.copy()\n\n    def save(self, filename):\n        \"\"\"Save configuration to file.\"\"\"\n        with open(filename, 'w') as f:\n            json.dump(self._config, f, indent=2)\n</code></pre>"},{"location":"api/config/#agent-specific-configuration","title":"Agent-Specific Configuration","text":""},{"location":"api/config/#claude-configuration","title":"Claude Configuration","text":"<pre><code>CLAUDE_CONFIG = {\n    'command': 'claude',\n    'args': [],\n    'env': {},\n    'timeout': 300,\n    'context_limit': 200000,\n    'features': {\n        'code_execution': True,\n        'web_search': False,\n        'file_operations': True\n    }\n}\n</code></pre>"},{"location":"api/config/#gemini-configuration","title":"Gemini Configuration","text":"<pre><code>GEMINI_CONFIG = {\n    'command': 'gemini',\n    'args': ['--no-web'],\n    'env': {},\n    'timeout': 300,\n    'context_limit': 32768,\n    'features': {\n        'code_execution': True,\n        'web_search': True,\n        'file_operations': True\n    }\n}\n</code></pre>"},{"location":"api/config/#q-configuration","title":"Q Configuration","text":"<pre><code>Q_CONFIG = {\n    'command': 'q',\n    'args': [],\n    'env': {},\n    'timeout': 300,\n    'context_limit': 8192,\n    'features': {\n        'code_execution': True,\n        'web_search': False,\n        'file_operations': True\n    }\n}\n</code></pre>"},{"location":"api/config/#runtime-configuration","title":"Runtime Configuration","text":""},{"location":"api/config/#dynamic-updates","title":"Dynamic Updates","text":"<pre><code>class RuntimeConfig:\n    \"\"\"\n    Configuration that can be updated during execution.\n\n    Example:\n        runtime_config = RuntimeConfig(initial_config)\n        runtime_config.update_agent('gemini')\n        runtime_config.adjust_limits(iterations=50)\n    \"\"\"\n\n    def __init__(self, initial_config):\n        self.config = initial_config.copy()\n        self.history = [initial_config.copy()]\n\n    def update_agent(self, agent):\n        \"\"\"Switch to different agent.\"\"\"\n        if agent in ['claude', 'q', 'gemini']:\n            self.config['agent'] = agent\n            self.history.append(self.config.copy())\n\n    def adjust_limits(self, iterations=None, runtime=None):\n        \"\"\"Adjust runtime limits.\"\"\"\n        if iterations:\n            self.config['max_iterations'] = iterations\n        if runtime:\n            self.config['max_runtime'] = runtime\n        self.history.append(self.config.copy())\n\n    def rollback(self):\n        \"\"\"Rollback to previous configuration.\"\"\"\n        if len(self.history) &gt; 1:\n            self.history.pop()\n            self.config = self.history[-1].copy()\n</code></pre>"},{"location":"api/config/#configuration-templates","title":"Configuration Templates","text":""},{"location":"api/config/#development-template","title":"Development Template","text":"<pre><code>{\n  \"agent\": \"auto\",\n  \"max_iterations\": 50,\n  \"max_runtime\": 3600,\n  \"checkpoint_interval\": 10,\n  \"verbose\": true,\n  \"dry_run\": false,\n  \"git_enabled\": true,\n  \"archive_enabled\": true\n}\n</code></pre>"},{"location":"api/config/#production-template","title":"Production Template","text":"<pre><code>{\n  \"agent\": \"claude\",\n  \"max_iterations\": 100,\n  \"max_runtime\": 14400,\n  \"checkpoint_interval\": 5,\n  \"retry_delay\": 5,\n  \"retry_max\": 3,\n  \"verbose\": false,\n  \"dry_run\": false,\n  \"git_enabled\": true,\n  \"archive_enabled\": true,\n  \"monitoring\": {\n    \"enabled\": true,\n    \"metrics_interval\": 60,\n    \"alert_on_error\": true\n  }\n}\n</code></pre>"},{"location":"api/config/#testing-template","title":"Testing Template","text":"<pre><code>{\n  \"agent\": \"auto\",\n  \"max_iterations\": 10,\n  \"max_runtime\": 600,\n  \"checkpoint_interval\": 1,\n  \"verbose\": true,\n  \"dry_run\": true,\n  \"git_enabled\": false,\n  \"archive_enabled\": false\n}\n</code></pre>"},{"location":"api/config/#configuration-examples","title":"Configuration Examples","text":""},{"location":"api/config/#basic-usage","title":"Basic Usage","text":"<pre><code># Load default configuration\nconfig = Config(DEFAULT_CONFIG)\n\n# Update specific values\nconfig.agent = 'claude'\nconfig.max_iterations = 50\n\n# Access values\nprint(f\"Using agent: {config.agent}\")\nprint(f\"Max iterations: {config.max_iterations}\")\n</code></pre>"},{"location":"api/config/#advanced-usage","title":"Advanced Usage","text":"<pre><code># Load from multiple sources\nfile_config = load_config('custom.json')\nenv_config = load_env_config()\ncli_config = vars(parse_args())\n\n# Merge with priority\nfinal_config = merge_configs(\n    DEFAULT_CONFIG,\n    file_config,\n    env_config,\n    cli_config\n)\n\n# Validate\nvalidate_config(final_config)\n\n# Create accessor\nconfig = Config(final_config)\n\n# Save for reproducibility\nconfig.save('execution_config.json')\n</code></pre>"},{"location":"api/config/#programmatic-configuration","title":"Programmatic Configuration","text":"<pre><code># Create configuration programmatically\nconfig = Config({\n    'agent': detect_best_agent(),\n    'prompt_file': 'task.md',\n    'max_iterations': calculate_iterations(task_complexity),\n    'max_runtime': estimate_runtime(task_size),\n    'checkpoint_interval': 5 if production else 10,\n    'verbose': debug_mode,\n    'dry_run': test_mode\n})\n\n# Use configuration\norchestrator = RalphOrchestrator(config.to_dict())\nresult = orchestrator.run()\n</code></pre>"},{"location":"api/metrics/","title":"Metrics API Reference","text":""},{"location":"api/metrics/#overview","title":"Overview","text":"<p>The Metrics API provides functionality for collecting, storing, and analyzing execution metrics from Ralph Orchestrator runs.</p>"},{"location":"api/metrics/#metrics-collection","title":"Metrics Collection","text":""},{"location":"api/metrics/#metricscollector-class","title":"MetricsCollector Class","text":"<pre><code>class MetricsCollector:\n    \"\"\"\n    Collects and manages execution metrics.\n\n    Example:\n        collector = MetricsCollector()\n        collector.start_iteration(1)\n        # ... execution ...\n        collector.end_iteration(1, success=True)\n        collector.save()\n    \"\"\"\n\n    def __init__(self, metrics_dir: str = '.agent/metrics'):\n        \"\"\"\n        Initialize metrics collector.\n\n        Args:\n            metrics_dir (str): Directory to store metrics files\n        \"\"\"\n        self.metrics_dir = metrics_dir\n        self.current_metrics = {\n            'start_time': None,\n            'iterations': [],\n            'errors': [],\n            'checkpoints': [],\n            'agent_executions': [],\n            'resource_usage': []\n        }\n        self._ensure_metrics_dir()\n\n    def _ensure_metrics_dir(self):\n        \"\"\"Create metrics directory if it doesn't exist.\"\"\"\n        os.makedirs(self.metrics_dir, exist_ok=True)\n\n    def start_iteration(self, iteration_num: int):\n        \"\"\"\n        Mark the start of an iteration.\n\n        Args:\n            iteration_num (int): Iteration number\n\n        Example:\n            collector.start_iteration(1)\n        \"\"\"\n        self.current_iteration = {\n            'number': iteration_num,\n            'start_time': time.time(),\n            'end_time': None,\n            'duration': None,\n            'success': False,\n            'output_size': 0,\n            'errors': []\n        }\n\n    def end_iteration(self, iteration_num: int, \n                     success: bool = True, \n                     output_size: int = 0):\n        \"\"\"\n        Mark the end of an iteration.\n\n        Args:\n            iteration_num (int): Iteration number\n            success (bool): Whether iteration succeeded\n            output_size (int): Size of output in bytes\n\n        Example:\n            collector.end_iteration(1, success=True, output_size=2048)\n        \"\"\"\n        if hasattr(self, 'current_iteration'):\n            self.current_iteration['end_time'] = time.time()\n            self.current_iteration['duration'] = (\n                self.current_iteration['end_time'] - \n                self.current_iteration['start_time']\n            )\n            self.current_iteration['success'] = success\n            self.current_iteration['output_size'] = output_size\n\n            self.current_metrics['iterations'].append(self.current_iteration)\n            del self.current_iteration\n\n    def record_error(self, error: str, iteration: int = None):\n        \"\"\"\n        Record an error.\n\n        Args:\n            error (str): Error message\n            iteration (int): Iteration number where error occurred\n\n        Example:\n            collector.record_error(\"Agent timeout\", iteration=5)\n        \"\"\"\n        error_record = {\n            'timestamp': time.time(),\n            'iteration': iteration,\n            'message': error,\n            'traceback': traceback.format_exc() if sys.exc_info()[0] else None\n        }\n\n        self.current_metrics['errors'].append(error_record)\n\n        if hasattr(self, 'current_iteration'):\n            self.current_iteration['errors'].append(error)\n\n    def record_checkpoint(self, iteration: int, commit_hash: str = None):\n        \"\"\"\n        Record a checkpoint.\n\n        Args:\n            iteration (int): Iteration number\n            commit_hash (str): Git commit hash\n\n        Example:\n            collector.record_checkpoint(5, \"abc123def\")\n        \"\"\"\n        checkpoint = {\n            'iteration': iteration,\n            'timestamp': time.time(),\n            'commit_hash': commit_hash\n        }\n        self.current_metrics['checkpoints'].append(checkpoint)\n\n    def record_agent_execution(self, agent: str, \n                              duration: float, \n                              success: bool):\n        \"\"\"\n        Record agent execution details.\n\n        Args:\n            agent (str): Agent name\n            duration (float): Execution duration\n            success (bool): Whether execution succeeded\n\n        Example:\n            collector.record_agent_execution('claude', 45.3, True)\n        \"\"\"\n        execution = {\n            'agent': agent,\n            'duration': duration,\n            'success': success,\n            'timestamp': time.time()\n        }\n        self.current_metrics['agent_executions'].append(execution)\n\n    def record_resource_usage(self):\n        \"\"\"\n        Record current resource usage.\n\n        Example:\n            collector.record_resource_usage()\n        \"\"\"\n        import psutil\n\n        process = psutil.Process()\n        usage = {\n            'timestamp': time.time(),\n            'cpu_percent': process.cpu_percent(),\n            'memory_mb': process.memory_info().rss / 1024 / 1024,\n            'disk_io': process.io_counters()._asdict() if hasattr(process, 'io_counters') else {},\n            'open_files': len(process.open_files()) if hasattr(process, 'open_files') else 0\n        }\n        self.current_metrics['resource_usage'].append(usage)\n\n    def save(self, filename: str = None):\n        \"\"\"\n        Save metrics to file.\n\n        Args:\n            filename (str): Custom filename or auto-generated\n\n        Returns:\n            str: Path to saved metrics file\n\n        Example:\n            path = collector.save()\n            print(f\"Metrics saved to {path}\")\n        \"\"\"\n        if not filename:\n            timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')\n            filename = f\"metrics_{timestamp}.json\"\n\n        filepath = os.path.join(self.metrics_dir, filename)\n\n        with open(filepath, 'w') as f:\n            json.dump(self.current_metrics, f, indent=2, default=str)\n\n        return filepath\n</code></pre>"},{"location":"api/metrics/#state-management","title":"State Management","text":""},{"location":"api/metrics/#statemanager-class","title":"StateManager Class","text":"<pre><code>class StateManager:\n    \"\"\"\n    Manages Ralph execution state.\n\n    Example:\n        state = StateManager()\n        state.update(iteration=5, status='running')\n        state.save()\n    \"\"\"\n\n    def __init__(self, state_dir: str = '.agent/metrics'):\n        \"\"\"\n        Initialize state manager.\n\n        Args:\n            state_dir (str): Directory for state files\n        \"\"\"\n        self.state_dir = state_dir\n        self.state_file = os.path.join(state_dir, 'state_latest.json')\n        self.state = self.load() or self.initialize_state()\n\n    def initialize_state(self) -&gt; dict:\n        \"\"\"\n        Initialize empty state.\n\n        Returns:\n            dict: Initial state structure\n        \"\"\"\n        return {\n            'status': 'idle',\n            'iteration_count': 0,\n            'start_time': None,\n            'last_update': None,\n            'runtime': 0,\n            'agent': None,\n            'prompt_file': None,\n            'errors': [],\n            'checkpoints': [],\n            'task_complete': False\n        }\n\n    def load(self) -&gt; dict:\n        \"\"\"\n        Load state from file.\n\n        Returns:\n            dict: Loaded state or None\n\n        Example:\n            state = StateManager()\n            current = state.load()\n        \"\"\"\n        if os.path.exists(self.state_file):\n            try:\n                with open(self.state_file) as f:\n                    return json.load(f)\n            except json.JSONDecodeError:\n                return None\n        return None\n\n    def save(self):\n        \"\"\"\n        Save current state to file.\n\n        Example:\n            state.update(iteration=10)\n            state.save()\n        \"\"\"\n        os.makedirs(self.state_dir, exist_ok=True)\n\n        # Update last_update timestamp\n        self.state['last_update'] = time.time()\n\n        # Save to latest file\n        with open(self.state_file, 'w') as f:\n            json.dump(self.state, f, indent=2, default=str)\n\n        # Also save timestamped version\n        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')\n        archive_file = os.path.join(\n            self.state_dir, \n            f\"state_{timestamp}.json\"\n        )\n        with open(archive_file, 'w') as f:\n            json.dump(self.state, f, indent=2, default=str)\n\n    def update(self, **kwargs):\n        \"\"\"\n        Update state values.\n\n        Args:\n            **kwargs: State values to update\n\n        Example:\n            state.update(\n                iteration_count=5,\n                status='running',\n                agent='claude'\n            )\n        \"\"\"\n        self.state.update(kwargs)\n\n        # Calculate runtime if start_time exists\n        if self.state.get('start_time'):\n            self.state['runtime'] = time.time() - self.state['start_time']\n\n    def get(self, key: str, default=None):\n        \"\"\"\n        Get state value.\n\n        Args:\n            key (str): State key\n            default: Default value if key not found\n\n        Returns:\n            Value from state\n\n        Example:\n            iteration = state.get('iteration_count', 0)\n        \"\"\"\n        return self.state.get(key, default)\n\n    def reset(self):\n        \"\"\"\n        Reset state to initial values.\n\n        Example:\n            state.reset()\n        \"\"\"\n        self.state = self.initialize_state()\n        self.save()\n</code></pre>"},{"location":"api/metrics/#metrics-analysis","title":"Metrics Analysis","text":""},{"location":"api/metrics/#metricsanalyzer-class","title":"MetricsAnalyzer Class","text":"<pre><code>class MetricsAnalyzer:\n    \"\"\"\n    Analyze collected metrics.\n\n    Example:\n        analyzer = MetricsAnalyzer('.agent/metrics')\n        report = analyzer.generate_report()\n        print(report)\n    \"\"\"\n\n    def __init__(self, metrics_dir: str = '.agent/metrics'):\n        \"\"\"\n        Initialize metrics analyzer.\n\n        Args:\n            metrics_dir (str): Directory containing metrics files\n        \"\"\"\n        self.metrics_dir = metrics_dir\n        self.metrics_files = self.find_metrics_files()\n\n    def find_metrics_files(self) -&gt; List[str]:\n        \"\"\"\n        Find all metrics files.\n\n        Returns:\n            list: Paths to metrics files\n        \"\"\"\n        pattern = os.path.join(self.metrics_dir, 'metrics_*.json')\n        return sorted(glob.glob(pattern))\n\n    def load_metrics(self, filepath: str) -&gt; dict:\n        \"\"\"\n        Load metrics from file.\n\n        Args:\n            filepath (str): Path to metrics file\n\n        Returns:\n            dict: Loaded metrics\n        \"\"\"\n        with open(filepath) as f:\n            return json.load(f)\n\n    def analyze_iterations(self, metrics: dict) -&gt; dict:\n        \"\"\"\n        Analyze iteration performance.\n\n        Args:\n            metrics (dict): Metrics data\n\n        Returns:\n            dict: Iteration analysis\n\n        Example:\n            metrics = analyzer.load_metrics('metrics.json')\n            analysis = analyzer.analyze_iterations(metrics)\n        \"\"\"\n        iterations = metrics.get('iterations', [])\n\n        if not iterations:\n            return {}\n\n        durations = [i['duration'] for i in iterations if i.get('duration')]\n        success_count = sum(1 for i in iterations if i.get('success'))\n\n        return {\n            'total_iterations': len(iterations),\n            'successful_iterations': success_count,\n            'success_rate': success_count / len(iterations) if iterations else 0,\n            'avg_duration': sum(durations) / len(durations) if durations else 0,\n            'min_duration': min(durations) if durations else 0,\n            'max_duration': max(durations) if durations else 0,\n            'total_duration': sum(durations)\n        }\n\n    def analyze_errors(self, metrics: dict) -&gt; dict:\n        \"\"\"\n        Analyze errors.\n\n        Args:\n            metrics (dict): Metrics data\n\n        Returns:\n            dict: Error analysis\n        \"\"\"\n        errors = metrics.get('errors', [])\n\n        if not errors:\n            return {'total_errors': 0}\n\n        # Group errors by iteration\n        errors_by_iteration = {}\n        for error in errors:\n            iteration = error.get('iteration', 'unknown')\n            if iteration not in errors_by_iteration:\n                errors_by_iteration[iteration] = []\n            errors_by_iteration[iteration].append(error['message'])\n\n        return {\n            'total_errors': len(errors),\n            'errors_by_iteration': errors_by_iteration,\n            'unique_errors': len(set(e['message'] for e in errors))\n        }\n\n    def analyze_resource_usage(self, metrics: dict) -&gt; dict:\n        \"\"\"\n        Analyze resource usage.\n\n        Args:\n            metrics (dict): Metrics data\n\n        Returns:\n            dict: Resource usage analysis\n        \"\"\"\n        usage = metrics.get('resource_usage', [])\n\n        if not usage:\n            return {}\n\n        cpu_values = [u['cpu_percent'] for u in usage if 'cpu_percent' in u]\n        memory_values = [u['memory_mb'] for u in usage if 'memory_mb' in u]\n\n        return {\n            'avg_cpu_percent': sum(cpu_values) / len(cpu_values) if cpu_values else 0,\n            'max_cpu_percent': max(cpu_values) if cpu_values else 0,\n            'avg_memory_mb': sum(memory_values) / len(memory_values) if memory_values else 0,\n            'max_memory_mb': max(memory_values) if memory_values else 0\n        }\n\n    def generate_report(self) -&gt; str:\n        \"\"\"\n        Generate comprehensive metrics report.\n\n        Returns:\n            str: Formatted report\n\n        Example:\n            report = analyzer.generate_report()\n            print(report)\n        \"\"\"\n        if not self.metrics_files:\n            return \"No metrics files found\"\n\n        # Load latest metrics\n        latest_file = self.metrics_files[-1]\n        metrics = self.load_metrics(latest_file)\n\n        # Analyze different aspects\n        iteration_analysis = self.analyze_iterations(metrics)\n        error_analysis = self.analyze_errors(metrics)\n        resource_analysis = self.analyze_resource_usage(metrics)\n\n        # Format report\n        report = []\n        report.append(\"=\" * 50)\n        report.append(\"RALPH ORCHESTRATOR METRICS REPORT\")\n        report.append(\"=\" * 50)\n        report.append(f\"Metrics File: {os.path.basename(latest_file)}\")\n        report.append(\"\")\n\n        # Iteration statistics\n        report.append(\"ITERATION STATISTICS:\")\n        report.append(f\"  Total Iterations: {iteration_analysis.get('total_iterations', 0)}\")\n        report.append(f\"  Success Rate: {iteration_analysis.get('success_rate', 0):.1%}\")\n        report.append(f\"  Avg Duration: {iteration_analysis.get('avg_duration', 0):.2f}s\")\n        report.append(f\"  Total Runtime: {iteration_analysis.get('total_duration', 0):.2f}s\")\n        report.append(\"\")\n\n        # Error statistics\n        report.append(\"ERROR STATISTICS:\")\n        report.append(f\"  Total Errors: {error_analysis.get('total_errors', 0)}\")\n        report.append(f\"  Unique Errors: {error_analysis.get('unique_errors', 0)}\")\n        report.append(\"\")\n\n        # Resource usage\n        if resource_analysis:\n            report.append(\"RESOURCE USAGE:\")\n            report.append(f\"  Avg CPU: {resource_analysis.get('avg_cpu_percent', 0):.1f}%\")\n            report.append(f\"  Max CPU: {resource_analysis.get('max_cpu_percent', 0):.1f}%\")\n            report.append(f\"  Avg Memory: {resource_analysis.get('avg_memory_mb', 0):.1f} MB\")\n            report.append(f\"  Max Memory: {resource_analysis.get('max_memory_mb', 0):.1f} MB\")\n\n        return \"\\n\".join(report)\n</code></pre>"},{"location":"api/metrics/#metrics-export","title":"Metrics Export","text":""},{"location":"api/metrics/#export-functions","title":"Export Functions","text":"<pre><code>def export_to_csv(metrics: dict, output_file: str):\n    \"\"\"\n    Export metrics to CSV.\n\n    Args:\n        metrics (dict): Metrics data\n        output_file (str): Output CSV file path\n\n    Example:\n        metrics = load_metrics('metrics.json')\n        export_to_csv(metrics, 'metrics.csv')\n    \"\"\"\n    import csv\n\n    iterations = metrics.get('iterations', [])\n\n    with open(output_file, 'w', newline='') as f:\n        writer = csv.DictWriter(f, fieldnames=[\n            'number', 'start_time', 'end_time', \n            'duration', 'success', 'output_size'\n        ])\n        writer.writeheader()\n        writer.writerows(iterations)\n\ndef export_to_prometheus(metrics: dict, output_file: str):\n    \"\"\"\n    Export metrics in Prometheus format.\n\n    Args:\n        metrics (dict): Metrics data\n        output_file (str): Output file path\n\n    Example:\n        export_to_prometheus(metrics, 'metrics.prom')\n    \"\"\"\n    lines = []\n\n    # Iteration metrics\n    iterations = metrics.get('iterations', [])\n    if iterations:\n        total = len(iterations)\n        successful = sum(1 for i in iterations if i.get('success'))\n\n        lines.append(f'ralph_iterations_total {total}')\n        lines.append(f'ralph_iterations_successful {successful}')\n        lines.append(f'ralph_success_rate {successful/total if total else 0}')\n\n    # Error metrics\n    errors = metrics.get('errors', [])\n    lines.append(f'ralph_errors_total {len(errors)}')\n\n    # Write to file\n    with open(output_file, 'w') as f:\n        f.write('\\n'.join(lines))\n\ndef export_to_json_lines(metrics: dict, output_file: str):\n    \"\"\"\n    Export metrics as JSON lines for streaming.\n\n    Args:\n        metrics (dict): Metrics data\n        output_file (str): Output file path\n\n    Example:\n        export_to_json_lines(metrics, 'metrics.jsonl')\n    \"\"\"\n    with open(output_file, 'w') as f:\n        for iteration in metrics.get('iterations', []):\n            f.write(json.dumps(iteration) + '\\n')\n</code></pre>"},{"location":"api/metrics/#real-time-metrics","title":"Real-time Metrics","text":"<pre><code>class RealtimeMetrics:\n    \"\"\"\n    Provide real-time metrics access.\n\n    Example:\n        realtime = RealtimeMetrics()\n        realtime.start_monitoring()\n        # ... execution ...\n        stats = realtime.get_current_stats()\n    \"\"\"\n\n    def __init__(self):\n        self.current_stats = {}\n        self.monitoring = False\n\n    def start_monitoring(self):\n        \"\"\"Start real-time monitoring.\"\"\"\n        self.monitoring = True\n        self.monitor_thread = threading.Thread(target=self._monitor_loop)\n        self.monitor_thread.daemon = True\n        self.monitor_thread.start()\n\n    def _monitor_loop(self):\n        \"\"\"Background monitoring loop.\"\"\"\n        while self.monitoring:\n            self.current_stats = {\n                'timestamp': time.time(),\n                'cpu_percent': psutil.cpu_percent(interval=1),\n                'memory_percent': psutil.virtual_memory().percent,\n                'disk_usage': psutil.disk_usage('.').percent\n            }\n            time.sleep(5)\n\n    def get_current_stats(self) -&gt; dict:\n        \"\"\"Get current statistics.\"\"\"\n        return self.current_stats.copy()\n\n    def stop_monitoring(self):\n        \"\"\"Stop monitoring.\"\"\"\n        self.monitoring = False\n        if hasattr(self, 'monitor_thread'):\n            self.monitor_thread.join(timeout=1)\n</code></pre>"},{"location":"api/orchestrator/","title":"Orchestrator API Reference","text":"<p>Complete API documentation for the Ralph Orchestrator core module.</p>"},{"location":"api/orchestrator/#module-ralph_orchestrator","title":"Module: <code>ralph_orchestrator</code>","text":"<p>The main orchestration module that coordinates AI agent execution.</p>"},{"location":"api/orchestrator/#classes","title":"Classes","text":""},{"location":"api/orchestrator/#ralphorchestrator","title":"<code>RalphOrchestrator</code>","text":"<p>Main orchestrator class managing the execution loop.</p> <pre><code>class RalphOrchestrator:\n    def __init__(self, config: RalphConfig):\n        \"\"\"Initialize the orchestrator with configuration.\"\"\"\n</code></pre>"},{"location":"api/orchestrator/#methods","title":"Methods","text":""},{"location":"api/orchestrator/#run","title":"<code>run()</code>","text":"<pre><code>def run(self) -&gt; Dict[str, Any]:\n    \"\"\"\n    Run the orchestration loop until completion or limits reached.\n\n    Returns:\n        Dict containing final metrics and status\n    \"\"\"\n</code></pre>"},{"location":"api/orchestrator/#ralphconfig","title":"<code>RalphConfig</code>","text":"<p>Configuration dataclass for the orchestrator.</p> <pre><code>@dataclass\nclass RalphConfig:\n    agent: AgentType = AgentType.AUTO\n    prompt_file: str = \"PROMPT.md\"\n    max_iterations: int = 100\n    max_runtime: int = 14400\n    # ... additional fields\n</code></pre>"},{"location":"api/orchestrator/#agenttype","title":"<code>AgentType</code>","text":"<pre><code>class AgentType(Enum):\n    CLAUDE = \"claude\"\n    Q = \"q\"\n    GEMINI = \"gemini\"\n    AUTO = \"auto\"\n</code></pre>"},{"location":"api/orchestrator/#functions","title":"Functions","text":""},{"location":"api/orchestrator/#main","title":"<code>main()</code>","text":"<p>Entry point for CLI execution.</p> <pre><code>def main() -&gt; int:\n    \"\"\"Main entry point for CLI execution.\"\"\"\n</code></pre>"},{"location":"api/orchestrator/#detect_agent","title":"<code>detect_agent()</code>","text":"<pre><code>def detect_agent() -&gt; Optional[AgentType]:\n    \"\"\"Detect available AI agent.\"\"\"\n</code></pre>"},{"location":"api/orchestrator/#usage-examples","title":"Usage Examples","text":"<pre><code>from ralph_orchestrator import RalphOrchestrator, RalphConfig\n\nconfig = RalphConfig(agent=AgentType.CLAUDE)\norchestrator = RalphOrchestrator(config)\nresult = orchestrator.run()\n</code></pre> <p>The main orchestration module that implements the Ralph Wiggum technique.</p>"},{"location":"api/orchestrator/#classes_1","title":"Classes","text":""},{"location":"api/orchestrator/#ralphorchestrator_1","title":"<code>RalphOrchestrator</code>","text":"<p>The main orchestrator class that manages the iteration loop.</p> <pre><code>class RalphOrchestrator:\n    \"\"\"\n    Orchestrates AI agent iterations for autonomous task completion.\n\n    Attributes:\n        config (RalphConfig): Configuration object\n        agent (Agent): Active AI agent instance\n        metrics (MetricsCollector): Metrics tracking\n        state (OrchestratorState): Current state\n    \"\"\"\n</code></pre>"},{"location":"api/orchestrator/#constructor","title":"Constructor","text":"<pre><code>def __init__(self, config: RalphConfig) -&gt; None:\n    \"\"\"\n    Initialize the orchestrator with configuration.\n\n    Args:\n        config: RalphConfig object with settings\n\n    Raises:\n        ValueError: If configuration is invalid\n        RuntimeError: If no agents are available\n    \"\"\"\n</code></pre>"},{"location":"api/orchestrator/#methods_1","title":"Methods","text":""},{"location":"api/orchestrator/#run_1","title":"<code>run()</code>","text":"<pre><code>def run(self) -&gt; int:\n    \"\"\"\n    Execute the main orchestration loop.\n\n    Returns:\n        int: Exit code (0 for success, non-zero for failure)\n\n    Raises:\n        SecurityError: If security validation fails\n        RuntimeError: If unrecoverable error occurs\n    \"\"\"\n</code></pre>"},{"location":"api/orchestrator/#iterate","title":"<code>iterate()</code>","text":"<pre><code>def iterate(self) -&gt; bool:\n    \"\"\"\n    Execute a single iteration.\n\n    Returns:\n        bool: True if task is complete, False otherwise\n\n    Raises:\n        AgentError: If agent execution fails\n        TokenLimitError: If token limit exceeded\n        CostLimitError: If cost limit exceeded\n    \"\"\"\n</code></pre>"},{"location":"api/orchestrator/#checkpoint","title":"<code>checkpoint()</code>","text":"<pre><code>def checkpoint(self) -&gt; None:\n    \"\"\"\n    Create a Git checkpoint of current state.\n\n    Raises:\n        GitError: If Git operations fail\n    \"\"\"\n</code></pre>"},{"location":"api/orchestrator/#save_state","title":"<code>save_state()</code>","text":"<pre><code>def save_state(self) -&gt; None:\n    \"\"\"\n    Persist current state to disk.\n\n    The state includes:\n    - Current iteration number\n    - Token usage\n    - Cost accumulation\n    - Timestamps\n    - Agent information\n    \"\"\"\n</code></pre>"},{"location":"api/orchestrator/#load_state","title":"<code>load_state()</code>","text":"<pre><code>def load_state(self) -&gt; Optional[OrchestratorState]:\n    \"\"\"\n    Load previous state from disk.\n\n    Returns:\n        OrchestratorState or None if no state exists\n    \"\"\"\n</code></pre>"},{"location":"api/orchestrator/#ralphconfig_1","title":"<code>RalphConfig</code>","text":"<p>Configuration dataclass for the orchestrator.</p> <pre><code>@dataclass\nclass RalphConfig:\n    \"\"\"\n    Configuration for Ralph orchestrator.\n\n    All parameters can be set via:\n    - Command-line arguments\n    - Environment variables (RALPH_*)\n    - Configuration file (.ralph.conf)\n    - Default values\n    \"\"\"\n\n    # Agent configuration\n    agent: AgentType = AgentType.AUTO\n    agent_args: List[str] = field(default_factory=list)\n\n    # File paths\n    prompt_file: str = \"PROMPT.md\"\n\n    # Iteration limits\n    max_iterations: int = 100\n    max_runtime: int = 14400  # 4 hours\n\n    # Token and cost limits\n    max_tokens: int = 1000000  # 1M tokens\n    max_cost: float = 50.0  # $50 USD\n\n    # Context management\n    context_window: int = 200000  # 200K tokens\n    context_threshold: float = 0.8  # 80% trigger\n\n    # Checkpointing\n    checkpoint_interval: int = 5\n    git_checkpoint: bool = True\n    archive_prompts: bool = True\n\n    # Retry configuration\n    retry_delay: int = 2\n    max_retries: int = 3\n\n    # Monitoring\n    metrics_interval: int = 10\n    enable_metrics: bool = True\n\n    # Security\n    max_prompt_size: int = 10485760  # 10MB\n    allow_unsafe_paths: bool = False\n\n    # Output\n    verbose: bool = False\n    dry_run: bool = False\n</code></pre>"},{"location":"api/orchestrator/#orchestratorstate","title":"<code>OrchestratorState</code>","text":"<p>State tracking for the orchestrator.</p> <pre><code>@dataclass\nclass OrchestratorState:\n    \"\"\"\n    Orchestrator state for persistence and recovery.\n    \"\"\"\n\n    # Iteration tracking\n    current_iteration: int = 0\n    total_iterations: int = 0\n\n    # Time tracking\n    start_time: datetime = field(default_factory=datetime.now)\n    last_iteration_time: Optional[datetime] = None\n    total_runtime: float = 0.0\n\n    # Token tracking\n    total_input_tokens: int = 0\n    total_output_tokens: int = 0\n\n    # Cost tracking\n    total_cost: float = 0.0\n\n    # Agent information\n    agent_type: str = \"\"\n    agent_version: Optional[str] = None\n\n    # Completion status\n    is_complete: bool = False\n    completion_reason: Optional[str] = None\n</code></pre>"},{"location":"api/orchestrator/#functions_1","title":"Functions","text":""},{"location":"api/orchestrator/#detect_agents","title":"<code>detect_agents()</code>","text":"<pre><code>def detect_agents() -&gt; List[AgentType]:\n    \"\"\"\n    Detect available AI agents on the system.\n\n    Returns:\n        List of available AgentType enums\n\n    Example:\n        &gt;&gt;&gt; detect_agents()\n        [AgentType.CLAUDE, AgentType.GEMINI]\n    \"\"\"\n</code></pre>"},{"location":"api/orchestrator/#validate_prompt_file","title":"<code>validate_prompt_file()</code>","text":"<pre><code>def validate_prompt_file(\n    file_path: str, \n    max_size: int = DEFAULT_MAX_PROMPT_SIZE\n) -&gt; None:\n    \"\"\"\n    Validate prompt file for security and size.\n\n    Args:\n        file_path: Path to prompt file\n        max_size: Maximum allowed file size in bytes\n\n    Raises:\n        FileNotFoundError: If file doesn't exist\n        SecurityError: If file contains dangerous patterns\n        ValueError: If file exceeds size limit\n    \"\"\"\n</code></pre>"},{"location":"api/orchestrator/#sanitize_input","title":"<code>sanitize_input()</code>","text":"<pre><code>def sanitize_input(text: str) -&gt; str:\n    \"\"\"\n    Sanitize input text for security.\n\n    Args:\n        text: Input text to sanitize\n\n    Returns:\n        Sanitized text safe for processing\n\n    Example:\n        &gt;&gt;&gt; sanitize_input(\"rm -rf /; echo 'done'\")\n        \"rm -rf _; echo 'done'\"\n    \"\"\"\n</code></pre>"},{"location":"api/orchestrator/#calculate_cost","title":"<code>calculate_cost()</code>","text":"<pre><code>def calculate_cost(\n    input_tokens: int,\n    output_tokens: int,\n    agent_type: AgentType\n) -&gt; float:\n    \"\"\"\n    Calculate cost based on token usage.\n\n    Args:\n        input_tokens: Number of input tokens\n        output_tokens: Number of output tokens\n        agent_type: Type of agent used\n\n    Returns:\n        Cost in USD\n\n    Example:\n        &gt;&gt;&gt; calculate_cost(1000, 500, AgentType.CLAUDE)\n        0.0105  # $0.0105\n    \"\"\"\n</code></pre>"},{"location":"api/orchestrator/#exceptions","title":"Exceptions","text":""},{"location":"api/orchestrator/#orchestratorerror","title":"<code>OrchestratorError</code>","text":"<p>Base exception for orchestrator errors.</p> <pre><code>class OrchestratorError(Exception):\n    \"\"\"Base exception for orchestrator errors.\"\"\"\n    pass\n</code></pre>"},{"location":"api/orchestrator/#securityerror","title":"<code>SecurityError</code>","text":"<pre><code>class SecurityError(OrchestratorError):\n    \"\"\"Raised when security validation fails.\"\"\"\n    pass\n</code></pre>"},{"location":"api/orchestrator/#tokenlimiterror","title":"<code>TokenLimitError</code>","text":"<pre><code>class TokenLimitError(OrchestratorError):\n    \"\"\"Raised when token limit is exceeded.\"\"\"\n    pass\n</code></pre>"},{"location":"api/orchestrator/#costlimiterror","title":"<code>CostLimitError</code>","text":"<pre><code>class CostLimitError(OrchestratorError):\n    \"\"\"Raised when cost limit is exceeded.\"\"\"\n    pass\n</code></pre>"},{"location":"api/orchestrator/#agenterror","title":"<code>AgentError</code>","text":"<pre><code>class AgentError(OrchestratorError):\n    \"\"\"Raised when agent execution fails.\"\"\"\n    pass\n</code></pre>"},{"location":"api/orchestrator/#constants","title":"Constants","text":"<pre><code># Version\nVERSION = \"1.0.0\"\n\n# Default values\nDEFAULT_MAX_ITERATIONS = 100\nDEFAULT_MAX_RUNTIME = 14400  # 4 hours\nDEFAULT_PROMPT_FILE = \"PROMPT.md\"\nDEFAULT_CHECKPOINT_INTERVAL = 5\nDEFAULT_RETRY_DELAY = 2\nDEFAULT_MAX_TOKENS = 1000000  # 1M tokens\nDEFAULT_MAX_COST = 50.0  # $50 USD\nDEFAULT_CONTEXT_WINDOW = 200000  # 200K tokens\nDEFAULT_CONTEXT_THRESHOLD = 0.8  # 80%\nDEFAULT_METRICS_INTERVAL = 10\nDEFAULT_MAX_PROMPT_SIZE = 10485760  # 10MB\n\n# Token costs per million\nTOKEN_COSTS = {\n    \"claude\": {\"input\": 3.0, \"output\": 15.0},\n    \"q\": {\"input\": 0.5, \"output\": 1.5},\n    \"gemini\": {\"input\": 0.5, \"output\": 1.5}\n}\n\n# Completion markers\nCOMPLETION_MARKERS = [\"TASK_COMPLETE\", \"TASK_DONE\", \"COMPLETE\"]\n\n# Security patterns\nDANGEROUS_PATTERNS = [\n    r\"rm\\s+-rf\\s+/\",\n    r\":(){ :|:&amp; };:\",\n    r\"dd\\s+if=/dev/zero\",\n    r\"mkfs\\.\",\n    r\"format\\s+[cC]:\",\n]\n</code></pre>"},{"location":"api/orchestrator/#usage-examples_1","title":"Usage Examples","text":""},{"location":"api/orchestrator/#basic-usage","title":"Basic Usage","text":"<pre><code>from ralph_orchestrator import RalphOrchestrator, RalphConfig\n\n# Create configuration\nconfig = RalphConfig(\n    agent=AgentType.CLAUDE,\n    prompt_file=\"task.md\",\n    max_iterations=50,\n    max_cost=25.0\n)\n\n# Initialize orchestrator\norchestrator = RalphOrchestrator(config)\n\n# Run orchestration\nexit_code = orchestrator.run()\n</code></pre>"},{"location":"api/orchestrator/#custom-configuration","title":"Custom Configuration","text":"<pre><code># Load from environment and add overrides\nconfig = RalphConfig()\nconfig.max_iterations = 100\nconfig.checkpoint_interval = 10\nconfig.verbose = True\n\n# Initialize with custom config\norchestrator = RalphOrchestrator(config)\n</code></pre>"},{"location":"api/orchestrator/#state-management","title":"State Management","text":"<pre><code># Save state manually\norchestrator.save_state()\n\n# Load previous state\nstate = orchestrator.load_state()\nif state:\n    print(f\"Resuming from iteration {state.current_iteration}\")\n</code></pre>"},{"location":"api/orchestrator/#error-handling","title":"Error Handling","text":"<pre><code>try:\n    orchestrator = RalphOrchestrator(config)\n    exit_code = orchestrator.run()\nexcept SecurityError as e:\n    print(f\"Security violation: {e}\")\nexcept TokenLimitError as e:\n    print(f\"Token limit exceeded: {e}\")\nexcept CostLimitError as e:\n    print(f\"Cost limit exceeded: {e}\")\nexcept Exception as e:\n    print(f\"Unexpected error: {e}\")\n</code></pre>"},{"location":"api/orchestrator/#thread-safety","title":"Thread Safety","text":"<p>The orchestrator is not thread-safe. If you need concurrent execution:</p> <ol> <li>Create separate orchestrator instances</li> <li>Use different working directories</li> <li>Implement external synchronization</li> </ol>"},{"location":"api/orchestrator/#performance-considerations","title":"Performance Considerations","text":"<ul> <li>Memory usage: ~50MB base + agent overhead</li> <li>Disk I/O: Checkpoints create Git commits</li> <li>Network: Agent API calls may have latency</li> <li>CPU: Minimal overhead (&lt;1% between iterations)</li> </ul>"},{"location":"api/orchestrator/#see-also","title":"See Also","text":"<ul> <li>Configuration API</li> <li>Agent API</li> <li>Metrics API</li> <li>CLI Reference</li> </ul> <p>\ud83d\udcda Continue to Configuration API \u2192</p>"},{"location":"deployment/ci-cd/","title":"CI/CD Pipeline Guide","text":"<p>Automate Ralph Orchestrator deployment with continuous integration and delivery pipelines.</p>"},{"location":"deployment/ci-cd/#overview","title":"Overview","text":"<p>This guide covers setting up automated pipelines for: - Code testing and validation - Docker image building and pushing - Documentation deployment - Automated releases - Multi-environment deployments</p>"},{"location":"deployment/ci-cd/#github-actions","title":"GitHub Actions","text":""},{"location":"deployment/ci-cd/#complete-cicd-workflow","title":"Complete CI/CD Workflow","text":"<p>Create <code>.github/workflows/ci-cd.yml</code>:</p> <pre><code>name: CI/CD Pipeline\n\non:\n  push:\n    branches: [ main, develop ]\n    tags: [ 'v*' ]\n  pull_request:\n    branches: [ main ]\n  workflow_dispatch:\n\nenv:\n  REGISTRY: ghcr.io\n  IMAGE_NAME: ${{ github.repository }}\n\njobs:\n  # Test Job\n  test:\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        python-version: ['3.9', '3.10', '3.11']\n\n    steps:\n    - uses: actions/checkout@v4\n\n    - name: Set up Python\n      uses: actions/setup-python@v4\n      with:\n        python-version: ${{ matrix.python-version }}\n\n    - name: Install uv\n      run: |\n        curl -LsSf https://astral.sh/uv/install.sh | sh\n        echo \"$HOME/.cargo/bin\" &gt;&gt; $GITHUB_PATH\n\n    - name: Install dependencies\n      run: |\n        uv venv\n        uv pip install -e .\n        uv pip install pytest pytest-cov pytest-asyncio\n\n    - name: Run tests\n      run: |\n        source .venv/bin/activate\n        pytest tests/ -v --cov=ralph_orchestrator --cov-report=xml\n\n    - name: Upload coverage\n      uses: codecov/codecov-action@v3\n      with:\n        file: ./coverage.xml\n        fail_ci_if_error: true\n\n  # Lint and Security Check\n  quality:\n    runs-on: ubuntu-latest\n\n    steps:\n    - uses: actions/checkout@v4\n\n    - name: Set up Python\n      uses: actions/setup-python@v4\n      with:\n        python-version: '3.11'\n\n    - name: Install tools\n      run: |\n        pip install ruff black mypy bandit safety\n\n    - name: Run ruff\n      run: ruff check .\n\n    - name: Check formatting\n      run: black --check .\n\n    - name: Type checking\n      run: mypy ralph_orchestrator.py\n\n    - name: Security scan\n      run: |\n        bandit -r . -ll\n        safety check\n\n  # Build Docker Image\n  build:\n    needs: [test, quality]\n    runs-on: ubuntu-latest\n    permissions:\n      contents: read\n      packages: write\n\n    steps:\n    - uses: actions/checkout@v4\n\n    - name: Set up Docker Buildx\n      uses: docker/setup-buildx-action@v3\n\n    - name: Log in to Container Registry\n      uses: docker/login-action@v3\n      with:\n        registry: ${{ env.REGISTRY }}\n        username: ${{ github.actor }}\n        password: ${{ secrets.GITHUB_TOKEN }}\n\n    - name: Extract metadata\n      id: meta\n      uses: docker/metadata-action@v5\n      with:\n        images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}\n        tags: |\n          type=ref,event=branch\n          type=ref,event=pr\n          type=semver,pattern={{version}}\n          type=semver,pattern={{major}}.{{minor}}\n          type=sha,prefix={{branch}}-\n\n    - name: Build and push Docker image\n      uses: docker/build-push-action@v5\n      with:\n        context: .\n        push: true\n        tags: ${{ steps.meta.outputs.tags }}\n        labels: ${{ steps.meta.outputs.labels }}\n        cache-from: type=gha\n        cache-to: type=gha,mode=max\n        platforms: linux/amd64,linux/arm64\n\n  # Deploy Documentation\n  docs:\n    if: github.ref == 'refs/heads/main'\n    runs-on: ubuntu-latest\n\n    steps:\n    - uses: actions/checkout@v4\n\n    - name: Set up Python\n      uses: actions/setup-python@v4\n      with:\n        python-version: '3.11'\n\n    - name: Install MkDocs\n      run: |\n        pip install mkdocs mkdocs-material pymdown-extensions\n\n    - name: Build documentation\n      run: mkdocs build\n\n    - name: Deploy to GitHub Pages\n      uses: peaceiris/actions-gh-pages@v3\n      if: github.ref == 'refs/heads/main'\n      with:\n        github_token: ${{ secrets.GITHUB_TOKEN }}\n        publish_dir: ./site\n\n  # Deploy to Staging\n  deploy-staging:\n    needs: build\n    if: github.ref == 'refs/heads/develop'\n    runs-on: ubuntu-latest\n    environment: staging\n\n    steps:\n    - uses: actions/checkout@v4\n\n    - name: Deploy to Kubernetes (Staging)\n      env:\n        KUBE_CONFIG: ${{ secrets.STAGING_KUBE_CONFIG }}\n      run: |\n        echo \"$KUBE_CONFIG\" | base64 -d &gt; kubeconfig\n        export KUBECONFIG=kubeconfig\n        kubectl set image deployment/ralph-orchestrator \\\n          ralph=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:develop \\\n          -n ralph-staging\n        kubectl rollout status deployment/ralph-orchestrator -n ralph-staging\n\n  # Deploy to Production\n  deploy-production:\n    needs: build\n    if: startsWith(github.ref, 'refs/tags/v')\n    runs-on: ubuntu-latest\n    environment: production\n\n    steps:\n    - uses: actions/checkout@v4\n\n    - name: Deploy to Kubernetes (Production)\n      env:\n        KUBE_CONFIG: ${{ secrets.PROD_KUBE_CONFIG }}\n      run: |\n        echo \"$KUBE_CONFIG\" | base64 -d &gt; kubeconfig\n        export KUBECONFIG=kubeconfig\n        VERSION=${GITHUB_REF#refs/tags/}\n        kubectl set image deployment/ralph-orchestrator \\\n          ralph=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:$VERSION \\\n          -n ralph-production\n        kubectl rollout status deployment/ralph-orchestrator -n ralph-production\n\n    - name: Create Release\n      uses: softprops/action-gh-release@v1\n      with:\n        generate_release_notes: true\n        files: |\n          dist/*.whl\n          dist/*.tar.gz\n</code></pre>"},{"location":"deployment/ci-cd/#documentation-workflow","title":"Documentation Workflow","text":"<p>Create <code>.github/workflows/docs.yml</code>:</p> <pre><code>name: Deploy Documentation\n\non:\n  push:\n    branches: [ main ]\n    paths:\n      - 'docs/**'\n      - 'mkdocs.yml'\n  workflow_dispatch:\n\njobs:\n  deploy:\n    runs-on: ubuntu-latest\n\n    steps:\n    - uses: actions/checkout@v4\n      with:\n        fetch-depth: 0  # Full history for git info\n\n    - name: Configure Git\n      run: |\n        git config user.name github-actions\n        git config user.email github-actions@github.com\n\n    - uses: actions/setup-python@v4\n      with:\n        python-version: '3.11'\n\n    - name: Install dependencies\n      run: |\n        pip install mkdocs-material mkdocs-git-revision-date-localized-plugin\n        pip install mkdocs-minify-plugin mkdocs-redirects\n\n    - name: Build and Deploy\n      run: |\n        mkdocs gh-deploy --force --clean --verbose\n</code></pre>"},{"location":"deployment/ci-cd/#release-workflow","title":"Release Workflow","text":"<p>Create <code>.github/workflows/release.yml</code>:</p> <pre><code>name: Release\n\non:\n  push:\n    tags:\n      - 'v*'\n\njobs:\n  release:\n    runs-on: ubuntu-latest\n\n    steps:\n    - uses: actions/checkout@v4\n\n    - name: Set up Python\n      uses: actions/setup-python@v4\n      with:\n        python-version: '3.11'\n\n    - name: Build distribution\n      run: |\n        pip install build\n        python -m build\n\n    - name: Publish to PyPI\n      uses: pypa/gh-action-pypi-publish@release/v1\n      with:\n        password: ${{ secrets.PYPI_API_TOKEN }}\n\n    - name: Create GitHub Release\n      uses: softprops/action-gh-release@v1\n      with:\n        files: dist/*\n        generate_release_notes: true\n        body: |\n          ## Docker Image\n          \\`\\`\\`bash\n          docker pull ghcr.io/${{ github.repository }}:${{ github.ref_name }}\n          \\`\\`\\`\n\n          ## Changelog\n          See [CHANGELOG.md](CHANGELOG.md) for details.\n</code></pre>"},{"location":"deployment/ci-cd/#gitlab-cicd","title":"GitLab CI/CD","text":"<p>Create <code>.gitlab-ci.yml</code>:</p> <pre><code>stages:\n  - test\n  - build\n  - deploy\n\nvariables:\n  DOCKER_DRIVER: overlay2\n  DOCKER_TLS_CERTDIR: \"\"\n  IMAGE_TAG: $CI_REGISTRY_IMAGE:$CI_COMMIT_SHORT_SHA\n\n# Test Stage\ntest:unit:\n  stage: test\n  image: python:3.11\n  script:\n    - pip install uv\n    - uv venv &amp;&amp; source .venv/bin/activate\n    - uv pip install -e . pytest pytest-cov\n    - pytest tests/ --cov=ralph_orchestrator\n  coverage: '/TOTAL.*\\s+(\\d+%)$/'\n  artifacts:\n    reports:\n      coverage_report:\n        coverage_format: cobertura\n        path: coverage.xml\n\ntest:lint:\n  stage: test\n  image: python:3.11\n  script:\n    - pip install ruff black\n    - ruff check .\n    - black --check .\n\n# Build Stage\nbuild:docker:\n  stage: build\n  image: docker:latest\n  services:\n    - docker:dind\n  before_script:\n    - docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY\n  script:\n    - docker build -t $IMAGE_TAG .\n    - docker push $IMAGE_TAG\n    - |\n      if [ \"$CI_COMMIT_BRANCH\" == \"main\" ]; then\n        docker tag $IMAGE_TAG $CI_REGISTRY_IMAGE:latest\n        docker push $CI_REGISTRY_IMAGE:latest\n      fi\n\n# Deploy Stage\ndeploy:staging:\n  stage: deploy\n  image: bitnami/kubectl:latest\n  environment:\n    name: staging\n    url: https://staging.ralph.example.com\n  only:\n    - develop\n  script:\n    - kubectl set image deployment/ralph ralph=$IMAGE_TAG -n staging\n    - kubectl rollout status deployment/ralph -n staging\n\ndeploy:production:\n  stage: deploy\n  image: bitnami/kubectl:latest\n  environment:\n    name: production\n    url: https://ralph.example.com\n  only:\n    - tags\n  when: manual\n  script:\n    - kubectl set image deployment/ralph ralph=$CI_REGISTRY_IMAGE:$CI_COMMIT_TAG -n production\n    - kubectl rollout status deployment/ralph -n production\n</code></pre>"},{"location":"deployment/ci-cd/#jenkins-pipeline","title":"Jenkins Pipeline","text":"<p>Create <code>Jenkinsfile</code>:</p> <pre><code>pipeline {\n    agent any\n\n    environment {\n        DOCKER_REGISTRY = 'docker.io'\n        DOCKER_IMAGE = 'mikeyobrien/ralph-orchestrator'\n        DOCKER_CREDENTIALS = 'docker-hub-credentials'\n        KUBECONFIG_STAGING = credentials('kubeconfig-staging')\n        KUBECONFIG_PROD = credentials('kubeconfig-production')\n    }\n\n    stages {\n        stage('Checkout') {\n            steps {\n                checkout scm\n            }\n        }\n\n        stage('Test') {\n            parallel {\n                stage('Unit Tests') {\n                    steps {\n                        sh '''\n                            python -m venv venv\n                            . venv/bin/activate\n                            pip install -e . pytest pytest-cov\n                            pytest tests/ --junitxml=test-results.xml\n                        '''\n                        junit 'test-results.xml'\n                    }\n                }\n\n                stage('Lint') {\n                    steps {\n                        sh '''\n                            pip install ruff\n                            ruff check .\n                        '''\n                    }\n                }\n\n                stage('Security Scan') {\n                    steps {\n                        sh '''\n                            pip install bandit safety\n                            bandit -r . -f json -o bandit-report.json\n                            safety check --json\n                        '''\n                    }\n                }\n            }\n        }\n\n        stage('Build Docker Image') {\n            steps {\n                script {\n                    docker.withRegistry(\"https://${DOCKER_REGISTRY}\", DOCKER_CREDENTIALS) {\n                        def image = docker.build(\"${DOCKER_IMAGE}:${env.BUILD_NUMBER}\")\n                        image.push()\n                        if (env.BRANCH_NAME == 'main') {\n                            image.push('latest')\n                        }\n                    }\n                }\n            }\n        }\n\n        stage('Deploy to Staging') {\n            when {\n                branch 'develop'\n            }\n            steps {\n                sh '''\n                    export KUBECONFIG=${KUBECONFIG_STAGING}\n                    kubectl set image deployment/ralph ralph=${DOCKER_IMAGE}:${BUILD_NUMBER} -n staging\n                    kubectl rollout status deployment/ralph -n staging\n                '''\n            }\n        }\n\n        stage('Deploy to Production') {\n            when {\n                tag pattern: \"v\\\\d+\\\\.\\\\d+\\\\.\\\\d+\", comparator: \"REGEXP\"\n            }\n            input {\n                message \"Deploy to production?\"\n                ok \"Deploy\"\n            }\n            steps {\n                sh '''\n                    export KUBECONFIG=${KUBECONFIG_PROD}\n                    kubectl set image deployment/ralph ralph=${DOCKER_IMAGE}:${TAG_NAME} -n production\n                    kubectl rollout status deployment/ralph -n production\n                '''\n            }\n        }\n    }\n\n    post {\n        always {\n            cleanWs()\n        }\n        success {\n            slackSend(\n                color: 'good',\n                message: \"Build Successful: ${env.JOB_NAME} - ${env.BUILD_NUMBER}\"\n            )\n        }\n        failure {\n            slackSend(\n                color: 'danger',\n                message: \"Build Failed: ${env.JOB_NAME} - ${env.BUILD_NUMBER}\"\n            )\n        }\n    }\n}\n</code></pre>"},{"location":"deployment/ci-cd/#circleci-configuration","title":"CircleCI Configuration","text":"<p>Create <code>.circleci/config.yml</code>:</p> <pre><code>version: 2.1\n\norbs:\n  python: circleci/python@2.1.1\n  docker: circleci/docker@2.2.0\n  kubernetes: circleci/kubernetes@1.3.1\n\njobs:\n  test:\n    docker:\n      - image: cimg/python:3.11\n    steps:\n      - checkout\n      - python/install-packages:\n          pkg-manager: pip\n      - run:\n          name: Run tests\n          command: |\n            pip install pytest pytest-cov\n            pytest tests/ --cov=ralph_orchestrator\n      - store_test_results:\n          path: test-results\n      - store_artifacts:\n          path: coverage\n\n  build-and-push:\n    executor: docker/docker\n    steps:\n      - setup_remote_docker\n      - checkout\n      - docker/check\n      - docker/build:\n          image: mikeyobrien/ralph-orchestrator\n          tag: ${CIRCLE_SHA1}\n      - docker/push:\n          image: mikeyobrien/ralph-orchestrator\n          tag: ${CIRCLE_SHA1}\n\n  deploy:\n    docker:\n      - image: cimg/base:stable\n    steps:\n      - kubernetes/install-kubectl\n      - run:\n          name: Deploy to Kubernetes\n          command: |\n            echo $KUBE_CONFIG | base64 -d &gt; kubeconfig\n            export KUBECONFIG=kubeconfig\n            kubectl set image deployment/ralph ralph=mikeyobrien/ralph-orchestrator:${CIRCLE_SHA1}\n            kubectl rollout status deployment/ralph\n\nworkflows:\n  main:\n    jobs:\n      - test\n      - build-and-push:\n          requires:\n            - test\n          filters:\n            branches:\n              only: main\n      - deploy:\n          requires:\n            - build-and-push\n          filters:\n            branches:\n              only: main\n</code></pre>"},{"location":"deployment/ci-cd/#azure-devops-pipeline","title":"Azure DevOps Pipeline","text":"<p>Create <code>azure-pipelines.yml</code>:</p> <pre><code>trigger:\n  branches:\n    include:\n    - main\n    - develop\n  tags:\n    include:\n    - v*\n\npool:\n  vmImage: 'ubuntu-latest'\n\nvariables:\n  dockerRegistry: 'your-registry.azurecr.io'\n  dockerImageName: 'ralph-orchestrator'\n  kubernetesServiceConnection: 'k8s-connection'\n\nstages:\n- stage: Test\n  jobs:\n  - job: TestJob\n    steps:\n    - task: UsePythonVersion@0\n      inputs:\n        versionSpec: '3.11'\n\n    - script: |\n        pip install uv\n        uv venv &amp;&amp; source .venv/bin/activate\n        uv pip install -e . pytest pytest-cov\n        pytest tests/ --junitxml=test-results.xml\n      displayName: 'Run tests'\n\n    - task: PublishTestResults@2\n      inputs:\n        testResultsFiles: 'test-results.xml'\n        testRunTitle: 'Python Tests'\n\n- stage: Build\n  dependsOn: Test\n  jobs:\n  - job: BuildJob\n    steps:\n    - task: Docker@2\n      inputs:\n        containerRegistry: $(dockerRegistry)\n        repository: $(dockerImageName)\n        command: buildAndPush\n        Dockerfile: Dockerfile\n        tags: |\n          $(Build.BuildId)\n          latest\n\n- stage: Deploy\n  dependsOn: Build\n  condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/main'))\n  jobs:\n  - deployment: DeployJob\n    environment: 'production'\n    strategy:\n      runOnce:\n        deploy:\n          steps:\n          - task: Kubernetes@1\n            inputs:\n              connectionType: 'Kubernetes Service Connection'\n              kubernetesServiceEndpoint: $(kubernetesServiceConnection)\n              command: 'set'\n              arguments: 'image deployment/ralph ralph=$(dockerRegistry)/$(dockerImageName):$(Build.BuildId)'\n              namespace: 'production'\n</code></pre>"},{"location":"deployment/ci-cd/#argocd-gitops","title":"ArgoCD GitOps","text":"<p>Create <code>argocd/application.yaml</code>:</p> <pre><code>apiVersion: argoproj.io/v1alpha1\nkind: Application\nmetadata:\n  name: ralph-orchestrator\n  namespace: argocd\n  finalizers:\n    - resources-finalizer.argocd.argoproj.io\nspec:\n  project: default\n  source:\n    repoURL: https://github.com/mikeyobrien/ralph-orchestrator\n    targetRevision: HEAD\n    path: k8s\n    helm:\n      valueFiles:\n        - values.yaml\n      parameters:\n        - name: image.tag\n          value: latest\n  destination:\n    server: https://kubernetes.default.svc\n    namespace: ralph-production\n  syncPolicy:\n    automated:\n      prune: true\n      selfHeal: true\n      allowEmpty: false\n    syncOptions:\n      - CreateNamespace=true\n      - PruneLast=true\n    retry:\n      limit: 5\n      backoff:\n        duration: 5s\n        factor: 2\n        maxDuration: 3m\n</code></pre>"},{"location":"deployment/ci-cd/#tekton-pipeline","title":"Tekton Pipeline","text":"<p>Create <code>tekton/pipeline.yaml</code>:</p> <pre><code>apiVersion: tekton.dev/v1beta1\nkind: Pipeline\nmetadata:\n  name: ralph-ci-pipeline\nspec:\n  params:\n    - name: repo-url\n      type: string\n    - name: revision\n      type: string\n      default: main\n  workspaces:\n    - name: shared-workspace\n  tasks:\n    - name: fetch-source\n      taskRef:\n        name: git-clone\n      workspaces:\n        - name: output\n          workspace: shared-workspace\n      params:\n        - name: url\n          value: $(params.repo-url)\n        - name: revision\n          value: $(params.revision)\n\n    - name: run-tests\n      runAfter:\n        - fetch-source\n      taskRef:\n        name: pytest\n      workspaces:\n        - name: source\n          workspace: shared-workspace\n\n    - name: build-image\n      runAfter:\n        - run-tests\n      taskRef:\n        name: buildah\n      workspaces:\n        - name: source\n          workspace: shared-workspace\n      params:\n        - name: IMAGE\n          value: ghcr.io/mikeyobrien/ralph-orchestrator\n\n    - name: deploy\n      runAfter:\n        - build-image\n      taskRef:\n        name: kubernetes-actions\n      params:\n        - name: script\n          value: |\n            kubectl set image deployment/ralph ralph=ghcr.io/mikeyobrien/ralph-orchestrator:$(params.revision)\n            kubectl rollout status deployment/ralph\n</code></pre>"},{"location":"deployment/ci-cd/#monitoring-and-notifications","title":"Monitoring and Notifications","text":""},{"location":"deployment/ci-cd/#slack-notifications","title":"Slack Notifications","text":"<p>Add to any CI/CD platform:</p> <pre><code># GitHub Actions example\n- name: Slack Notification\n  uses: 8398a7/action-slack@v3\n  with:\n    status: ${{ job.status }}\n    text: 'Deployment ${{ job.status }}'\n    webhook_url: ${{ secrets.SLACK_WEBHOOK }}\n  if: always()\n</code></pre>"},{"location":"deployment/ci-cd/#health-checks","title":"Health Checks","text":"<pre><code># Post-deployment validation\n- name: Health Check\n  run: |\n    for i in {1..30}; do\n      if curl -f http://ralph.example.com/health; then\n        echo \"Service is healthy\"\n        exit 0\n      fi\n      sleep 10\n    done\n    echo \"Health check failed\"\n    exit 1\n</code></pre>"},{"location":"deployment/ci-cd/#best-practices","title":"Best Practices","text":"<ol> <li>Version Everything: Tag releases with semantic versioning</li> <li>Automate Tests: Run tests on every commit</li> <li>Security Scanning: Include SAST and dependency scanning</li> <li>Progressive Deployment: Use staging environments</li> <li>Rollback Strategy: Implement automatic rollback on failures</li> <li>Secrets Management: Never commit secrets, use CI/CD secrets</li> <li>Artifact Storage: Store build artifacts for reproducibility</li> <li>Monitoring: Track deployment metrics and success rates</li> <li>Documentation: Update docs with every release</li> <li>Compliance: Audit trail for all deployments</li> </ol>"},{"location":"deployment/ci-cd/#next-steps","title":"Next Steps","text":"<ul> <li>Production Deployment - Production best practices</li> <li>Monitoring Setup - Observability configuration</li> <li>Security Guide - Security hardening</li> </ul>"},{"location":"deployment/docker/","title":"Docker Deployment Guide","text":"<p>Deploy Ralph Orchestrator using Docker for consistent, reproducible environments.</p>"},{"location":"deployment/docker/#prerequisites","title":"Prerequisites","text":"<ul> <li>Docker Engine 20.10+ installed</li> <li>Docker Compose 2.0+ (optional, for multi-container setups)</li> <li>At least one AI CLI tool API key configured</li> <li>2GB RAM minimum, 4GB recommended</li> <li>10GB disk space for images and data</li> </ul>"},{"location":"deployment/docker/#quick-start","title":"Quick Start","text":""},{"location":"deployment/docker/#using-pre-built-image","title":"Using Pre-built Image","text":"<pre><code># Pull the latest image\ndocker pull ghcr.io/mikeyobrien/ralph-orchestrator:latest\n\n# Run with default settings\ndocker run -it \\\n  -v $(pwd):/workspace \\\n  -e CLAUDE_API_KEY=$CLAUDE_API_KEY \\\n  ghcr.io/mikeyobrien/ralph-orchestrator:latest\n</code></pre>"},{"location":"deployment/docker/#building-from-source","title":"Building from Source","text":"<p>Create a <code>Dockerfile</code> in your project root:</p> <pre><code># Multi-stage build for optimal size\nFROM python:3.11-slim as builder\n\n# Install build dependencies\nRUN apt-get update &amp;&amp; apt-get install -y \\\n    gcc \\\n    git \\\n    &amp;&amp; rm -rf /var/lib/apt/lists/*\n\n# Copy requirements\nWORKDIR /build\nCOPY pyproject.toml uv.lock ./\nRUN pip install uv &amp;&amp; uv sync --frozen\n\n# Runtime stage\nFROM python:3.11-slim\n\n# Install runtime dependencies\nRUN apt-get update &amp;&amp; apt-get install -y \\\n    git \\\n    nodejs \\\n    npm \\\n    &amp;&amp; rm -rf /var/lib/apt/lists/*\n\n# Install AI CLI tools\nRUN npm install -g @anthropic-ai/claude-code\nRUN npm install -g @google/gemini-cli\n\n# Copy application\nWORKDIR /app\nCOPY --from=builder /build/.venv /app/.venv\nCOPY . /app/\n\n# Set environment\nENV PATH=\"/app/.venv/bin:$PATH\"\nENV PYTHONUNBUFFERED=1\n\n# Create workspace directory\nRUN mkdir -p /workspace\nWORKDIR /workspace\n\n# Entry point\nENTRYPOINT [\"python\", \"/app/ralph_orchestrator.py\"]\nCMD [\"--help\"]\n</code></pre> <p>Build and run:</p> <pre><code># Build the image\ndocker build -t ralph-orchestrator:local .\n\n# Run with your prompt\ndocker run -it \\\n  -v $(pwd):/workspace \\\n  -e CLAUDE_API_KEY=$CLAUDE_API_KEY \\\n  ralph-orchestrator:local \\\n  --agent claude \\\n  --prompt PROMPT.md\n</code></pre>"},{"location":"deployment/docker/#docker-compose-setup","title":"Docker Compose Setup","text":"<p>For complex deployments with multiple services:</p> <pre><code># docker-compose.yml\nversion: '3.8'\n\nservices:\n  ralph:\n    image: ghcr.io/mikeyobrien/ralph-orchestrator:latest\n    container_name: ralph-orchestrator\n    environment:\n      - CLAUDE_API_KEY=${CLAUDE_API_KEY}\n      - GEMINI_API_KEY=${GEMINI_API_KEY}\n      - Q_API_KEY=${Q_API_KEY}\n      - RALPH_MAX_ITERATIONS=100\n      - RALPH_MAX_RUNTIME=14400\n    volumes:\n      - ./workspace:/workspace\n      - ./prompts:/prompts:ro\n      - ralph-cache:/app/.cache\n    networks:\n      - ralph-network\n    restart: unless-stopped\n    command: \n      - --agent=auto\n      - --prompt=/prompts/PROMPT.md\n      - --verbose\n\n  # Optional: Monitoring with Prometheus\n  prometheus:\n    image: prom/prometheus:latest\n    container_name: ralph-prometheus\n    volumes:\n      - ./monitoring/prometheus.yml:/etc/prometheus/prometheus.yml\n      - prometheus-data:/prometheus\n    networks:\n      - ralph-network\n    ports:\n      - \"9090:9090\"\n\n  # Optional: Grafana for visualization\n  grafana:\n    image: grafana/grafana:latest\n    container_name: ralph-grafana\n    environment:\n      - GF_SECURITY_ADMIN_PASSWORD=admin\n    volumes:\n      - grafana-data:/var/lib/grafana\n      - ./monitoring/dashboards:/etc/grafana/provisioning/dashboards\n    networks:\n      - ralph-network\n    ports:\n      - \"3000:3000\"\n\nvolumes:\n  ralph-cache:\n  prometheus-data:\n  grafana-data:\n\nnetworks:\n  ralph-network:\n    driver: bridge\n</code></pre> <p>Start the stack:</p> <pre><code># Start all services\ndocker-compose up -d\n\n# View logs\ndocker-compose logs -f ralph\n\n# Stop all services\ndocker-compose down\n</code></pre>"},{"location":"deployment/docker/#environment-variables","title":"Environment Variables","text":"<p>Configure Ralph through environment variables:</p> Variable Description Default <code>CLAUDE_API_KEY</code> Anthropic Claude API key Required for Claude <code>GEMINI_API_KEY</code> Google Gemini API key Required for Gemini <code>Q_API_KEY</code> Q Chat API key Required for Q <code>RALPH_AGENT</code> Default agent (claude/gemini/q/auto) auto <code>RALPH_MAX_ITERATIONS</code> Maximum loop iterations 100 <code>RALPH_MAX_RUNTIME</code> Maximum runtime in seconds 14400 <code>RALPH_MAX_TOKENS</code> Maximum total tokens 1000000 <code>RALPH_MAX_COST</code> Maximum cost in USD 50.0 <code>RALPH_CHECKPOINT_INTERVAL</code> Git checkpoint frequency 5 <code>RALPH_VERBOSE</code> Enable verbose logging false <code>RALPH_DRY_RUN</code> Test mode without execution false"},{"location":"deployment/docker/#volume-mounts","title":"Volume Mounts","text":"<p>Essential directories to mount:</p> <pre><code>docker run -it \\\n  -v $(pwd)/workspace:/workspace \\           # Working directory\n  -v $(pwd)/prompts:/prompts:ro \\           # Prompt files (read-only)\n  -v $(pwd)/.agent:/app/.agent \\            # Agent state\n  -v $(pwd)/.git:/workspace/.git \\          # Git repository\n  -v ~/.ssh:/root/.ssh:ro \\                 # SSH keys (if needed)\n  ralph-orchestrator:latest\n</code></pre>"},{"location":"deployment/docker/#security-considerations","title":"Security Considerations","text":""},{"location":"deployment/docker/#running-as-non-root-user","title":"Running as Non-Root User","text":"<pre><code># Add to Dockerfile\nRUN useradd -m -u 1000 ralph\nUSER ralph\n</code></pre> <pre><code># Run with user mapping\ndocker run -it \\\n  --user $(id -u):$(id -g) \\\n  -v $(pwd):/workspace \\\n  ralph-orchestrator:latest\n</code></pre>"},{"location":"deployment/docker/#secrets-management","title":"Secrets Management","text":"<p>Never hardcode API keys. Use Docker secrets or environment files:</p> <pre><code># .env file (add to .gitignore!)\nCLAUDE_API_KEY=sk-ant-...\nGEMINI_API_KEY=AIza...\nQ_API_KEY=...\n\n# Run with env file\ndocker run -it \\\n  --env-file .env \\\n  -v $(pwd):/workspace \\\n  ralph-orchestrator:latest\n</code></pre>"},{"location":"deployment/docker/#network-isolation","title":"Network Isolation","text":"<pre><code># Create isolated network\ndocker network create ralph-isolated\n\n# Run with network isolation\ndocker run -it \\\n  --network ralph-isolated \\\n  --network-alias ralph \\\n  -v $(pwd):/workspace \\\n  ralph-orchestrator:latest\n</code></pre>"},{"location":"deployment/docker/#resource-limits","title":"Resource Limits","text":"<p>Prevent runaway containers:</p> <pre><code>docker run -it \\\n  --memory=\"4g\" \\\n  --memory-swap=\"4g\" \\\n  --cpu-shares=512 \\\n  --pids-limit=100 \\\n  -v $(pwd):/workspace \\\n  ralph-orchestrator:latest\n</code></pre>"},{"location":"deployment/docker/#health-checks","title":"Health Checks","text":"<p>Add health monitoring:</p> <pre><code># Add to Dockerfile\nHEALTHCHECK --interval=30s --timeout=3s --retries=3 \\\n  CMD python -c \"import sys; sys.exit(0)\" || exit 1\n</code></pre>"},{"location":"deployment/docker/#debugging","title":"Debugging","text":""},{"location":"deployment/docker/#interactive-shell","title":"Interactive Shell","text":"<pre><code># Start with shell instead of ralph\ndocker run -it \\\n  -v $(pwd):/workspace \\\n  --entrypoint /bin/bash \\\n  ralph-orchestrator:latest\n\n# Inside container\npython /app/ralph_orchestrator.py --dry-run\n</code></pre>"},{"location":"deployment/docker/#view-logs","title":"View Logs","text":"<pre><code># Follow container logs\ndocker logs -f &lt;container-id&gt;\n\n# Save logs to file\ndocker logs &lt;container-id&gt; &gt; ralph.log 2&gt;&amp;1\n</code></pre>"},{"location":"deployment/docker/#inspect-running-container","title":"Inspect Running Container","text":"<pre><code># Execute commands in running container\ndocker exec -it &lt;container-id&gt; /bin/bash\n\n# Check process status\ndocker exec &lt;container-id&gt; ps aux\n\n# View environment\ndocker exec &lt;container-id&gt; env\n</code></pre>"},{"location":"deployment/docker/#production-deployment","title":"Production Deployment","text":""},{"location":"deployment/docker/#using-docker-swarm","title":"Using Docker Swarm","text":"<pre><code># Initialize swarm\ndocker swarm init\n\n# Create secrets\necho $CLAUDE_API_KEY | docker secret create claude_key -\necho $GEMINI_API_KEY | docker secret create gemini_key -\n\n# Deploy stack\ndocker stack deploy -c docker-compose.yml ralph-stack\n\n# Scale service\ndocker service scale ralph-stack_ralph=3\n</code></pre>"},{"location":"deployment/docker/#using-kubernetes","title":"Using Kubernetes","text":"<p>See Kubernetes Deployment Guide for container orchestration at scale.</p>"},{"location":"deployment/docker/#monitoring-and-metrics","title":"Monitoring and Metrics","text":""},{"location":"deployment/docker/#export-metrics","title":"Export Metrics","text":"<pre><code># Enable metrics in config\ndocker run -it \\\n  -e RALPH_ENABLE_METRICS=true \\\n  -e RALPH_METRICS_PORT=8080 \\\n  -p 8080:8080 \\\n  ralph-orchestrator:latest\n</code></pre>"},{"location":"deployment/docker/#prometheus-configuration","title":"Prometheus Configuration","text":"<pre><code># prometheus.yml\nscrape_configs:\n  - job_name: 'ralph'\n    static_configs:\n      - targets: ['ralph:8080']\n    metrics_path: '/metrics'\n</code></pre>"},{"location":"deployment/docker/#troubleshooting","title":"Troubleshooting","text":""},{"location":"deployment/docker/#common-issues","title":"Common Issues","text":""},{"location":"deployment/docker/#permission-denied","title":"Permission Denied","text":"<pre><code># Fix volume permissions\ndocker run -it \\\n  --user $(id -u):$(id -g) \\\n  -v $(pwd):/workspace:Z \\  # SELinux context\n  ralph-orchestrator:latest\n</code></pre>"},{"location":"deployment/docker/#out-of-memory","title":"Out of Memory","text":"<pre><code># Increase memory limit\ndocker run -it \\\n  --memory=\"8g\" \\\n  --memory-swap=\"8g\" \\\n  ralph-orchestrator:latest\n</code></pre>"},{"location":"deployment/docker/#network-timeouts","title":"Network Timeouts","text":"<pre><code># Increase timeout values\ndocker run -it \\\n  -e RALPH_RETRY_DELAY=5 \\\n  -e RALPH_MAX_RETRIES=10 \\\n  ralph-orchestrator:latest\n</code></pre>"},{"location":"deployment/docker/#debug-mode","title":"Debug Mode","text":"<pre><code># Enable debug logging\ndocker run -it \\\n  -e LOG_LEVEL=DEBUG \\\n  -e RALPH_VERBOSE=true \\\n  ralph-orchestrator:latest \\\n  --verbose --dry-run\n</code></pre>"},{"location":"deployment/docker/#best-practices","title":"Best Practices","text":"<ol> <li>Always use specific image tags in production (not <code>latest</code>)</li> <li>Mount prompts as read-only to prevent accidental modification</li> <li>Use .dockerignore to exclude unnecessary files</li> <li>Implement health checks for automatic recovery</li> <li>Set resource limits to prevent resource exhaustion</li> <li>Use multi-stage builds to minimize image size</li> <li>Scan images for vulnerabilities with tools like Trivy</li> <li>Never commit secrets to version control</li> <li>Use volume mounts for persistent data</li> <li>Monitor container logs and metrics</li> </ol>"},{"location":"deployment/docker/#example-dockerignore","title":"Example .dockerignore","text":"<pre><code># .dockerignore\n.git\n.github\n*.pyc\n__pycache__\n.pytest_cache\n.venv\nsite/\ndocs/\ntests/\n*.md\n!README.md\n.env\n.env.*\n</code></pre>"},{"location":"deployment/docker/#next-steps","title":"Next Steps","text":"<ul> <li>Kubernetes Deployment - For container orchestration</li> <li>CI/CD Integration - Automate Docker builds</li> <li>Production Guide - Best practices for production</li> </ul>"},{"location":"deployment/kubernetes/","title":"Kubernetes Deployment Guide","text":"<p>Deploy Ralph Orchestrator on Kubernetes for scalable, resilient AI orchestration.</p>"},{"location":"deployment/kubernetes/#prerequisites","title":"Prerequisites","text":"<ul> <li>Kubernetes cluster 1.20+ (local or cloud)</li> <li><code>kubectl</code> configured with cluster access</li> <li>Helm 3.0+ (optional, for Helm deployment)</li> <li>Container registry access (Docker Hub, GCR, ECR, etc.)</li> <li>Minimum 2 nodes with 4GB RAM each</li> </ul>"},{"location":"deployment/kubernetes/#quick-start","title":"Quick Start","text":""},{"location":"deployment/kubernetes/#basic-deployment-with-kubectl","title":"Basic Deployment with kubectl","text":"<p>Create namespace and deploy:</p> <pre><code># Create namespace\nkubectl create namespace ralph-orchestrator\n\n# Apply manifests\nkubectl apply -f k8s/ -n ralph-orchestrator\n\n# Check deployment\nkubectl get pods -n ralph-orchestrator\n</code></pre>"},{"location":"deployment/kubernetes/#kubernetes-manifests","title":"Kubernetes Manifests","text":""},{"location":"deployment/kubernetes/#1-namespace-and-configmap","title":"1. Namespace and ConfigMap","text":"<pre><code># k8s/00-namespace.yaml\napiVersion: v1\nkind: Namespace\nmetadata:\n  name: ralph-orchestrator\n---\n# k8s/01-configmap.yaml\napiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: ralph-config\n  namespace: ralph-orchestrator\ndata:\n  RALPH_AGENT: \"auto\"\n  RALPH_MAX_ITERATIONS: \"100\"\n  RALPH_MAX_RUNTIME: \"14400\"\n  RALPH_CHECKPOINT_INTERVAL: \"5\"\n  RALPH_VERBOSE: \"true\"\n  RALPH_ENABLE_METRICS: \"true\"\n</code></pre>"},{"location":"deployment/kubernetes/#2-secrets-management","title":"2. Secrets Management","text":"<pre><code># k8s/02-secrets.yaml\napiVersion: v1\nkind: Secret\nmetadata:\n  name: ralph-secrets\n  namespace: ralph-orchestrator\ntype: Opaque\nstringData:\n  CLAUDE_API_KEY: \"sk-ant-...\"\n  GEMINI_API_KEY: \"AIza...\"\n  Q_API_KEY: \"...\"\n</code></pre> <p>Apply secrets from command line:</p> <pre><code># Create secret from literals\nkubectl create secret generic ralph-secrets \\\n  --from-literal=CLAUDE_API_KEY=$CLAUDE_API_KEY \\\n  --from-literal=GEMINI_API_KEY=$GEMINI_API_KEY \\\n  --from-literal=Q_API_KEY=$Q_API_KEY \\\n  -n ralph-orchestrator\n</code></pre>"},{"location":"deployment/kubernetes/#3-persistent-storage","title":"3. Persistent Storage","text":"<pre><code># k8s/03-pvc.yaml\napiVersion: v1\nkind: PersistentVolumeClaim\nmetadata:\n  name: ralph-workspace\n  namespace: ralph-orchestrator\nspec:\n  accessModes:\n    - ReadWriteOnce\n  storageClassName: standard\n  resources:\n    requests:\n      storage: 10Gi\n---\napiVersion: v1\nkind: PersistentVolumeClaim\nmetadata:\n  name: ralph-cache\n  namespace: ralph-orchestrator\nspec:\n  accessModes:\n    - ReadWriteMany\n  storageClassName: standard\n  resources:\n    requests:\n      storage: 5Gi\n</code></pre>"},{"location":"deployment/kubernetes/#4-deployment","title":"4. Deployment","text":"<pre><code># k8s/04-deployment.yaml\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: ralph-orchestrator\n  namespace: ralph-orchestrator\n  labels:\n    app: ralph-orchestrator\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      app: ralph-orchestrator\n  template:\n    metadata:\n      labels:\n        app: ralph-orchestrator\n    spec:\n      serviceAccountName: ralph-sa\n      containers:\n      - name: ralph\n        image: ghcr.io/mikeyobrien/ralph-orchestrator:v1.0.0\n        imagePullPolicy: Always\n        envFrom:\n        - configMapRef:\n            name: ralph-config\n        - secretRef:\n            name: ralph-secrets\n        resources:\n          requests:\n            memory: \"2Gi\"\n            cpu: \"1\"\n          limits:\n            memory: \"4Gi\"\n            cpu: \"2\"\n        volumeMounts:\n        - name: workspace\n          mountPath: /workspace\n        - name: cache\n          mountPath: /app/.cache\n        - name: prompts\n          mountPath: /prompts\n        livenessProbe:\n          exec:\n            command:\n            - python\n            - -c\n            - \"import sys; sys.exit(0)\"\n          initialDelaySeconds: 30\n          periodSeconds: 30\n        readinessProbe:\n          exec:\n            command:\n            - python\n            - -c\n            - \"import os; sys.exit(0 if os.path.exists('/app/ralph_orchestrator.py') else 1)\"\n          initialDelaySeconds: 10\n          periodSeconds: 10\n      volumes:\n      - name: workspace\n        persistentVolumeClaim:\n          claimName: ralph-workspace\n      - name: cache\n        persistentVolumeClaim:\n          claimName: ralph-cache\n      - name: prompts\n        configMap:\n          name: ralph-prompts\n</code></pre>"},{"location":"deployment/kubernetes/#5-service-and-monitoring","title":"5. Service and Monitoring","text":"<pre><code># k8s/05-service.yaml\napiVersion: v1\nkind: Service\nmetadata:\n  name: ralph-metrics\n  namespace: ralph-orchestrator\n  labels:\n    app: ralph-orchestrator\nspec:\n  type: ClusterIP\n  ports:\n  - port: 8080\n    targetPort: 8080\n    name: metrics\n  selector:\n    app: ralph-orchestrator\n---\n# k8s/06-servicemonitor.yaml\napiVersion: monitoring.coreos.com/v1\nkind: ServiceMonitor\nmetadata:\n  name: ralph-orchestrator\n  namespace: ralph-orchestrator\nspec:\n  selector:\n    matchLabels:\n      app: ralph-orchestrator\n  endpoints:\n  - port: metrics\n    interval: 30s\n    path: /metrics\n</code></pre>"},{"location":"deployment/kubernetes/#6-job-for-one-time-tasks","title":"6. Job for One-Time Tasks","text":"<pre><code># k8s/07-job.yaml\napiVersion: batch/v1\nkind: Job\nmetadata:\n  name: ralph-task\n  namespace: ralph-orchestrator\nspec:\n  backoffLimit: 3\n  activeDeadlineSeconds: 14400\n  template:\n    spec:\n      restartPolicy: Never\n      containers:\n      - name: ralph\n        image: ghcr.io/mikeyobrien/ralph-orchestrator:v1.0.0\n        envFrom:\n        - configMapRef:\n            name: ralph-config\n        - secretRef:\n            name: ralph-secrets\n        args:\n        - \"--agent=claude\"\n        - \"--prompt=/prompts/task.md\"\n        - \"--max-iterations=50\"\n        volumeMounts:\n        - name: prompts\n          mountPath: /prompts\n        - name: output\n          mountPath: /output\n      volumes:\n      - name: prompts\n        configMap:\n          name: ralph-prompts\n      - name: output\n        emptyDir: {}\n</code></pre>"},{"location":"deployment/kubernetes/#helm-chart-deployment","title":"Helm Chart Deployment","text":""},{"location":"deployment/kubernetes/#install-with-helm","title":"Install with Helm","text":"<pre><code># Add repository\nhelm repo add ralph https://mikeyobrien.github.io/ralph-orchestrator/charts\nhelm repo update\n\n# Install with custom values\nhelm install ralph ralph/ralph-orchestrator \\\n  --namespace ralph-orchestrator \\\n  --create-namespace \\\n  --set apiKeys.claude=$CLAUDE_API_KEY \\\n  --set apiKeys.gemini=$GEMINI_API_KEY \\\n  --set config.maxIterations=100\n</code></pre>"},{"location":"deployment/kubernetes/#custom-valuesyaml","title":"Custom values.yaml","text":"<pre><code># values.yaml\nreplicaCount: 1\n\nimage:\n  repository: ghcr.io/mikeyobrien/ralph-orchestrator\n  tag: v1.0.0\n  pullPolicy: IfNotPresent\n\napiKeys:\n  claude: \"\"\n  gemini: \"\"\n  q: \"\"\n\nconfig:\n  agent: \"auto\"\n  maxIterations: 100\n  maxRuntime: 14400\n  checkpointInterval: 5\n  verbose: true\n  enableMetrics: true\n\nresources:\n  requests:\n    memory: \"2Gi\"\n    cpu: \"1\"\n  limits:\n    memory: \"4Gi\"\n    cpu: \"2\"\n\npersistence:\n  enabled: true\n  storageClass: \"standard\"\n  workspace:\n    size: 10Gi\n  cache:\n    size: 5Gi\n\nautoscaling:\n  enabled: false\n  minReplicas: 1\n  maxReplicas: 10\n  targetCPUUtilizationPercentage: 80\n\nmonitoring:\n  enabled: true\n  serviceMonitor:\n    enabled: true\n    interval: 30s\n\ningress:\n  enabled: false\n  className: \"nginx\"\n  annotations: {}\n  hosts:\n    - host: ralph.example.com\n      paths:\n        - path: /\n          pathType: Prefix\n</code></pre>"},{"location":"deployment/kubernetes/#horizontal-pod-autoscaling","title":"Horizontal Pod Autoscaling","text":"<pre><code># k8s/08-hpa.yaml\napiVersion: autoscaling/v2\nkind: HorizontalPodAutoscaler\nmetadata:\n  name: ralph-hpa\n  namespace: ralph-orchestrator\nspec:\n  scaleTargetRef:\n    apiVersion: apps/v1\n    kind: Deployment\n    name: ralph-orchestrator\n  minReplicas: 1\n  maxReplicas: 10\n  metrics:\n  - type: Resource\n    resource:\n      name: cpu\n      target:\n        type: Utilization\n        averageUtilization: 70\n  - type: Resource\n    resource:\n      name: memory\n      target:\n        type: Utilization\n        averageUtilization: 80\n</code></pre>"},{"location":"deployment/kubernetes/#cronjob-for-scheduled-tasks","title":"CronJob for Scheduled Tasks","text":"<pre><code># k8s/09-cronjob.yaml\napiVersion: batch/v1\nkind: CronJob\nmetadata:\n  name: ralph-daily\n  namespace: ralph-orchestrator\nspec:\n  schedule: \"0 2 * * *\"  # Daily at 2 AM\n  jobTemplate:\n    spec:\n      template:\n        spec:\n          restartPolicy: OnFailure\n          containers:\n          - name: ralph\n            image: ghcr.io/mikeyobrien/ralph-orchestrator:v1.0.0\n            envFrom:\n            - configMapRef:\n                name: ralph-config\n            - secretRef:\n                name: ralph-secrets\n            args:\n            - \"--agent=auto\"\n            - \"--prompt=/prompts/daily-task.md\"\n</code></pre>"},{"location":"deployment/kubernetes/#service-account-and-rbac","title":"Service Account and RBAC","text":"<pre><code># k8s/10-rbac.yaml\napiVersion: v1\nkind: ServiceAccount\nmetadata:\n  name: ralph-sa\n  namespace: ralph-orchestrator\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: Role\nmetadata:\n  name: ralph-role\n  namespace: ralph-orchestrator\nrules:\n- apiGroups: [\"\"]\n  resources: [\"configmaps\", \"secrets\"]\n  verbs: [\"get\", \"list\", \"watch\"]\n- apiGroups: [\"\"]\n  resources: [\"pods\", \"pods/log\"]\n  verbs: [\"get\", \"list\", \"watch\"]\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: RoleBinding\nmetadata:\n  name: ralph-rolebinding\n  namespace: ralph-orchestrator\nroleRef:\n  apiVersion: rbac.authorization.k8s.io/v1\n  kind: Role\n  name: ralph-role\nsubjects:\n- kind: ServiceAccount\n  name: ralph-sa\n  namespace: ralph-orchestrator\n</code></pre>"},{"location":"deployment/kubernetes/#network-policies","title":"Network Policies","text":"<pre><code># k8s/11-networkpolicy.yaml\napiVersion: networking.k8s.io/v1\nkind: NetworkPolicy\nmetadata:\n  name: ralph-network-policy\n  namespace: ralph-orchestrator\nspec:\n  podSelector:\n    matchLabels:\n      app: ralph-orchestrator\n  policyTypes:\n  - Ingress\n  - Egress\n  ingress:\n  - from:\n    - namespaceSelector:\n        matchLabels:\n          name: monitoring\n    ports:\n    - protocol: TCP\n      port: 8080\n  egress:\n  - to:\n    - namespaceSelector: {}\n    ports:\n    - protocol: TCP\n      port: 443  # HTTPS for API calls\n    - protocol: TCP\n      port: 53   # DNS\n    - protocol: UDP\n      port: 53   # DNS\n</code></pre>"},{"location":"deployment/kubernetes/#monitoring-with-prometheus","title":"Monitoring with Prometheus","text":"<pre><code># k8s/12-prometheus-config.yaml\napiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: prometheus-config\n  namespace: monitoring\ndata:\n  prometheus.yml: |\n    global:\n      scrape_interval: 15s\n    scrape_configs:\n    - job_name: 'ralph-orchestrator'\n      kubernetes_sd_configs:\n      - role: pod\n        namespaces:\n          names:\n          - ralph-orchestrator\n      relabel_configs:\n      - source_labels: [__meta_kubernetes_pod_label_app]\n        action: keep\n        regex: ralph-orchestrator\n</code></pre>"},{"location":"deployment/kubernetes/#cloud-provider-specific","title":"Cloud Provider Specific","text":""},{"location":"deployment/kubernetes/#google-kubernetes-engine-gke","title":"Google Kubernetes Engine (GKE)","text":"<pre><code># Create cluster\ngcloud container clusters create ralph-cluster \\\n  --zone us-central1-a \\\n  --num-nodes 3 \\\n  --machine-type n1-standard-2\n\n# Get credentials\ngcloud container clusters get-credentials ralph-cluster \\\n  --zone us-central1-a\n\n# Create secret for GCR\nkubectl create secret docker-registry gcr-json-key \\\n  --docker-server=gcr.io \\\n  --docker-username=_json_key \\\n  --docker-password=\"$(cat ~/key.json)\" \\\n  -n ralph-orchestrator\n</code></pre>"},{"location":"deployment/kubernetes/#amazon-eks","title":"Amazon EKS","text":"<pre><code># Create cluster\neksctl create cluster \\\n  --name ralph-cluster \\\n  --region us-west-2 \\\n  --nodegroup-name workers \\\n  --node-type t3.medium \\\n  --nodes 3\n\n# Update kubeconfig\naws eks update-kubeconfig \\\n  --name ralph-cluster \\\n  --region us-west-2\n</code></pre>"},{"location":"deployment/kubernetes/#azure-aks","title":"Azure AKS","text":"<pre><code># Create cluster\naz aks create \\\n  --resource-group ralph-rg \\\n  --name ralph-cluster \\\n  --node-count 3 \\\n  --node-vm-size Standard_DS2_v2\n\n# Get credentials\naz aks get-credentials \\\n  --resource-group ralph-rg \\\n  --name ralph-cluster\n</code></pre>"},{"location":"deployment/kubernetes/#gitops-with-argocd","title":"GitOps with ArgoCD","text":"<pre><code># k8s/argocd-app.yaml\napiVersion: argoproj.io/v1alpha1\nkind: Application\nmetadata:\n  name: ralph-orchestrator\n  namespace: argocd\nspec:\n  project: default\n  source:\n    repoURL: https://github.com/mikeyobrien/ralph-orchestrator\n    targetRevision: HEAD\n    path: k8s\n  destination:\n    server: https://kubernetes.default.svc\n    namespace: ralph-orchestrator\n  syncPolicy:\n    automated:\n      prune: true\n      selfHeal: true\n</code></pre>"},{"location":"deployment/kubernetes/#troubleshooting","title":"Troubleshooting","text":""},{"location":"deployment/kubernetes/#check-pod-status","title":"Check Pod Status","text":"<pre><code># Get pods\nkubectl get pods -n ralph-orchestrator\n\n# Describe pod\nkubectl describe pod &lt;pod-name&gt; -n ralph-orchestrator\n\n# View logs\nkubectl logs -f &lt;pod-name&gt; -n ralph-orchestrator\n\n# Execute into pod\nkubectl exec -it &lt;pod-name&gt; -n ralph-orchestrator -- /bin/bash\n</code></pre>"},{"location":"deployment/kubernetes/#common-issues","title":"Common Issues","text":""},{"location":"deployment/kubernetes/#imagepullbackoff","title":"ImagePullBackOff","text":"<pre><code># Check image pull secrets\nkubectl get secrets -n ralph-orchestrator\n\n# Create pull secret\nkubectl create secret docker-registry regcred \\\n  --docker-server=ghcr.io \\\n  --docker-username=USERNAME \\\n  --docker-password=TOKEN \\\n  -n ralph-orchestrator\n</code></pre>"},{"location":"deployment/kubernetes/#pvc-not-bound","title":"PVC Not Bound","text":"<pre><code># Check PVC status\nkubectl get pvc -n ralph-orchestrator\n\n# Check available storage classes\nkubectl get storageclass\n\n# Create PV if needed\nkubectl apply -f persistent-volume.yaml\n</code></pre>"},{"location":"deployment/kubernetes/#oomkilled","title":"OOMKilled","text":"<pre><code># Increase memory limits\nkubectl set resources deployment ralph-orchestrator \\\n  --limits=memory=8Gi \\\n  -n ralph-orchestrator\n</code></pre>"},{"location":"deployment/kubernetes/#best-practices","title":"Best Practices","text":"<ol> <li>Use namespaces to isolate Ralph deployments</li> <li>Implement RBAC for least privilege access</li> <li>Use secrets management (Sealed Secrets, External Secrets)</li> <li>Set resource limits to prevent resource starvation</li> <li>Enable monitoring with Prometheus/Grafana</li> <li>Use network policies for security</li> <li>Implement health checks for automatic recovery</li> <li>Use GitOps for declarative deployments</li> <li>Regular backups of persistent volumes</li> <li>Use pod disruption budgets for high availability</li> </ol>"},{"location":"deployment/kubernetes/#production-considerations","title":"Production Considerations","text":"<ul> <li>High Availability: Deploy across multiple availability zones</li> <li>Disaster Recovery: Regular backups and cross-region replication</li> <li>Security: Pod Security Policies, Network Policies, RBAC</li> <li>Observability: Logging (ELK), Metrics (Prometheus), Tracing (Jaeger)</li> <li>Cost Optimization: Use spot instances, autoscaling, resource quotas</li> <li>Compliance: Audit logging, encryption at rest and in transit</li> </ul>"},{"location":"deployment/kubernetes/#next-steps","title":"Next Steps","text":"<ul> <li>CI/CD Integration - Automate Kubernetes deployments</li> <li>Production Guide - Production best practices</li> <li>Monitoring Setup - Complete observability</li> </ul>"},{"location":"deployment/production/","title":"Production Deployment Guide","text":"<p>Complete guide for deploying Ralph Orchestrator in production environments with enterprise-grade reliability, security, and scalability.</p>"},{"location":"deployment/production/#pre-production-checklist","title":"Pre-Production Checklist","text":""},{"location":"deployment/production/#infrastructure-requirements","title":"Infrastructure Requirements","text":"<ul> <li> Compute Resources</li> <li>Minimum: 2 vCPUs, 4GB RAM per instance</li> <li>Recommended: 4 vCPUs, 8GB RAM per instance</li> <li> <p>Auto-scaling configured (2-10 instances)</p> </li> <li> <p> Storage</p> </li> <li>100GB SSD for application and logs</li> <li>Separate persistent volumes for data</li> <li> <p>Backup storage configured</p> </li> <li> <p> Network</p> </li> <li>Load balancer configured</li> <li>SSL/TLS certificates installed</li> <li>Firewall rules configured</li> <li> <p>DDoS protection enabled</p> </li> <li> <p> High Availability</p> </li> <li>Multi-AZ deployment</li> <li>Database replication</li> <li>Redis cluster for caching</li> <li>Message queue redundancy</li> </ul>"},{"location":"deployment/production/#security-requirements","title":"Security Requirements","text":"<ul> <li> Access Control</li> <li>RBAC configured</li> <li>Service accounts created</li> <li>API keys rotated</li> <li> <p>MFA enforced for admin access</p> </li> <li> <p> Secrets Management</p> </li> <li>HashiCorp Vault or AWS Secrets Manager configured</li> <li>All secrets encrypted at rest</li> <li> <p>Secrets rotation policy implemented</p> </li> <li> <p> Compliance</p> </li> <li>Data encryption in transit and at rest</li> <li>Audit logging enabled</li> <li>GDPR/CCPA compliance verified</li> <li>Security scanning completed</li> </ul>"},{"location":"deployment/production/#production-architecture","title":"Production Architecture","text":"<pre><code>graph TB\n    subgraph \"Internet\"\n        U[Users]\n        API[API Clients]\n    end\n\n    subgraph \"Edge Layer\"\n        CDN[CloudFlare CDN]\n        WAF[Web Application Firewall]\n    end\n\n    subgraph \"Load Balancing\"\n        ALB[Application Load Balancer]\n        NLB[Network Load Balancer]\n    end\n\n    subgraph \"Application Layer\"\n        R1[Ralph Instance 1]\n        R2[Ralph Instance 2]\n        R3[Ralph Instance N]\n    end\n\n    subgraph \"Data Layer\"\n        PG[(PostgreSQL Primary)]\n        PGR[(PostgreSQL Replica)]\n        REDIS[(Redis Cluster)]\n        S3[S3 Object Storage]\n    end\n\n    subgraph \"Monitoring\"\n        PROM[Prometheus]\n        GRAF[Grafana]\n        ELK[ELK Stack]\n    end\n\n    U --&gt; CDN\n    API --&gt; WAF\n    CDN --&gt; ALB\n    WAF --&gt; NLB\n    ALB --&gt; R1\n    ALB --&gt; R2\n    ALB --&gt; R3\n    NLB --&gt; R1\n    R1 --&gt; PG\n    R2 --&gt; PGR\n    R3 --&gt; REDIS\n    R1 --&gt; S3\n    R1 --&gt; PROM\n    PROM --&gt; GRAF\n    R1 --&gt; ELK</code></pre>"},{"location":"deployment/production/#deployment-steps","title":"Deployment Steps","text":""},{"location":"deployment/production/#1-infrastructure-setup","title":"1. Infrastructure Setup","text":""},{"location":"deployment/production/#aws-production-setup","title":"AWS Production Setup","text":"<pre><code># Create VPC and subnets\naws ec2 create-vpc --cidr-block 10.0.0.0/16\n\n# Create EKS cluster\neksctl create cluster \\\n  --name ralph-production \\\n  --version 1.28 \\\n  --region us-west-2 \\\n  --nodegroup-name workers \\\n  --node-type m5.xlarge \\\n  --nodes 3 \\\n  --nodes-min 2 \\\n  --nodes-max 10 \\\n  --managed\n\n# Create RDS instance\naws rds create-db-instance \\\n  --db-instance-identifier ralph-prod-db \\\n  --db-instance-class db.t3.large \\\n  --engine postgres \\\n  --engine-version 15.4 \\\n  --master-username ralph \\\n  --master-user-password $DB_PASSWORD \\\n  --allocated-storage 100 \\\n  --backup-retention-period 30 \\\n  --multi-az\n\n# Create ElastiCache Redis cluster\naws elasticache create-cache-cluster \\\n  --cache-cluster-id ralph-prod-cache \\\n  --engine redis \\\n  --cache-node-type cache.r6g.large \\\n  --num-cache-nodes 3 \\\n  --cache-subnet-group-name ralph-cache-subnet\n</code></pre>"},{"location":"deployment/production/#gcp-production-setup","title":"GCP Production Setup","text":"<pre><code># Create GKE cluster\ngcloud container clusters create ralph-production \\\n  --zone us-central1-a \\\n  --machine-type n2-standard-4 \\\n  --num-nodes 3 \\\n  --enable-autoscaling \\\n  --min-nodes 2 \\\n  --max-nodes 10 \\\n  --enable-autorepair \\\n  --enable-autoupgrade\n\n# Create Cloud SQL instance\ngcloud sql instances create ralph-prod-db \\\n  --database-version=POSTGRES_15 \\\n  --cpu=4 \\\n  --memory=16GB \\\n  --region=us-central1 \\\n  --availability-type=REGIONAL \\\n  --backup \\\n  --backup-start-time=03:00\n\n# Create Memorystore Redis\ngcloud redis instances create ralph-prod-cache \\\n  --size=5 \\\n  --region=us-central1 \\\n  --redis-version=redis_6_x \\\n  --tier=STANDARD_HA\n</code></pre>"},{"location":"deployment/production/#2-application-configuration","title":"2. Application Configuration","text":""},{"location":"deployment/production/#production-environment-variables","title":"Production Environment Variables","text":"<pre><code># .env.production\n# API Configuration\nRALPH_AGENT=auto\nRALPH_MAX_ITERATIONS=1000\nRALPH_MAX_RUNTIME=28800  # 8 hours\nRALPH_MAX_TOKENS=5000000\nRALPH_MAX_COST=500.0\n\n# Database\nDATABASE_URL=postgresql://user:pass@db.example.com:5432/ralph_prod\nDATABASE_POOL_SIZE=20\nDATABASE_MAX_OVERFLOW=40\n\n# Redis Cache\nREDIS_URL=redis://redis.example.com:6379/0\nREDIS_POOL_SIZE=50\nREDIS_TTL=3600\n\n# Monitoring\nENABLE_METRICS=true\nMETRICS_PORT=8080\nLOG_LEVEL=INFO\nSENTRY_DSN=https://xxx@sentry.io/xxx\n\n# Security\nSECRET_KEY=$(openssl rand -hex 32)\nENCRYPTION_KEY=$(openssl rand -base64 32)\nAPI_RATE_LIMIT=100/minute\nALLOWED_HOSTS=ralph.example.com\nCORS_ORIGINS=https://app.example.com\n\n# AI Service Keys (from secrets manager)\nCLAUDE_API_KEY_SECRET=arn:aws:secretsmanager:region:account:secret:claude-key\nGEMINI_API_KEY_SECRET=arn:aws:secretsmanager:region:account:secret:gemini-key\n</code></pre>"},{"location":"deployment/production/#production-settings","title":"Production Settings","text":"<pre><code># config/production.py\nimport os\nfrom typing import Dict, Any\n\nclass ProductionConfig:\n    \"\"\"Production configuration\"\"\"\n\n    # Application\n    DEBUG = False\n    TESTING = False\n    ENV = 'production'\n\n    # Security\n    SECRET_KEY = os.environ['SECRET_KEY']\n    SESSION_COOKIE_SECURE = True\n    SESSION_COOKIE_HTTPONLY = True\n    SESSION_COOKIE_SAMESITE = 'Strict'\n    PERMANENT_SESSION_LIFETIME = 3600\n\n    # Database\n    SQLALCHEMY_DATABASE_URI = os.environ['DATABASE_URL']\n    SQLALCHEMY_ENGINE_OPTIONS = {\n        'pool_size': 20,\n        'pool_recycle': 3600,\n        'pool_pre_ping': True,\n        'max_overflow': 40,\n        'connect_args': {\n            'connect_timeout': 10,\n            'application_name': 'ralph-orchestrator'\n        }\n    }\n\n    # Caching\n    CACHE_TYPE = 'redis'\n    CACHE_REDIS_URL = os.environ['REDIS_URL']\n    CACHE_DEFAULT_TIMEOUT = 3600\n\n    # Rate Limiting\n    RATELIMIT_STORAGE_URL = os.environ['REDIS_URL']\n    RATELIMIT_STRATEGY = 'fixed-window'\n    RATELIMIT_DEFAULT = \"100/hour\"\n\n    # Monitoring\n    PROMETHEUS_METRICS = True\n    LOGGING_CONFIG = {\n        'version': 1,\n        'disable_existing_loggers': False,\n        'formatters': {\n            'json': {\n                'class': 'pythonjsonlogger.jsonlogger.JsonFormatter',\n                'format': '%(asctime)s %(name)s %(levelname)s %(message)s'\n            }\n        },\n        'handlers': {\n            'console': {\n                'class': 'logging.StreamHandler',\n                'formatter': 'json',\n                'level': 'INFO'\n            },\n            'file': {\n                'class': 'logging.handlers.RotatingFileHandler',\n                'filename': '/var/log/ralph/app.log',\n                'maxBytes': 104857600,  # 100MB\n                'backupCount': 10,\n                'formatter': 'json'\n            }\n        },\n        'root': {\n            'level': 'INFO',\n            'handlers': ['console', 'file']\n        }\n    }\n</code></pre>"},{"location":"deployment/production/#3-deployment-configuration","title":"3. Deployment Configuration","text":""},{"location":"deployment/production/#kubernetes-production-manifests","title":"Kubernetes Production Manifests","text":"<pre><code># k8s/production/deployment.yaml\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: ralph-orchestrator\n  namespace: production\nspec:\n  replicas: 3\n  strategy:\n    type: RollingUpdate\n    rollingUpdate:\n      maxSurge: 1\n      maxUnavailable: 0\n  selector:\n    matchLabels:\n      app: ralph-orchestrator\n  template:\n    metadata:\n      labels:\n        app: ralph-orchestrator\n        version: v1.0.0\n    spec:\n      affinity:\n        podAntiAffinity:\n          requiredDuringSchedulingIgnoredDuringExecution:\n          - labelSelector:\n              matchExpressions:\n              - key: app\n                operator: In\n                values:\n                - ralph-orchestrator\n            topologyKey: kubernetes.io/hostname\n      containers:\n      - name: ralph\n        image: ghcr.io/mikeyobrien/ralph-orchestrator:v1.0.0\n        ports:\n        - containerPort: 8080\n          name: metrics\n        envFrom:\n        - secretRef:\n            name: ralph-secrets\n        - configMapRef:\n            name: ralph-config\n        resources:\n          requests:\n            memory: \"4Gi\"\n            cpu: \"2\"\n          limits:\n            memory: \"8Gi\"\n            cpu: \"4\"\n        livenessProbe:\n          httpGet:\n            path: /health\n            port: 8080\n          initialDelaySeconds: 30\n          periodSeconds: 30\n          timeoutSeconds: 5\n          failureThreshold: 3\n        readinessProbe:\n          httpGet:\n            path: /ready\n            port: 8080\n          initialDelaySeconds: 10\n          periodSeconds: 10\n          timeoutSeconds: 5\n          failureThreshold: 3\n        volumeMounts:\n        - name: config\n          mountPath: /app/config\n          readOnly: true\n        - name: secrets\n          mountPath: /app/secrets\n          readOnly: true\n      volumes:\n      - name: config\n        configMap:\n          name: ralph-config\n      - name: secrets\n        secret:\n          secretName: ralph-secrets\n          defaultMode: 0400\n</code></pre>"},{"location":"deployment/production/#4-load-balancing-and-ssl","title":"4. Load Balancing and SSL","text":""},{"location":"deployment/production/#ingress-configuration","title":"Ingress Configuration","text":"<pre><code># k8s/production/ingress.yaml\napiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: ralph-ingress\n  namespace: production\n  annotations:\n    kubernetes.io/ingress.class: nginx\n    cert-manager.io/cluster-issuer: letsencrypt-prod\n    nginx.ingress.kubernetes.io/rate-limit: \"100\"\n    nginx.ingress.kubernetes.io/ssl-redirect: \"true\"\n    nginx.ingress.kubernetes.io/force-ssl-redirect: \"true\"\nspec:\n  tls:\n  - hosts:\n    - ralph.example.com\n    secretName: ralph-tls\n  rules:\n  - host: ralph.example.com\n    http:\n      paths:\n      - path: /\n        pathType: Prefix\n        backend:\n          service:\n            name: ralph-service\n            port:\n              number: 80\n</code></pre>"},{"location":"deployment/production/#5-database-setup","title":"5. Database Setup","text":""},{"location":"deployment/production/#production-database-initialization","title":"Production Database Initialization","text":"<pre><code>-- Create production database\nCREATE DATABASE ralph_production;\nCREATE USER ralph_app WITH ENCRYPTED PASSWORD 'secure_password';\nGRANT ALL PRIVILEGES ON DATABASE ralph_production TO ralph_app;\n\n-- Enable extensions\n\\c ralph_production\nCREATE EXTENSION IF NOT EXISTS \"uuid-ossp\";\nCREATE EXTENSION IF NOT EXISTS \"pg_stat_statements\";\n\n-- Create schemas\nCREATE SCHEMA IF NOT EXISTS ralph;\nCREATE SCHEMA IF NOT EXISTS audit;\n\n-- Set search path\nALTER USER ralph_app SET search_path TO ralph, public;\n\n-- Create tables\nCREATE TABLE ralph.orchestrations (\n    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),\n    task_id VARCHAR(255) UNIQUE NOT NULL,\n    agent_type VARCHAR(50) NOT NULL,\n    status VARCHAR(50) NOT NULL,\n    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,\n    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,\n    completed_at TIMESTAMP WITH TIME ZONE,\n    metadata JSONB,\n    metrics JSONB\n);\n\n-- Create indexes\nCREATE INDEX idx_orchestrations_status ON ralph.orchestrations(status);\nCREATE INDEX idx_orchestrations_created ON ralph.orchestrations(created_at);\nCREATE INDEX idx_orchestrations_agent ON ralph.orchestrations(agent_type);\n\n-- Audit table\nCREATE TABLE audit.activity_log (\n    id BIGSERIAL PRIMARY KEY,\n    timestamp TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,\n    user_id VARCHAR(255),\n    action VARCHAR(100),\n    resource VARCHAR(255),\n    details JSONB,\n    ip_address INET\n);\n</code></pre>"},{"location":"deployment/production/#6-monitoring-setup","title":"6. Monitoring Setup","text":""},{"location":"deployment/production/#prometheus-configuration","title":"Prometheus Configuration","text":"<pre><code># monitoring/prometheus.yaml\nglobal:\n  scrape_interval: 15s\n  evaluation_interval: 15s\n\nalerting:\n  alertmanagers:\n  - static_configs:\n    - targets:\n      - alertmanager:9093\n\nrule_files:\n  - \"alerts.yml\"\n\nscrape_configs:\n  - job_name: 'ralph-orchestrator'\n    kubernetes_sd_configs:\n    - role: pod\n      namespaces:\n        names:\n        - production\n    relabel_configs:\n    - source_labels: [__meta_kubernetes_pod_label_app]\n      action: keep\n      regex: ralph-orchestrator\n    - source_labels: [__meta_kubernetes_pod_name]\n      target_label: instance\n</code></pre>"},{"location":"deployment/production/#alert-rules","title":"Alert Rules","text":"<pre><code># monitoring/alerts.yml\ngroups:\n- name: ralph_alerts\n  interval: 30s\n  rules:\n  - alert: HighErrorRate\n    expr: rate(ralph_errors_total[5m]) &gt; 0.1\n    for: 5m\n    labels:\n      severity: critical\n    annotations:\n      summary: High error rate detected\n      description: \"Error rate is {{ $value }} errors/sec\"\n\n  - alert: HighMemoryUsage\n    expr: container_memory_usage_bytes{pod=~\"ralph-.*\"} / container_spec_memory_limit_bytes &gt; 0.9\n    for: 5m\n    labels:\n      severity: warning\n    annotations:\n      summary: High memory usage\n      description: \"Memory usage is above 90%\"\n\n  - alert: LongRunningTask\n    expr: ralph_task_duration_seconds &gt; 14400\n    for: 1m\n    labels:\n      severity: warning\n    annotations:\n      summary: Task running longer than 4 hours\n      description: \"Task {{ $labels.task_id }} has been running for {{ $value }} seconds\"\n</code></pre>"},{"location":"deployment/production/#7-backup-and-recovery","title":"7. Backup and Recovery","text":""},{"location":"deployment/production/#automated-backup-script","title":"Automated Backup Script","text":"<pre><code>#!/bin/bash\n# backup.sh\n\n# Configuration\nBACKUP_DIR=\"/backups\"\nS3_BUCKET=\"s3://ralph-backups\"\nDATE=$(date +%Y%m%d_%H%M%S)\nRETENTION_DAYS=30\n\n# Database backup\npg_dump $DATABASE_URL | gzip &gt; $BACKUP_DIR/db_$DATE.sql.gz\n\n# Application data backup\ntar -czf $BACKUP_DIR/data_$DATE.tar.gz /app/data\n\n# Upload to S3\naws s3 cp $BACKUP_DIR/db_$DATE.sql.gz $S3_BUCKET/db/\naws s3 cp $BACKUP_DIR/data_$DATE.tar.gz $S3_BUCKET/data/\n\n# Clean old backups\nfind $BACKUP_DIR -name \"*.gz\" -mtime +$RETENTION_DAYS -delete\naws s3 ls $S3_BUCKET/db/ | while read -r line; do\n  createDate=$(echo $line | awk '{print $1\" \"$2}')\n  createDate=$(date -d \"$createDate\" +%s)\n  olderThan=$(date -d \"$RETENTION_DAYS days ago\" +%s)\n  if [[ $createDate -lt $olderThan ]]; then\n    fileName=$(echo $line | awk '{print $4}')\n    aws s3 rm $S3_BUCKET/db/$fileName\n  fi\ndone\n</code></pre>"},{"location":"deployment/production/#8-security-hardening","title":"8. Security Hardening","text":""},{"location":"deployment/production/#security-policies","title":"Security Policies","text":"<pre><code># k8s/production/security.yaml\napiVersion: policy/v1beta1\nkind: PodSecurityPolicy\nmetadata:\n  name: ralph-psp\nspec:\n  privileged: false\n  allowPrivilegeEscalation: false\n  requiredDropCapabilities:\n    - ALL\n  volumes:\n    - 'configMap'\n    - 'emptyDir'\n    - 'projected'\n    - 'secret'\n    - 'persistentVolumeClaim'\n  hostNetwork: false\n  hostIPC: false\n  hostPID: false\n  runAsUser:\n    rule: 'MustRunAsNonRoot'\n  seLinux:\n    rule: 'RunAsAny'\n  supplementalGroups:\n    rule: 'RunAsAny'\n  fsGroup:\n    rule: 'RunAsAny'\n  readOnlyRootFilesystem: true\n---\napiVersion: networking.k8s.io/v1\nkind: NetworkPolicy\nmetadata:\n  name: ralph-network-policy\n  namespace: production\nspec:\n  podSelector:\n    matchLabels:\n      app: ralph-orchestrator\n  policyTypes:\n  - Ingress\n  - Egress\n  ingress:\n  - from:\n    - namespaceSelector:\n        matchLabels:\n          name: ingress-nginx\n    ports:\n    - protocol: TCP\n      port: 8080\n  egress:\n  - to:\n    - namespaceSelector: {}\n    ports:\n    - protocol: TCP\n      port: 443\n    - protocol: TCP\n      port: 5432  # PostgreSQL\n    - protocol: TCP\n      port: 6379  # Redis\n</code></pre>"},{"location":"deployment/production/#performance-optimization","title":"Performance Optimization","text":""},{"location":"deployment/production/#caching-strategy","title":"Caching Strategy","text":"<pre><code># cache_config.py\nfrom functools import lru_cache\nimport redis\nimport json\n\nclass CacheManager:\n    def __init__(self, redis_url):\n        self.redis = redis.from_url(redis_url)\n\n    def cache_result(self, key, value, ttl=3600):\n        \"\"\"Cache result with TTL\"\"\"\n        self.redis.setex(\n            key,\n            ttl,\n            json.dumps(value)\n        )\n\n    @lru_cache(maxsize=1000)\n    def get_cached(self, key):\n        \"\"\"Get cached value\"\"\"\n        value = self.redis.get(key)\n        return json.loads(value) if value else None\n</code></pre>"},{"location":"deployment/production/#database-optimization","title":"Database Optimization","text":"<pre><code>-- Optimize queries\nCREATE INDEX CONCURRENTLY idx_orchestrations_composite \nON ralph.orchestrations(agent_type, status, created_at);\n\n-- Partition large tables\nCREATE TABLE ralph.orchestrations_2024 PARTITION OF ralph.orchestrations\nFOR VALUES FROM ('2024-01-01') TO ('2025-01-01');\n\n-- Vacuum and analyze\nVACUUM ANALYZE ralph.orchestrations;\n</code></pre>"},{"location":"deployment/production/#disaster-recovery","title":"Disaster Recovery","text":""},{"location":"deployment/production/#recovery-plan","title":"Recovery Plan","text":"<ol> <li>RTO (Recovery Time Objective): 4 hours</li> <li>RPO (Recovery Point Objective): 1 hour</li> </ol>"},{"location":"deployment/production/#failover-procedure","title":"Failover Procedure","text":"<pre><code>#!/bin/bash\n# failover.sh\n\n# Check primary health\nif ! curl -f https://ralph.example.com/health; then\n  echo \"Primary unhealthy, initiating failover\"\n\n  # Update DNS to point to standby\n  aws route53 change-resource-record-sets \\\n    --hosted-zone-id Z123456 \\\n    --change-batch file://failover-dns.json\n\n  # Promote standby database\n  aws rds promote-read-replica \\\n    --db-instance-identifier ralph-standby-db\n\n  # Scale up standby region\n  kubectl scale deployment ralph-orchestrator \\\n    --replicas=5 \\\n    --context=standby-cluster\n\n  # Notify team\n  aws sns publish \\\n    --topic-arn arn:aws:sns:region:account:alerts \\\n    --message \"Failover initiated to standby region\"\nfi\n</code></pre>"},{"location":"deployment/production/#maintenance","title":"Maintenance","text":""},{"location":"deployment/production/#rolling-updates","title":"Rolling Updates","text":"<pre><code># Zero-downtime deployment\nkubectl set image deployment/ralph-orchestrator \\\n  ralph=ghcr.io/mikeyobrien/ralph-orchestrator:v1.0.1 \\\n  --record\n\n# Monitor rollout\nkubectl rollout status deployment/ralph-orchestrator\n\n# Rollback if needed\nkubectl rollout undo deployment/ralph-orchestrator\n</code></pre>"},{"location":"deployment/production/#health-checks","title":"Health Checks","text":"<pre><code># health.py\nfrom flask import Flask, jsonify\nimport psutil\nimport redis\n\napp = Flask(__name__)\n\n@app.route('/health')\ndef health():\n    \"\"\"Health check endpoint\"\"\"\n    checks = {\n        'database': check_database(),\n        'redis': check_redis(),\n        'disk': check_disk_space(),\n        'memory': check_memory()\n    }\n\n    status = 'healthy' if all(checks.values()) else 'unhealthy'\n    return jsonify({\n        'status': status,\n        'checks': checks\n    }), 200 if status == 'healthy' else 503\n\ndef check_database():\n    try:\n        db.session.execute('SELECT 1')\n        return True\n    except:\n        return False\n\ndef check_redis():\n    try:\n        r = redis.from_url(REDIS_URL)\n        r.ping()\n        return True\n    except:\n        return False\n\ndef check_disk_space():\n    usage = psutil.disk_usage('/')\n    return usage.percent &lt; 90\n\ndef check_memory():\n    usage = psutil.virtual_memory()\n    return usage.percent &lt; 90\n</code></pre>"},{"location":"deployment/production/#production-checklist","title":"Production Checklist","text":""},{"location":"deployment/production/#pre-deployment","title":"Pre-Deployment","text":"<ul> <li> All tests passing</li> <li> Security scan completed</li> <li> Performance testing done</li> <li> Documentation updated</li> <li> Runbook created</li> <li> Rollback plan ready</li> </ul>"},{"location":"deployment/production/#deployment","title":"Deployment","text":"<ul> <li> Database migrations run</li> <li> Secrets configured</li> <li> Monitoring enabled</li> <li> Alerts configured</li> <li> Health checks passing</li> <li> Load balancer configured</li> </ul>"},{"location":"deployment/production/#post-deployment","title":"Post-Deployment","text":"<ul> <li> Smoke tests passed</li> <li> Performance metrics normal</li> <li> Error rates acceptable</li> <li> User acceptance testing</li> <li> Documentation published</li> <li> Team notified</li> </ul>"},{"location":"deployment/production/#support-and-maintenance","title":"Support and Maintenance","text":""},{"location":"deployment/production/#sla-targets","title":"SLA Targets","text":"<ul> <li>Uptime: 99.9% (43.8 minutes downtime/month)</li> <li>Response Time: &lt; 500ms p95</li> <li>Error Rate: &lt; 0.1%</li> <li>Recovery Time: &lt; 4 hours</li> </ul>"},{"location":"deployment/production/#on-call-procedures","title":"On-Call Procedures","text":"<ol> <li>Alert received via PagerDuty</li> <li>Check runbook for known issues</li> <li>Assess severity and impact</li> <li>Implement fix or workaround</li> <li>Document incident</li> <li>Post-mortem if needed</li> </ol>"},{"location":"deployment/production/#next-steps","title":"Next Steps","text":"<ul> <li>Monitoring Guide - Set up comprehensive monitoring</li> <li>Security Best Practices - Security hardening</li> <li>Troubleshooting Guide - Common issues and solutions</li> </ul>"},{"location":"examples/","title":"Examples","text":"<p>Learn how to use Ralph Orchestrator through practical examples.</p>"},{"location":"examples/#quick-examples","title":"Quick Examples","text":""},{"location":"examples/#hello-world","title":"Hello World","text":"<p>The simplest possible Ralph task:</p> <pre><code># PROMPT.md\nWrite a Python function that prints \"Hello, World!\"\nSave it to hello.py and add TASK_COMPLETE when done.\n</code></pre> <p>Run with: <pre><code>python ralph_orchestrator.py --prompt PROMPT.md --max-iterations 5\n</code></pre></p>"},{"location":"examples/#basic-math-function","title":"Basic Math Function","text":"<p>Generate a calculator module:</p> <pre><code># PROMPT.md\nCreate a Python calculator module with:\n- Functions for add, subtract, multiply, divide\n- Error handling for division by zero\n- Docstrings for all functions\n- Save to calculator.py\n\nWhen complete, add TASK_COMPLETE.\n</code></pre>"},{"location":"examples/#complete-examples","title":"Complete Examples","text":"<p>Explore our detailed example guides:</p>"},{"location":"examples/#simple-task","title":"\ud83d\udcdd Simple Task","text":"<p>Build a command-line todo list application with file persistence.</p>"},{"location":"examples/#web-api","title":"\ud83c\udf10 Web API","text":"<p>Create a RESTful API with Flask, including authentication and database integration.</p>"},{"location":"examples/#cli-tool","title":"\ud83d\udee0\ufe0f CLI Tool","text":"<p>Develop a feature-rich command-line tool with argument parsing and configuration.</p>"},{"location":"examples/#data-analysis","title":"\ud83d\udcca Data Analysis","text":"<p>Process CSV data, generate statistics, and create visualizations.</p>"},{"location":"examples/#example-categories","title":"Example Categories","text":""},{"location":"examples/#code-generation","title":"Code Generation","text":"<p>Use Case: Automatically generate boilerplate code, utilities, or entire modules.</p> <pre><code>Create a Python logging utility with:\n- Colored console output\n- File rotation\n- JSON formatting option\n- Multiple log levels\n</code></pre>"},{"location":"examples/#testing","title":"Testing","text":"<p>Use Case: Generate comprehensive test suites for existing code.</p> <pre><code>Write pytest tests for the user_auth.py module:\n- Test all public functions\n- Include edge cases\n- Mock external dependencies\n- Aim for 100% coverage\n</code></pre>"},{"location":"examples/#documentation","title":"Documentation","text":"<p>Use Case: Create or update project documentation.</p> <pre><code>Generate comprehensive API documentation for this project:\n- Document all public classes and functions\n- Include usage examples\n- Create a getting started guide\n- Format as Markdown\n</code></pre>"},{"location":"examples/#refactoring","title":"Refactoring","text":"<p>Use Case: Improve code quality and structure.</p> <pre><code>Refactor the data_processor.py file:\n- Split large functions (&gt;50 lines)\n- Extract common patterns\n- Add type hints\n- Improve variable names\n- Maintain functionality\n</code></pre>"},{"location":"examples/#bug-fixing","title":"Bug Fixing","text":"<p>Use Case: Identify and fix issues in code.</p> <pre><code>Debug and fix the payment processing module:\n- The calculate_tax() function returns wrong values\n- Payment status isn't updating correctly\n- Add logging to trace the issue\n- Write tests to prevent regression\n</code></pre>"},{"location":"examples/#data-processing","title":"Data Processing","text":"<p>Use Case: Transform and analyze data files.</p> <pre><code>Process sales_data.csv:\n- Clean missing values\n- Calculate monthly totals\n- Find top 10 products\n- Generate summary statistics\n- Export results to report.json\n</code></pre>"},{"location":"examples/#best-practices-for-examples","title":"Best Practices for Examples","text":""},{"location":"examples/#1-clear-objectives","title":"1. Clear Objectives","text":"<p>Always specify exactly what you want:</p> <p>\u2705 Good: <pre><code>Create a REST API endpoint that:\n- Accepts POST requests to /api/users\n- Validates email and password\n- Returns JWT token on success\n- Uses SQLite for storage\n</code></pre></p> <p>\u274c Bad: <pre><code>Make a user API\n</code></pre></p>"},{"location":"examples/#2-include-constraints","title":"2. Include Constraints","text":"<p>Specify limitations and requirements:</p> <pre><code>Build a web scraper that:\n- Uses only standard library (no pip installs)\n- Respects robots.txt\n- Implements rate limiting (1 request/second)\n- Handles errors gracefully\n</code></pre>"},{"location":"examples/#3-define-success-criteria","title":"3. Define Success Criteria","text":"<p>Make completion conditions explicit:</p> <pre><code>Task is complete when:\n1. All tests pass (run: pytest test_calculator.py)\n2. Code follows PEP 8 (run: flake8 calculator.py)\n3. Documentation is complete\n4. TASK_COMPLETE is added to this file\n</code></pre>"},{"location":"examples/#4-provide-context","title":"4. Provide Context","text":"<p>Include relevant information:</p> <pre><code>Context: We're building a microservice for order processing.\nExisting files: models.py, database.py\n\nCreate an order validation module that:\n- Integrates with existing models\n- Validates against business rules\n- Returns detailed error messages\n</code></pre>"},{"location":"examples/#running-examples","title":"Running Examples","text":""},{"location":"examples/#basic-execution","title":"Basic Execution","text":"<pre><code># Run with default settings\npython ralph_orchestrator.py --prompt examples/simple-task.md\n</code></pre>"},{"location":"examples/#with-cost-limits","title":"With Cost Limits","text":"<pre><code># Limit spending\npython ralph_orchestrator.py \\\n  --prompt examples/web-api.md \\\n  --max-cost 5.0 \\\n  --max-tokens 100000\n</code></pre>"},{"location":"examples/#using-specific-agents","title":"Using Specific Agents","text":"<pre><code># Use Claude for complex tasks\npython ralph_orchestrator.py \\\n  --agent claude \\\n  --prompt examples/cli-tool.md\n\n# Use Gemini for research tasks\npython ralph_orchestrator.py \\\n  --agent gemini \\\n  --prompt examples/data-analysis.md\n</code></pre>"},{"location":"examples/#development-mode","title":"Development Mode","text":"<pre><code># Verbose output with frequent checkpoints\npython ralph_orchestrator.py \\\n  --prompt examples/simple-task.md \\\n  --verbose \\\n  --checkpoint-interval 1 \\\n  --max-iterations 10\n</code></pre>"},{"location":"examples/#example-prompt-templates","title":"Example Prompt Templates","text":""},{"location":"examples/#web-application","title":"Web Application","text":"<p><pre><code># Task: Create [Application Name]\n\n## Requirements\n- Framework: [Flask/FastAPI/Django]\n- Database: [SQLite/PostgreSQL/MongoDB]\n- Authentication: [JWT/Session/OAuth]\n\n## Features\n1. [Feature 1]\n2. [Feature 2]\n3. [Feature 3]\n\n## File Structure\n</code></pre> project/ \u251c\u2500\u2500 app.py \u251c\u2500\u2500 models.py \u251c\u2500\u2500 routes.py \u2514\u2500\u2500 tests/ <pre><code>## Completion Criteria\n- All endpoints working\n- Tests passing\n- Documentation complete\n- TASK_COMPLETE added\n</code></pre></p>"},{"location":"examples/#data-processing_1","title":"Data Processing","text":"<pre><code># Task: Process [Data Description]\n\n## Input\n- File: [filename.csv]\n- Format: [CSV/JSON/XML]\n- Size: [approximate size]\n\n## Processing Steps\n1. [Step 1: Load and validate]\n2. [Step 2: Clean and transform]\n3. [Step 3: Analyze]\n4. [Step 4: Export results]\n\n## Output\n- Format: [JSON/CSV/Report]\n- Include: [metrics, visualizations, etc.]\n\n## Success Criteria\n- No errors during processing\n- Output validates against schema\n- Performance: &lt; [X] seconds\n- TASK_COMPLETE added\n</code></pre>"},{"location":"examples/#cli-tool_1","title":"CLI Tool","text":"<pre><code># Task: Build [Tool Name] CLI\n\n## Commands\n- `tool command1` - [description]\n- `tool command2` - [description]\n\n## Options\n- `--option1` - [description]\n- `--option2` - [description]\n\n## Requirements\n- Argument parsing with argparse\n- Configuration file support\n- Colored output\n- Progress bars for long operations\n\n## Examples\n```bash\ntool process --input file.txt --output result.json\ntool analyze --verbose\n</code></pre>"},{"location":"examples/#completion","title":"Completion","text":"<ul> <li>All commands working</li> <li>Help text complete</li> <li>Error handling robust</li> <li>TASK_COMPLETE added ```</li> </ul>"},{"location":"examples/#learning-from-examples","title":"Learning from Examples","text":""},{"location":"examples/#study-the-patterns","title":"Study the Patterns","text":"<ol> <li>Prompt Structure: How successful prompts are organized</li> <li>Iteration Counts: Typical iterations for different task types</li> <li>Token Usage: Costs for various complexities</li> <li>Completion Time: Expected runtime for tasks</li> </ol>"},{"location":"examples/#experiment","title":"Experiment","text":"<ol> <li>Start with provided examples</li> <li>Modify them for your needs</li> <li>Compare different approaches</li> <li>Share successful patterns</li> </ol>"},{"location":"examples/#contributing-examples","title":"Contributing Examples","text":"<p>Have a great example? Share it:</p> <ol> <li>Create a new example file</li> <li>Document the use case</li> <li>Include expected results</li> <li>Submit a pull request</li> </ol>"},{"location":"examples/#troubleshooting-examples","title":"Troubleshooting Examples","text":""},{"location":"examples/#task-not-completing","title":"Task Not Completing","text":"<p>If examples run indefinitely: - Check completion criteria clarity - Verify agent can modify files - Review iteration logs - Adjust max iterations</p>"},{"location":"examples/#high-costs","title":"High Costs","text":"<p>If examples are expensive: - Use simpler prompts - Set token limits - Choose appropriate agents - Enable context management</p>"},{"location":"examples/#poor-results","title":"Poor Results","text":"<p>If output quality is low: - Provide more context - Include examples in prompt - Specify constraints clearly - Use more capable agents</p>"},{"location":"examples/#next-steps","title":"Next Steps","text":"<ul> <li>Try the Simple Task Example</li> <li>Explore Web API Example</li> <li>Build a CLI Tool</li> <li>Analyze Data</li> </ul> <p>\ud83d\udcda Continue to Simple Task Example \u2192</p>"},{"location":"examples/bug-fix/","title":"Bug Fixing Examples","text":""},{"location":"examples/bug-fix/#overview","title":"Overview","text":"<p>This guide demonstrates how to use Ralph Orchestrator for debugging and fixing code issues.</p>"},{"location":"examples/bug-fix/#example-1-null-pointer-exception","title":"Example 1: Null Pointer Exception","text":""},{"location":"examples/bug-fix/#problem-code","title":"Problem Code","text":"<pre><code>def calculate_average(numbers):\n    total = sum(numbers)\n    return total / len(numbers)\n\n# This crashes with: TypeError: unsupported operand type(s)\nresult = calculate_average(None)\n</code></pre>"},{"location":"examples/bug-fix/#fix-request","title":"Fix Request","text":"<pre><code>prompt = \"\"\"\nFix this function that crashes when passed None:\n\ndef calculate_average(numbers):\n    total = sum(numbers)\n    return total / len(numbers)\n\nThe function should handle None, empty lists, and non-numeric values gracefully.\n\"\"\"\n\nresponse = orchestrator.execute(prompt, agent=\"claude\")\n</code></pre>"},{"location":"examples/bug-fix/#fixed-code","title":"Fixed Code","text":"<pre><code>def calculate_average(numbers):\n    \"\"\"\n    Calculate the average of a list of numbers.\n\n    Args:\n        numbers: List of numeric values or None\n\n    Returns:\n        float: Average value, or None if input is invalid\n    \"\"\"\n    # Handle None input\n    if numbers is None:\n        return None\n\n    # Handle empty list\n    if not numbers:\n        return 0\n\n    # Filter out non-numeric values\n    numeric_values = []\n    for num in numbers:\n        try:\n            numeric_values.append(float(num))\n        except (TypeError, ValueError):\n            continue\n\n    # Return None if no valid numbers found\n    if not numeric_values:\n        return None\n\n    return sum(numeric_values) / len(numeric_values)\n</code></pre>"},{"location":"examples/bug-fix/#example-2-memory-leak-fix","title":"Example 2: Memory Leak Fix","text":""},{"location":"examples/bug-fix/#problem-code_1","title":"Problem Code","text":"<pre><code>class EventManager {\n    constructor() {\n        this.events = {};\n    }\n\n    on(event, callback) {\n        if (!this.events[event]) {\n            this.events[event] = [];\n        }\n        this.events[event].push(callback);\n    }\n\n    emit(event, data) {\n        if (this.events[event]) {\n            this.events[event].forEach(cb =&gt; cb(data));\n        }\n    }\n}\n</code></pre>"},{"location":"examples/bug-fix/#fix-request_1","title":"Fix Request","text":"<pre><code>prompt = \"\"\"\nFix the memory leak in this JavaScript EventManager class. \nThe class never removes event listeners, causing memory leaks.\nAdd an 'off' method and ensure proper cleanup.\n\"\"\"\n\nresponse = orchestrator.execute(prompt, agent=\"claude\")\n</code></pre>"},{"location":"examples/bug-fix/#fixed-code_1","title":"Fixed Code","text":"<pre><code>class EventManager {\n    constructor() {\n        this.events = {};\n        this.eventIds = new WeakMap();\n        this.nextId = 0;\n    }\n\n    on(event, callback) {\n        if (!this.events[event]) {\n            this.events[event] = [];\n        }\n\n        // Store callback with unique ID for removal\n        const id = this.nextId++;\n        const callbackWrapper = { id, callback };\n        this.events[event].push(callbackWrapper);\n        this.eventIds.set(callback, id);\n\n        // Return unsubscribe function\n        return () =&gt; this.off(event, callback);\n    }\n\n    off(event, callback) {\n        if (!this.events[event]) return;\n\n        const id = this.eventIds.get(callback);\n        if (id !== undefined) {\n            this.events[event] = this.events[event].filter(\n                wrapper =&gt; wrapper.id !== id\n            );\n            this.eventIds.delete(callback);\n\n            // Clean up empty event arrays\n            if (this.events[event].length === 0) {\n                delete this.events[event];\n            }\n        }\n    }\n\n    emit(event, data) {\n        if (this.events[event]) {\n            this.events[event].forEach(wrapper =&gt; \n                wrapper.callback(data)\n            );\n        }\n    }\n\n    // Clear all listeners for an event\n    removeAllListeners(event) {\n        if (event) {\n            delete this.events[event];\n        } else {\n            this.events = {};\n        }\n    }\n\n    // Cleanup method for destroying the instance\n    destroy() {\n        this.events = {};\n        this.eventIds = new WeakMap();\n    }\n}\n</code></pre>"},{"location":"examples/bug-fix/#example-3-race-condition-fix","title":"Example 3: Race Condition Fix","text":""},{"location":"examples/bug-fix/#problem-code_2","title":"Problem Code","text":"<pre><code>import threading\n\nclass Counter:\n    def __init__(self):\n        self.count = 0\n\n    def increment(self):\n        temp = self.count\n        # Simulating some processing\n        temp = temp + 1\n        self.count = temp\n</code></pre>"},{"location":"examples/bug-fix/#fix-request_2","title":"Fix Request","text":"<pre><code>prompt = \"\"\"\nFix the race condition in this Counter class that occurs when \nmultiple threads call increment() simultaneously.\n\"\"\"\n\nresponse = orchestrator.execute(prompt, agent=\"claude\")\n</code></pre>"},{"location":"examples/bug-fix/#fixed-code_2","title":"Fixed Code","text":"<pre><code>import threading\nfrom contextlib import contextmanager\n\nclass Counter:\n    def __init__(self):\n        self.count = 0\n        self._lock = threading.Lock()\n\n    def increment(self):\n        \"\"\"Thread-safe increment operation.\"\"\"\n        with self._lock:\n            temp = self.count\n            # Simulating some processing\n            temp = temp + 1\n            self.count = temp\n\n    def decrement(self):\n        \"\"\"Thread-safe decrement operation.\"\"\"\n        with self._lock:\n            self.count -= 1\n\n    def get_value(self):\n        \"\"\"Thread-safe read operation.\"\"\"\n        with self._lock:\n            return self.count\n\n    @contextmanager\n    def batch_operation(self):\n        \"\"\"Context manager for batch operations.\"\"\"\n        self._lock.acquire()\n        try:\n            yield self\n        finally:\n            self._lock.release()\n\n# Usage example:\ncounter = Counter()\n\n# Batch operations\nwith counter.batch_operation():\n    for _ in range(100):\n        counter.count += 1  # Direct access within context\n</code></pre>"},{"location":"examples/bug-fix/#example-4-sql-injection-vulnerability","title":"Example 4: SQL Injection Vulnerability","text":""},{"location":"examples/bug-fix/#problem-code_3","title":"Problem Code","text":"<pre><code>def get_user(user_id):\n    query = f\"SELECT * FROM users WHERE id = {user_id}\"\n    return db.execute(query)\n</code></pre>"},{"location":"examples/bug-fix/#fix-request_3","title":"Fix Request","text":"<pre><code>prompt = \"\"\"\nFix the SQL injection vulnerability in this function.\nUse parameterized queries and add input validation.\n\"\"\"\n\nresponse = orchestrator.execute(prompt, agent=\"claude\")\n</code></pre>"},{"location":"examples/bug-fix/#fixed-code_3","title":"Fixed Code","text":"<pre><code>def get_user(user_id):\n    \"\"\"\n    Safely retrieve user by ID with SQL injection protection.\n\n    Args:\n        user_id: User identifier (int or string)\n\n    Returns:\n        dict: User data or None if not found\n\n    Raises:\n        ValueError: If user_id is invalid\n    \"\"\"\n    # Input validation\n    if user_id is None:\n        raise ValueError(\"User ID cannot be None\")\n\n    try:\n        # Convert to integer to ensure type safety\n        user_id = int(user_id)\n    except (ValueError, TypeError):\n        raise ValueError(f\"Invalid user ID: {user_id}\")\n\n    # Additional validation\n    if user_id &lt;= 0:\n        raise ValueError(\"User ID must be positive\")\n\n    # Use parameterized query to prevent SQL injection\n    query = \"SELECT * FROM users WHERE id = %s\"\n\n    try:\n        result = db.execute(query, (user_id,))\n        return result.fetchone()\n    except DatabaseError as e:\n        logger.error(f\"Database error fetching user {user_id}: {e}\")\n        return None\n\n# Additional secure version using ORM\ndef get_user_orm(user_id):\n    \"\"\"ORM-based user retrieval (recommended).\"\"\"\n    try:\n        user_id = int(user_id)\n        return User.query.filter_by(id=user_id).first()\n    except (ValueError, TypeError):\n        return None\n</code></pre>"},{"location":"examples/bug-fix/#example-5-infinite-loop-fix","title":"Example 5: Infinite Loop Fix","text":""},{"location":"examples/bug-fix/#problem-code_4","title":"Problem Code","text":"<pre><code>def find_target(arr, target):\n    left = 0\n    right = len(arr) - 1\n\n    while left &lt; right:\n        mid = (left + right) // 2\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] &lt; target:\n            left = mid  # Bug: should be mid + 1\n        else:\n            right = mid\n\n    return -1\n</code></pre>"},{"location":"examples/bug-fix/#fix-request_4","title":"Fix Request","text":"<pre><code>prompt = \"\"\"\nFix the infinite loop bug in this binary search implementation.\nThe function gets stuck when the target is not in the array.\n\"\"\"\n\nresponse = orchestrator.execute(prompt, agent=\"claude\")\n</code></pre>"},{"location":"examples/bug-fix/#fixed-code_4","title":"Fixed Code","text":"<pre><code>def find_target(arr, target):\n    \"\"\"\n    Binary search implementation with infinite loop fix.\n\n    Args:\n        arr: Sorted array to search\n        target: Value to find\n\n    Returns:\n        int: Index of target or -1 if not found\n    \"\"\"\n    if not arr:\n        return -1\n\n    left = 0\n    right = len(arr) - 1\n\n    while left &lt;= right:  # Changed condition to include equality\n        mid = (left + right) // 2\n\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] &lt; target:\n            left = mid + 1  # Fixed: increment to avoid infinite loop\n        else:\n            right = mid - 1  # Fixed: decrement for consistency\n\n    return -1\n\n# Enhanced version with additional features\ndef find_target_enhanced(arr, target, return_insertion_point=False):\n    \"\"\"\n    Enhanced binary search with insertion point option.\n\n    Args:\n        arr: Sorted array to search\n        target: Value to find\n        return_insertion_point: If True, return where target should be inserted\n\n    Returns:\n        int: Index of target, or insertion point if not found and requested\n    \"\"\"\n    if not arr:\n        return 0 if return_insertion_point else -1\n\n    left = 0\n    right = len(arr) - 1\n\n    while left &lt;= right:\n        mid = (left + right) // 2\n\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] &lt; target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return left if return_insertion_point else -1\n</code></pre>"},{"location":"examples/bug-fix/#common-bug-patterns-and-fixes","title":"Common Bug Patterns and Fixes","text":""},{"location":"examples/bug-fix/#1-off-by-one-errors","title":"1. Off-by-One Errors","text":"<ul> <li>Check array bounds</li> <li>Verify loop conditions</li> <li>Test edge cases (empty, single element)</li> </ul>"},{"location":"examples/bug-fix/#2-nullundefined-handling","title":"2. Null/Undefined Handling","text":"<ul> <li>Add null checks at function entry</li> <li>Use optional chaining in JavaScript</li> <li>Provide sensible defaults</li> </ul>"},{"location":"examples/bug-fix/#3-resource-leaks","title":"3. Resource Leaks","text":"<ul> <li>Implement proper cleanup (close files, connections)</li> <li>Use context managers in Python</li> <li>Add finally blocks for cleanup</li> </ul>"},{"location":"examples/bug-fix/#4-concurrency-issues","title":"4. Concurrency Issues","text":"<ul> <li>Use locks for shared resources</li> <li>Implement atomic operations</li> <li>Consider using thread-safe data structures</li> </ul>"},{"location":"examples/bug-fix/#5-type-errors","title":"5. Type Errors","text":"<ul> <li>Add type checking/validation</li> <li>Use TypeScript/type hints</li> <li>Handle type conversions explicitly</li> </ul>"},{"location":"examples/bug-fix/#debugging-tips","title":"Debugging Tips","text":"<ol> <li>Reproduce First: Always reproduce the bug before fixing</li> <li>Add Logging: Insert strategic logging to understand flow</li> <li>Unit Tests: Write tests that expose the bug</li> <li>Edge Cases: Test with empty, null, and boundary values</li> <li>Code Review: Have the fix reviewed by others</li> </ol>"},{"location":"examples/bug-fix/#see-also","title":"See Also","text":"<ul> <li>Testing Examples</li> <li>Code Review Guide</li> <li>Error Handling Best Practices</li> </ul>"},{"location":"examples/cli-tool/","title":"Building a CLI Tool with Ralph","text":"<p>This example shows how to use Ralph Orchestrator to create a command-line tool with argparse, subcommands, and proper packaging.</p>"},{"location":"examples/cli-tool/#task-description","title":"Task Description","text":"<p>Create a Python CLI tool for file management with: - Multiple subcommands - Progress bars - Configuration file support - Error handling - Installation script</p>"},{"location":"examples/cli-tool/#promptmd-file","title":"PROMPT.md File","text":"<p><pre><code># Task: Build File Manager CLI Tool\n\nCreate a Python CLI tool called 'fman' with the following features:\n\n## Commands\n\n1. **list** - List files in directory\n   - Options: --all, --size, --date\n   - Show file sizes and modification dates\n\n2. **search** - Search for files\n   - Options: --name, --extension, --content\n   - Support wildcards and regex\n\n3. **copy** - Copy files/directories\n   - Show progress bar for large files\n   - Options: --recursive, --overwrite\n\n4. **move** - Move files/directories\n   - Confirm before overwriting\n   - Options: --force\n\n5. **delete** - Delete files/directories\n   - Require confirmation\n   - Options: --force, --recursive\n\n## Requirements\n\n- Use argparse for CLI parsing\n- Use click or rich for better UX\n- Progress bars with tqdm\n- Colored output\n- Configuration file support (~/.fmanrc)\n- Comprehensive error handling\n- Unit tests\n- Setup.py for installation\n\n## Project Structure\n</code></pre> file-manager-cli/ \u251c\u2500\u2500 fman/ \u2502   \u251c\u2500\u2500 init.py \u2502   \u251c\u2500\u2500 main.py      # Entry point \u2502   \u251c\u2500\u2500 cli.py           # CLI interface \u2502   \u251c\u2500\u2500 commands/        # Command implementations \u2502   \u2502   \u251c\u2500\u2500 init.py \u2502   \u2502   \u251c\u2500\u2500 list_cmd.py \u2502   \u2502   \u251c\u2500\u2500 search_cmd.py \u2502   \u2502   \u251c\u2500\u2500 copy_cmd.py \u2502   \u2502   \u251c\u2500\u2500 move_cmd.py \u2502   \u2502   \u2514\u2500\u2500 delete_cmd.py \u2502   \u251c\u2500\u2500 utils.py         # Utility functions \u2502   \u2514\u2500\u2500 config.py        # Configuration handling \u251c\u2500\u2500 tests/ \u2502   \u2514\u2500\u2500 test_commands.py \u251c\u2500\u2500 setup.py \u251c\u2500\u2500 requirements.txt \u2514\u2500\u2500 README.md <pre><code>&lt;!-- TASK_COMPLETE will be added when done --&gt;\n</code></pre></p>"},{"location":"examples/cli-tool/#running-ralph","title":"Running Ralph","text":"<pre><code># Initialize and run\nralph init\ncp cli-tool-prompt.md PROMPT.md\nralph run --agent claude --max-iterations 40\n</code></pre>"},{"location":"examples/cli-tool/#expected-output","title":"Expected Output","text":""},{"location":"examples/cli-tool/#fmanclipy","title":"fman/cli.py","text":"<pre><code>#!/usr/bin/env python3\nimport argparse\nimport sys\nfrom pathlib import Path\nfrom rich.console import Console\nfrom rich.table import Table\n\nfrom fman.commands import (\n    list_cmd, search_cmd, copy_cmd, \n    move_cmd, delete_cmd\n)\nfrom fman.config import load_config\n\nconsole = Console()\n\ndef create_parser():\n    \"\"\"Create argument parser\"\"\"\n    parser = argparse.ArgumentParser(\n        prog='fman',\n        description='File Manager CLI Tool',\n        formatter_class=argparse.RawDescriptionHelpFormatter\n    )\n\n    parser.add_argument(\n        '--version',\n        action='version',\n        version='%(prog)s 1.0.0'\n    )\n\n    parser.add_argument(\n        '--config',\n        help='Config file path',\n        default='~/.fmanrc'\n    )\n\n    subparsers = parser.add_subparsers(\n        dest='command',\n        help='Available commands'\n    )\n\n    # List command\n    list_parser = subparsers.add_parser(\n        'list',\n        help='List files in directory'\n    )\n    list_parser.add_argument(\n        'path',\n        nargs='?',\n        default='.',\n        help='Directory path'\n    )\n    list_parser.add_argument(\n        '--all', '-a',\n        action='store_true',\n        help='Show hidden files'\n    )\n    list_parser.add_argument(\n        '--size', '-s',\n        action='store_true',\n        help='Sort by size'\n    )\n    list_parser.add_argument(\n        '--date', '-d',\n        action='store_true',\n        help='Sort by date'\n    )\n\n    # Search command\n    search_parser = subparsers.add_parser(\n        'search',\n        help='Search for files'\n    )\n    search_parser.add_argument(\n        'pattern',\n        help='Search pattern'\n    )\n    search_parser.add_argument(\n        '--path', '-p',\n        default='.',\n        help='Search path'\n    )\n    search_parser.add_argument(\n        '--name', '-n',\n        action='store_true',\n        help='Search in filenames'\n    )\n    search_parser.add_argument(\n        '--content', '-c',\n        action='store_true',\n        help='Search in file contents'\n    )\n    search_parser.add_argument(\n        '--extension', '-e',\n        help='Filter by extension'\n    )\n\n    # Copy command\n    copy_parser = subparsers.add_parser(\n        'copy',\n        help='Copy files or directories'\n    )\n    copy_parser.add_argument('source', help='Source path')\n    copy_parser.add_argument('dest', help='Destination path')\n    copy_parser.add_argument(\n        '--recursive', '-r',\n        action='store_true',\n        help='Copy recursively'\n    )\n    copy_parser.add_argument(\n        '--overwrite', '-o',\n        action='store_true',\n        help='Overwrite existing files'\n    )\n\n    # Move command\n    move_parser = subparsers.add_parser(\n        'move',\n        help='Move files or directories'\n    )\n    move_parser.add_argument('source', help='Source path')\n    move_parser.add_argument('dest', help='Destination path')\n    move_parser.add_argument(\n        '--force', '-f',\n        action='store_true',\n        help='Force move without confirmation'\n    )\n\n    # Delete command\n    delete_parser = subparsers.add_parser(\n        'delete',\n        help='Delete files or directories'\n    )\n    delete_parser.add_argument(\n        'path',\n        nargs='+',\n        help='Path(s) to delete'\n    )\n    delete_parser.add_argument(\n        '--force', '-f',\n        action='store_true',\n        help='Force delete without confirmation'\n    )\n    delete_parser.add_argument(\n        '--recursive', '-r',\n        action='store_true',\n        help='Delete directories recursively'\n    )\n\n    return parser\n\ndef main():\n    \"\"\"Main entry point\"\"\"\n    parser = create_parser()\n    args = parser.parse_args()\n\n    # Load configuration\n    config = load_config(args.config)\n\n    # Execute command\n    commands = {\n        'list': list_cmd.execute,\n        'search': search_cmd.execute,\n        'copy': copy_cmd.execute,\n        'move': move_cmd.execute,\n        'delete': delete_cmd.execute\n    }\n\n    if args.command:\n        try:\n            result = commands[args.command](args, config)\n            sys.exit(0 if result else 1)\n        except KeyboardInterrupt:\n            console.print(\"\\n[yellow]Interrupted by user[/yellow]\")\n            sys.exit(130)\n        except Exception as e:\n            console.print(f\"[red]Error: {e}[/red]\")\n            sys.exit(1)\n    else:\n        parser.print_help()\n        sys.exit(0)\n\nif __name__ == '__main__':\n    main()\n</code></pre>"},{"location":"examples/cli-tool/#fmancommandslist_cmdpy","title":"fman/commands/list_cmd.py","text":"<pre><code>import os\nfrom pathlib import Path\nfrom datetime import datetime\nfrom rich.console import Console\nfrom rich.table import Table\nfrom rich.filesize import decimal\n\nconsole = Console()\n\ndef execute(args, config):\n    \"\"\"Execute list command\"\"\"\n    path = Path(args.path).expanduser().resolve()\n\n    if not path.exists():\n        console.print(f\"[red]Error: Path '{path}' does not exist[/red]\")\n        return False\n\n    if not path.is_dir():\n        console.print(f\"[red]Error: '{path}' is not a directory[/red]\")\n        return False\n\n    # Get files\n    if args.all:\n        files = list(path.iterdir())\n    else:\n        files = [f for f in path.iterdir() if not f.name.startswith('.')]\n\n    # Sort files\n    if args.size:\n        files.sort(key=lambda f: f.stat().st_size if f.is_file() else 0, \n                  reverse=True)\n    elif args.date:\n        files.sort(key=lambda f: f.stat().st_mtime, reverse=True)\n    else:\n        files.sort(key=lambda f: f.name.lower())\n\n    # Create table\n    table = Table(title=f\"Files in {path}\")\n    table.add_column(\"Name\", style=\"cyan\")\n    table.add_column(\"Type\", style=\"magenta\")\n    table.add_column(\"Size\", justify=\"right\", style=\"green\")\n    table.add_column(\"Modified\", style=\"yellow\")\n\n    for file in files:\n        stat = file.stat()\n\n        # Determine type\n        if file.is_dir():\n            file_type = \"DIR\"\n            size = \"-\"\n        elif file.is_symlink():\n            file_type = \"LINK\"\n            size = \"-\"\n        else:\n            file_type = \"FILE\"\n            size = decimal(stat.st_size)\n\n        # Format modification time\n        mtime = datetime.fromtimestamp(stat.st_mtime)\n        mtime_str = mtime.strftime(\"%Y-%m-%d %H:%M\")\n\n        table.add_row(\n            file.name,\n            file_type,\n            size,\n            mtime_str\n        )\n\n    console.print(table)\n    return True\n</code></pre>"},{"location":"examples/cli-tool/#fmancommandscopy_cmdpy","title":"fman/commands/copy_cmd.py","text":"<pre><code>import shutil\nfrom pathlib import Path\nfrom tqdm import tqdm\nfrom rich.console import Console\n\nconsole = Console()\n\ndef copy_with_progress(src, dst):\n    \"\"\"Copy file with progress bar\"\"\"\n    src_size = src.stat().st_size\n\n    with tqdm(total=src_size, unit='B', unit_scale=True, \n              desc=f\"Copying {src.name}\") as pbar:\n        def callback(copied, total):\n            pbar.update(copied - pbar.n)\n\n        # For large files, use callback\n        if src_size &gt; 1024 * 1024:  # 1MB\n            with open(src, 'rb') as fsrc:\n                with open(dst, 'wb') as fdst:\n                    copied = 0\n                    while True:\n                        buf = fsrc.read(1024 * 64)  # 64KB chunks\n                        if not buf:\n                            break\n                        fdst.write(buf)\n                        copied += len(buf)\n                        callback(copied, src_size)\n        else:\n            shutil.copy2(src, dst)\n            callback(src_size, src_size)\n\ndef execute(args, config):\n    \"\"\"Execute copy command\"\"\"\n    source = Path(args.source).expanduser().resolve()\n    dest = Path(args.dest).expanduser().resolve()\n\n    if not source.exists():\n        console.print(f\"[red]Error: Source '{source}' does not exist[/red]\")\n        return False\n\n    # Handle directory copy\n    if source.is_dir():\n        if not args.recursive:\n            console.print(\"[red]Error: Use -r to copy directories[/red]\")\n            return False\n\n        if dest.exists() and not args.overwrite:\n            response = console.input(\n                f\"[yellow]'{dest}' exists. Overwrite? [y/N]:[/yellow] \"\n            )\n            if response.lower() != 'y':\n                console.print(\"[yellow]Copy cancelled[/yellow]\")\n                return False\n\n        console.print(f\"Copying directory '{source}' to '{dest}'...\")\n        shutil.copytree(source, dest, dirs_exist_ok=args.overwrite)\n        console.print(\"[green]\u2713 Directory copied successfully[/green]\")\n\n    # Handle file copy\n    else:\n        if dest.is_dir():\n            dest = dest / source.name\n\n        if dest.exists() and not args.overwrite:\n            response = console.input(\n                f\"[yellow]'{dest}' exists. Overwrite? [y/N]:[/yellow] \"\n            )\n            if response.lower() != 'y':\n                console.print(\"[yellow]Copy cancelled[/yellow]\")\n                return False\n\n        copy_with_progress(source, dest)\n        console.print(\"[green]\u2713 File copied successfully[/green]\")\n\n    return True\n</code></pre>"},{"location":"examples/cli-tool/#setuppy","title":"setup.py","text":"<pre><code>from setuptools import setup, find_packages\n\nwith open(\"README.md\", \"r\", encoding=\"utf-8\") as fh:\n    long_description = fh.read()\n\nsetup(\n    name=\"fman\",\n    version=\"1.0.0\",\n    author=\"Your Name\",\n    author_email=\"your.email@example.com\",\n    description=\"A powerful file manager CLI tool\",\n    long_description=long_description,\n    long_description_content_type=\"text/markdown\",\n    url=\"https://github.com/yourusername/fman\",\n    packages=find_packages(),\n    classifiers=[\n        \"Programming Language :: Python :: 3\",\n        \"License :: OSI Approved :: MIT License\",\n        \"Operating System :: OS Independent\",\n        \"Environment :: Console\",\n        \"Topic :: System :: Filesystems\",\n    ],\n    python_requires=\"&gt;=3.7\",\n    install_requires=[\n        \"rich&gt;=10.0.0\",\n        \"tqdm&gt;=4.60.0\",\n        \"click&gt;=8.0.0\",\n    ],\n    entry_points={\n        \"console_scripts\": [\n            \"fman=fman.cli:main\",\n        ],\n    },\n    include_package_data=True,\n)\n</code></pre>"},{"location":"examples/cli-tool/#testing-the-cli","title":"Testing the CLI","text":"<pre><code># Install in development mode\npip install -e .\n\n# Test commands\nfman list --all\nfman search \"*.py\" --path /home/user/projects\nfman copy file.txt backup.txt\nfman move old.txt new.txt\nfman delete temp.txt --force\n\n# Run tests\npytest tests/ -v\n</code></pre>"},{"location":"examples/cli-tool/#tips-for-cli-development","title":"Tips for CLI Development","text":"<ol> <li>Clear Command Structure: Define all commands and options upfront</li> <li>User Experience: Request colored output and progress bars</li> <li>Error Handling: Specify how errors should be displayed</li> <li>Configuration: Include config file support from the start</li> <li>Testing: Request unit tests for each command</li> </ol>"},{"location":"examples/cli-tool/#extending-the-tool","title":"Extending the Tool","text":""},{"location":"examples/cli-tool/#add-compression-support","title":"Add Compression Support","text":"<pre><code>## Additional Command\n6. **compress** - Compress files/directories\n   - Support zip, tar.gz, tar.bz2\n   - Options: --format, --level\n   - Show compression ratio\n</code></pre>"},{"location":"examples/cli-tool/#add-remote-operations","title":"Add Remote Operations","text":"<pre><code>## Additional Features\n- Support for remote file operations via SSH\n- Commands: remote-list, remote-copy, remote-delete\n- Use paramiko for SSH connections\n</code></pre>"},{"location":"examples/cli-tool/#common-patterns","title":"Common Patterns","text":""},{"location":"examples/cli-tool/#confirmation-prompts","title":"Confirmation Prompts","text":"<pre><code>def confirm_action(message):\n    \"\"\"Get user confirmation\"\"\"\n    response = console.input(f\"[yellow]{message} [y/N]:[/yellow] \")\n    return response.lower() == 'y'\n</code></pre>"},{"location":"examples/cli-tool/#error-handling","title":"Error Handling","text":"<pre><code>def safe_operation(func):\n    \"\"\"Decorator for safe operations\"\"\"\n    def wrapper(*args, **kwargs):\n        try:\n            return func(*args, **kwargs)\n        except PermissionError:\n            console.print(\"[red]Permission denied[/red]\")\n        except FileNotFoundError:\n            console.print(\"[red]File not found[/red]\")\n        except Exception as e:\n            console.print(f\"[red]Error: {e}[/red]\")\n        return False\n    return wrapper\n</code></pre>"},{"location":"examples/cli-tool/#cost-estimation","title":"Cost Estimation","text":"<ul> <li>Iterations: ~30-40 for full implementation</li> <li>Time: ~15-20 minutes</li> <li>Agent: Claude or Gemini</li> <li>API Calls: ~$0.30-0.40</li> </ul>"},{"location":"examples/data-analysis/","title":"Data Analysis Script with Ralph","text":"<p>This example demonstrates using Ralph Orchestrator to create a data analysis script with pandas, visualization, and reporting.</p>"},{"location":"examples/data-analysis/#task-description","title":"Task Description","text":"<p>Create a Python data analysis script that: - Loads and cleans CSV data - Performs statistical analysis - Creates visualizations - Generates HTML report</p>"},{"location":"examples/data-analysis/#promptmd-file","title":"PROMPT.md File","text":"<p><pre><code># Task: Build Sales Data Analysis Script\n\nCreate a Python script to analyze sales data with the following requirements:\n\n## Data Processing\n\n1. Load sales data from CSV file\n2. Clean and validate data:\n   - Handle missing values\n   - Convert data types\n   - Remove duplicates\n   - Validate date ranges\n\n## Analysis Requirements\n\n1. **Sales Metrics**\n   - Total revenue by month\n   - Average order value\n   - Top 10 products by revenue\n   - Sales growth rate\n\n2. **Customer Analysis**\n   - Customer segmentation (RFM analysis)\n   - Customer lifetime value\n   - Repeat purchase rate\n   - Geographic distribution\n\n3. **Product Analysis**\n   - Best/worst performing products\n   - Product category performance\n   - Seasonal trends\n   - Inventory turnover\n\n## Visualizations\n\nCreate the following charts:\n1. Monthly revenue trend (line chart)\n2. Product category breakdown (pie chart)\n3. Customer distribution map (geographic)\n4. Sales heatmap by day/hour\n5. Top products bar chart\n\n## Output\n\nGenerate an HTML report with:\n- Executive summary\n- Key metrics dashboard\n- Interactive charts (using plotly)\n- Data tables\n- Insights and recommendations\n\n## File Structure\n</code></pre> sales-analysis/ \u251c\u2500\u2500 analyze.py          # Main analysis script \u251c\u2500\u2500 data_loader.py      # Data loading and cleaning \u251c\u2500\u2500 analysis.py         # Analysis functions \u251c\u2500\u2500 visualizations.py   # Chart generation \u251c\u2500\u2500 report_generator.py # HTML report creation \u251c\u2500\u2500 requirements.txt    # Dependencies \u251c\u2500\u2500 config.yaml        # Configuration \u251c\u2500\u2500 templates/         # HTML templates \u2502   \u2514\u2500\u2500 report.html \u251c\u2500\u2500 data/             # Data directory \u2502   \u2514\u2500\u2500 sales.csv     # Sample data \u2514\u2500\u2500 output/           # Output directory     \u2514\u2500\u2500 report.html   # Generated report <pre><code>## Sample Data Structure\n\nCSV columns:\n- order_id, customer_id, product_id, product_name, category\n- quantity, unit_price, total_price, discount\n- order_date, ship_date, region, payment_method\n\n&lt;!-- TASK_COMPLETE will be added when done --&gt;\n</code></pre></p>"},{"location":"examples/data-analysis/#running-ralph","title":"Running Ralph","text":"<pre><code>ralph init\ncp data-analysis-prompt.md PROMPT.md\nralph run --agent claude --max-iterations 35\n</code></pre>"},{"location":"examples/data-analysis/#expected-output","title":"Expected Output","text":""},{"location":"examples/data-analysis/#analyzepy-main-script","title":"analyze.py (Main Script)","text":"<pre><code>#!/usr/bin/env python3\n\"\"\"\nSales Data Analysis Script\nAnalyzes sales data and generates comprehensive HTML report\n\"\"\"\n\nimport pandas as pd\nimport numpy as np\nfrom datetime import datetime\nimport yaml\nimport logging\nfrom pathlib import Path\n\nfrom data_loader import DataLoader\nfrom analysis import SalesAnalyzer, CustomerAnalyzer, ProductAnalyzer\nfrom visualizations import ChartGenerator\nfrom report_generator import ReportGenerator\n\n# Setup logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\ndef load_config(config_path='config.yaml'):\n    \"\"\"Load configuration from YAML file\"\"\"\n    with open(config_path, 'r') as f:\n        return yaml.safe_load(f)\n\ndef main():\n    \"\"\"Main analysis pipeline\"\"\"\n    logger.info(\"Starting sales data analysis...\")\n\n    # Load configuration\n    config = load_config()\n\n    # Step 1: Load and clean data\n    logger.info(\"Loading data...\")\n    loader = DataLoader(config['data']['input_file'])\n    df = loader.load_and_clean()\n    logger.info(f\"Loaded {len(df)} records\")\n\n    # Step 2: Perform analysis\n    logger.info(\"Performing analysis...\")\n\n    # Sales analysis\n    sales_analyzer = SalesAnalyzer(df)\n    sales_metrics = {\n        'total_revenue': sales_analyzer.calculate_total_revenue(),\n        'monthly_revenue': sales_analyzer.get_monthly_revenue(),\n        'avg_order_value': sales_analyzer.calculate_avg_order_value(),\n        'growth_rate': sales_analyzer.calculate_growth_rate(),\n        'top_products': sales_analyzer.get_top_products(10)\n    }\n\n    # Customer analysis\n    customer_analyzer = CustomerAnalyzer(df)\n    customer_metrics = {\n        'total_customers': customer_analyzer.count_unique_customers(),\n        'repeat_rate': customer_analyzer.calculate_repeat_rate(),\n        'rfm_segments': customer_analyzer.perform_rfm_analysis(),\n        'lifetime_value': customer_analyzer.calculate_clv(),\n        'geographic_dist': customer_analyzer.get_geographic_distribution()\n    }\n\n    # Product analysis\n    product_analyzer = ProductAnalyzer(df)\n    product_metrics = {\n        'category_performance': product_analyzer.analyze_categories(),\n        'seasonal_trends': product_analyzer.find_seasonal_trends(),\n        'inventory_turnover': product_analyzer.calculate_turnover(),\n        'product_ranking': product_analyzer.rank_products()\n    }\n\n    # Step 3: Generate visualizations\n    logger.info(\"Creating visualizations...\")\n    chart_gen = ChartGenerator(df)\n\n    charts = {\n        'revenue_trend': chart_gen.create_revenue_trend(\n            sales_metrics['monthly_revenue']\n        ),\n        'category_pie': chart_gen.create_category_pie(\n            product_metrics['category_performance']\n        ),\n        'customer_map': chart_gen.create_customer_map(\n            customer_metrics['geographic_dist']\n        ),\n        'sales_heatmap': chart_gen.create_sales_heatmap(),\n        'top_products_bar': chart_gen.create_top_products_bar(\n            sales_metrics['top_products']\n        )\n    }\n\n    # Step 4: Generate report\n    logger.info(\"Generating HTML report...\")\n    report_gen = ReportGenerator()\n\n    report_data = {\n        'generated_at': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),\n        'record_count': len(df),\n        'date_range': f\"{df['order_date'].min()} to {df['order_date'].max()}\",\n        'sales_metrics': sales_metrics,\n        'customer_metrics': customer_metrics,\n        'product_metrics': product_metrics,\n        'charts': charts,\n        'insights': generate_insights(sales_metrics, customer_metrics, product_metrics)\n    }\n\n    output_path = Path(config['output']['report_path'])\n    output_path.parent.mkdir(parents=True, exist_ok=True)\n\n    report_gen.generate(report_data, output_path)\n\n    logger.info(f\"Report generated: {output_path}\")\n    logger.info(\"Analysis complete!\")\n\n    return output_path\n\ndef generate_insights(sales, customers, products):\n    \"\"\"Generate insights from analysis results\"\"\"\n    insights = []\n\n    # Revenue insights\n    if sales['growth_rate'] &gt; 0:\n        insights.append(f\"Revenue is growing at {sales['growth_rate']:.1f}% monthly\")\n    else:\n        insights.append(f\"Revenue declined by {abs(sales['growth_rate']):.1f}% monthly\")\n\n    # Customer insights\n    repeat_rate = customers['repeat_rate']\n    if repeat_rate &gt; 0.3:\n        insights.append(f\"Strong customer loyalty with {repeat_rate:.1%} repeat rate\")\n    else:\n        insights.append(f\"Opportunity to improve retention (current: {repeat_rate:.1%})\")\n\n    # Product insights\n    top_category = products['category_performance'].iloc[0]\n    insights.append(f\"{top_category['category']} is the top performing category\")\n\n    return insights\n\nif __name__ == '__main__':\n    try:\n        report_path = main()\n        print(f\"\\n\u2705 Analysis complete! Report saved to: {report_path}\")\n    except Exception as e:\n        logger.error(f\"Analysis failed: {e}\")\n        raise\n</code></pre>"},{"location":"examples/data-analysis/#data_loaderpy","title":"data_loader.py","text":"<pre><code>import pandas as pd\nimport numpy as np\nfrom datetime import datetime\nimport logging\n\nlogger = logging.getLogger(__name__)\n\nclass DataLoader:\n    \"\"\"Handle data loading and cleaning\"\"\"\n\n    def __init__(self, filepath):\n        self.filepath = filepath\n\n    def load_and_clean(self):\n        \"\"\"Load CSV and perform cleaning\"\"\"\n        # Load data\n        df = pd.read_csv(self.filepath)\n        logger.info(f\"Loaded {len(df)} raw records\")\n\n        # Clean data\n        df = self.remove_duplicates(df)\n        df = self.handle_missing_values(df)\n        df = self.convert_data_types(df)\n        df = self.validate_data(df)\n\n        logger.info(f\"Cleaned data: {len(df)} records\")\n        return df\n\n    def remove_duplicates(self, df):\n        \"\"\"Remove duplicate records\"\"\"\n        before = len(df)\n        df = df.drop_duplicates(subset=['order_id'])\n        after = len(df)\n\n        if before &gt; after:\n            logger.info(f\"Removed {before - after} duplicate records\")\n\n        return df\n\n    def handle_missing_values(self, df):\n        \"\"\"Handle missing values appropriately\"\"\"\n        # Fill numeric columns with 0\n        numeric_cols = df.select_dtypes(include=[np.number]).columns\n        df[numeric_cols] = df[numeric_cols].fillna(0)\n\n        # Fill categorical columns with 'Unknown'\n        categorical_cols = df.select_dtypes(include=['object']).columns\n        df[categorical_cols] = df[categorical_cols].fillna('Unknown')\n\n        return df\n\n    def convert_data_types(self, df):\n        \"\"\"Convert columns to appropriate data types\"\"\"\n        # Convert dates\n        date_columns = ['order_date', 'ship_date']\n        for col in date_columns:\n            if col in df.columns:\n                df[col] = pd.to_datetime(df[col], errors='coerce')\n\n        # Convert numeric columns\n        numeric_columns = ['quantity', 'unit_price', 'total_price', 'discount']\n        for col in numeric_columns:\n            if col in df.columns:\n                df[col] = pd.to_numeric(df[col], errors='coerce')\n\n        # Convert IDs to string\n        id_columns = ['order_id', 'customer_id', 'product_id']\n        for col in id_columns:\n            if col in df.columns:\n                df[col] = df[col].astype(str)\n\n        return df\n\n    def validate_data(self, df):\n        \"\"\"Validate data integrity\"\"\"\n        # Remove rows with invalid dates\n        if 'order_date' in df.columns:\n            df = df[df['order_date'].notna()]\n\n        # Remove rows with negative prices\n        if 'total_price' in df.columns:\n            df = df[df['total_price'] &gt;= 0]\n\n        # Remove rows with invalid quantities\n        if 'quantity' in df.columns:\n            df = df[df['quantity'] &gt; 0]\n\n        return df\n\n    def generate_sample_data(self, num_records=1000):\n        \"\"\"Generate sample sales data for testing\"\"\"\n        np.random.seed(42)\n\n        # Generate dates\n        dates = pd.date_range(\n            start='2023-01-01',\n            end='2023-12-31',\n            periods=num_records\n        )\n\n        # Categories and products\n        categories = ['Electronics', 'Clothing', 'Books', 'Home', 'Sports']\n        products = {\n            'Electronics': ['Laptop', 'Phone', 'Tablet', 'Headphones'],\n            'Clothing': ['Shirt', 'Pants', 'Jacket', 'Shoes'],\n            'Books': ['Fiction', 'Non-fiction', 'TextBook', 'Magazine'],\n            'Home': ['Furniture', 'Decor', 'Kitchen', 'Bedding'],\n            'Sports': ['Equipment', 'Apparel', 'Footwear', 'Accessories']\n        }\n\n        # Generate records\n        records = []\n        for i in range(num_records):\n            category = np.random.choice(categories)\n            product = np.random.choice(products[category])\n            quantity = np.random.randint(1, 10)\n            unit_price = np.random.uniform(10, 500)\n            discount = np.random.uniform(0, 0.3)\n\n            records.append({\n                'order_id': f'ORD{i:05d}',\n                'customer_id': f'CUST{np.random.randint(1, 200):04d}',\n                'product_id': f'PROD{np.random.randint(1, 50):03d}',\n                'product_name': product,\n                'category': category,\n                'quantity': quantity,\n                'unit_price': unit_price,\n                'total_price': quantity * unit_price * (1 - discount),\n                'discount': discount,\n                'order_date': dates[i],\n                'ship_date': dates[i] + pd.Timedelta(days=np.random.randint(1, 7)),\n                'region': np.random.choice(['North', 'South', 'East', 'West']),\n                'payment_method': np.random.choice(['Credit Card', 'PayPal', 'Cash'])\n            })\n\n        return pd.DataFrame(records)\n</code></pre>"},{"location":"examples/data-analysis/#visualizationspy","title":"visualizations.py","text":"<pre><code>import plotly.graph_objects as go\nimport plotly.express as px\nfrom plotly.subplots import make_subplots\nimport pandas as pd\n\nclass ChartGenerator:\n    \"\"\"Generate interactive charts using Plotly\"\"\"\n\n    def __init__(self, df):\n        self.df = df\n\n    def create_revenue_trend(self, monthly_revenue):\n        \"\"\"Create monthly revenue trend line chart\"\"\"\n        fig = go.Figure()\n\n        fig.add_trace(go.Scatter(\n            x=monthly_revenue.index,\n            y=monthly_revenue.values,\n            mode='lines+markers',\n            name='Revenue',\n            line=dict(color='#1f77b4', width=3),\n            marker=dict(size=8)\n        ))\n\n        fig.update_layout(\n            title='Monthly Revenue Trend',\n            xaxis_title='Month',\n            yaxis_title='Revenue ($)',\n            hovermode='x unified',\n            template='plotly_white'\n        )\n\n        return fig.to_html(include_plotlyjs='cdn')\n\n    def create_category_pie(self, category_data):\n        \"\"\"Create category breakdown pie chart\"\"\"\n        fig = px.pie(\n            category_data,\n            values='revenue',\n            names='category',\n            title='Revenue by Category',\n            color_discrete_sequence=px.colors.qualitative.Set3\n        )\n\n        fig.update_traces(\n            textposition='inside',\n            textinfo='percent+label'\n        )\n\n        return fig.to_html(include_plotlyjs='cdn')\n\n    def create_sales_heatmap(self):\n        \"\"\"Create sales heatmap by day and hour\"\"\"\n        # Extract day and hour\n        self.df['day_of_week'] = self.df['order_date'].dt.day_name()\n        self.df['hour'] = self.df['order_date'].dt.hour\n\n        # Aggregate sales\n        heatmap_data = self.df.groupby(['day_of_week', 'hour'])[\n            'total_price'\n        ].sum().reset_index()\n\n        # Pivot for heatmap\n        pivot_table = heatmap_data.pivot(\n            index='day_of_week',\n            columns='hour',\n            values='total_price'\n        )\n\n        # Reorder days\n        days_order = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', \n                     'Friday', 'Saturday', 'Sunday']\n        pivot_table = pivot_table.reindex(days_order)\n\n        fig = go.Figure(data=go.Heatmap(\n            z=pivot_table.values,\n            x=pivot_table.columns,\n            y=pivot_table.index,\n            colorscale='Viridis',\n            text=pivot_table.values.round(0),\n            texttemplate='%{text}',\n            textfont={\"size\": 10}\n        ))\n\n        fig.update_layout(\n            title='Sales Heatmap by Day and Hour',\n            xaxis_title='Hour of Day',\n            yaxis_title='Day of Week',\n            template='plotly_white'\n        )\n\n        return fig.to_html(include_plotlyjs='cdn')\n\n    def create_top_products_bar(self, top_products):\n        \"\"\"Create horizontal bar chart of top products\"\"\"\n        fig = go.Figure(go.Bar(\n            x=top_products['revenue'],\n            y=top_products['product_name'],\n            orientation='h',\n            marker_color='lightblue',\n            text=top_products['revenue'].round(0),\n            textposition='outside'\n        ))\n\n        fig.update_layout(\n            title='Top 10 Products by Revenue',\n            xaxis_title='Revenue ($)',\n            yaxis_title='Product',\n            template='plotly_white',\n            height=400\n        )\n\n        return fig.to_html(include_plotlyjs='cdn')\n\n    def create_customer_map(self, geographic_data):\n        \"\"\"Create geographic distribution map\"\"\"\n        # For simplicity, create a bar chart by region\n        fig = px.bar(\n            geographic_data,\n            x='region',\n            y='customer_count',\n            title='Customer Distribution by Region',\n            color='customer_count',\n            color_continuous_scale='Blues'\n        )\n\n        fig.update_layout(\n            xaxis_title='Region',\n            yaxis_title='Number of Customers',\n            template='plotly_white',\n            showlegend=False\n        )\n\n        return fig.to_html(include_plotlyjs='cdn')\n</code></pre>"},{"location":"examples/data-analysis/#report-template","title":"Report Template","text":""},{"location":"examples/data-analysis/#templatesreporthtml","title":"templates/report.html","text":"<pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n&lt;head&gt;\n    &lt;meta charset=\"UTF-8\"&gt;\n    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;\n    &lt;title&gt;Sales Analysis Report&lt;/title&gt;\n    &lt;style&gt;\n        body {\n            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;\n            margin: 0;\n            padding: 20px;\n            background: #f5f5f5;\n        }\n        .container {\n            max-width: 1200px;\n            margin: 0 auto;\n            background: white;\n            padding: 30px;\n            border-radius: 10px;\n            box-shadow: 0 2px 10px rgba(0,0,0,0.1);\n        }\n        h1 {\n            color: #333;\n            border-bottom: 3px solid #4CAF50;\n            padding-bottom: 10px;\n        }\n        .metrics-grid {\n            display: grid;\n            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));\n            gap: 20px;\n            margin: 30px 0;\n        }\n        .metric-card {\n            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);\n            color: white;\n            padding: 20px;\n            border-radius: 10px;\n            text-align: center;\n        }\n        .metric-value {\n            font-size: 2em;\n            font-weight: bold;\n            margin: 10px 0;\n        }\n        .metric-label {\n            font-size: 0.9em;\n            opacity: 0.9;\n        }\n        .chart-container {\n            margin: 30px 0;\n        }\n        .insights {\n            background: #e8f5e9;\n            padding: 20px;\n            border-radius: 10px;\n            margin: 30px 0;\n        }\n        .insight-item {\n            margin: 10px 0;\n            padding-left: 20px;\n            position: relative;\n        }\n        .insight-item:before {\n            content: \"\u2192\";\n            position: absolute;\n            left: 0;\n            color: #4CAF50;\n            font-weight: bold;\n        }\n    &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;div class=\"container\"&gt;\n        &lt;h1&gt;\ud83d\udcca Sales Analysis Report&lt;/h1&gt;\n\n        &lt;div class=\"report-meta\"&gt;\n            &lt;p&gt;&lt;strong&gt;Generated:&lt;/strong&gt; {{ generated_at }}&lt;/p&gt;\n            &lt;p&gt;&lt;strong&gt;Data Range:&lt;/strong&gt; {{ date_range }}&lt;/p&gt;\n            &lt;p&gt;&lt;strong&gt;Total Records:&lt;/strong&gt; {{ record_count }}&lt;/p&gt;\n        &lt;/div&gt;\n\n        &lt;h2&gt;Key Metrics&lt;/h2&gt;\n        &lt;div class=\"metrics-grid\"&gt;\n            &lt;div class=\"metric-card\"&gt;\n                &lt;div class=\"metric-label\"&gt;Total Revenue&lt;/div&gt;\n                &lt;div class=\"metric-value\"&gt;${{ total_revenue|round(0) }}&lt;/div&gt;\n            &lt;/div&gt;\n            &lt;div class=\"metric-card\"&gt;\n                &lt;div class=\"metric-label\"&gt;Avg Order Value&lt;/div&gt;\n                &lt;div class=\"metric-value\"&gt;${{ avg_order_value|round(2) }}&lt;/div&gt;\n            &lt;/div&gt;\n            &lt;div class=\"metric-card\"&gt;\n                &lt;div class=\"metric-label\"&gt;Total Customers&lt;/div&gt;\n                &lt;div class=\"metric-value\"&gt;{{ total_customers }}&lt;/div&gt;\n            &lt;/div&gt;\n            &lt;div class=\"metric-card\"&gt;\n                &lt;div class=\"metric-label\"&gt;Repeat Rate&lt;/div&gt;\n                &lt;div class=\"metric-value\"&gt;{{ repeat_rate|round(1) }}%&lt;/div&gt;\n            &lt;/div&gt;\n        &lt;/div&gt;\n\n        &lt;h2&gt;Insights&lt;/h2&gt;\n        &lt;div class=\"insights\"&gt;\n            {% for insight in insights %}\n            &lt;div class=\"insight-item\"&gt;{{ insight }}&lt;/div&gt;\n            {% endfor %}\n        &lt;/div&gt;\n\n        &lt;h2&gt;Revenue Trend&lt;/h2&gt;\n        &lt;div class=\"chart-container\"&gt;\n            {{ revenue_trend_chart|safe }}\n        &lt;/div&gt;\n\n        &lt;h2&gt;Category Performance&lt;/h2&gt;\n        &lt;div class=\"chart-container\"&gt;\n            {{ category_pie_chart|safe }}\n        &lt;/div&gt;\n\n        &lt;h2&gt;Top Products&lt;/h2&gt;\n        &lt;div class=\"chart-container\"&gt;\n            {{ top_products_chart|safe }}\n        &lt;/div&gt;\n\n        &lt;h2&gt;Sales Patterns&lt;/h2&gt;\n        &lt;div class=\"chart-container\"&gt;\n            {{ sales_heatmap|safe }}\n        &lt;/div&gt;\n    &lt;/div&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>"},{"location":"examples/data-analysis/#tips-for-data-analysis-tasks","title":"Tips for Data Analysis Tasks","text":"<ol> <li>Specify Data Structure: Clearly define input data format</li> <li>List Required Analyses: Be specific about calculations needed</li> <li>Request Visualizations: Specify chart types and libraries</li> <li>Output Format: Define report structure and format</li> <li>Error Handling: Request validation and error handling</li> </ol>"},{"location":"examples/data-analysis/#cost-estimation","title":"Cost Estimation","text":"<ul> <li>Iterations: ~25-35 for complete implementation</li> <li>Time: ~12-18 minutes</li> <li>Agent: Claude recommended for complex analysis</li> <li>API Calls: ~$0.25-0.35</li> </ul>"},{"location":"examples/documentation/","title":"Documentation Writing Examples","text":""},{"location":"examples/documentation/#overview","title":"Overview","text":"<p>This guide provides examples of using Ralph Orchestrator for documentation tasks.</p>"},{"location":"examples/documentation/#example-1-api-documentation-generation","title":"Example 1: API Documentation Generation","text":""},{"location":"examples/documentation/#prompt","title":"Prompt","text":"<pre><code>prompt = \"\"\"\nGenerate comprehensive API documentation for the following Python class:\n\nclass DataProcessor:\n    def process_batch(self, data: List[dict], batch_size: int = 100) -&gt; List[dict]:\n        '''Process data in batches'''\n        pass\n\n    def validate_data(self, data: dict) -&gt; bool:\n        '''Validate data structure'''\n        pass\n\"\"\"\n\nresponse = orchestrator.execute(prompt, agent=\"claude\")\n</code></pre>"},{"location":"examples/documentation/#generated-documentation","title":"Generated Documentation","text":"<pre><code>## DataProcessor API Reference\n\n### Class: DataProcessor\n\nA utility class for processing and validating data in batch operations.\n\n#### Methods\n\n##### `process_batch(data: List[dict], batch_size: int = 100) -&gt; List[dict]`\n\nProcess a list of dictionaries in configurable batch sizes.\n\n**Parameters:**\n- `data` (List[dict]): The input data to process\n- `batch_size` (int, optional): Number of items to process per batch. Defaults to 100.\n\n**Returns:**\n- List[dict]: Processed data maintaining the same structure\n\n**Example:**\n```python\nprocessor = DataProcessor()\nresult = processor.process_batch([{\"id\": 1}, {\"id\": 2}], batch_size=50)\n</code></pre>"},{"location":"examples/documentation/#validate_datadata-dict-bool","title":"<code>validate_data(data: dict) -&gt; bool</code>","text":"<p>Validate the structure and content of a data dictionary.</p> <p>Parameters: - <code>data</code> (dict): The data dictionary to validate</p> <p>Returns: - bool: True if data is valid, False otherwise <pre><code>## Example 2: README Generation\n\n### Prompt\n```python\nprompt = \"\"\"\nCreate a README.md for a Python package called 'quicksort-plus' that implements \nan optimized quicksort algorithm with the following features:\n- Hybrid approach with insertion sort for small arrays\n- Three-way partitioning for duplicate elements\n- Parallel processing support\n\"\"\"\n\nresponse = orchestrator.execute(prompt, agent=\"claude\")\n</code></pre></p>"},{"location":"examples/documentation/#generated-readme","title":"Generated README","text":"<pre><code># QuickSort Plus\n\nAn optimized implementation of the quicksort algorithm with modern enhancements.\n\n## Features\n\n- **Hybrid Sorting**: Automatically switches to insertion sort for small arrays (&lt; 10 elements)\n- **Three-Way Partitioning**: Efficiently handles arrays with many duplicate elements\n- **Parallel Processing**: Leverages multiple cores for large datasets\n- **Type Support**: Works with any comparable Python objects\n\n## Installation\n\n```bash\npip install quicksort-plus\n</code></pre>"},{"location":"examples/documentation/#quick-start","title":"Quick Start","text":"<pre><code>from quicksort_plus import quicksort\n\n# Basic usage\ndata = [3, 1, 4, 1, 5, 9, 2, 6]\nsorted_data = quicksort(data)\n\n# With parallel processing\nlarge_data = list(range(1000000, 0, -1))\nsorted_data = quicksort(large_data, parallel=True)\n</code></pre>"},{"location":"examples/documentation/#performance","title":"Performance","text":"Array Size Standard QuickSort QuickSort Plus Improvement 100 0.012ms 0.008ms 33% 10,000 1.8ms 1.2ms 33% 1,000,000 248ms 142ms 43%"},{"location":"examples/documentation/#license","title":"License","text":"<p>MIT License - See LICENSE file for details <pre><code>## Example 3: Code Comments Generation\n\n### Prompt\n```python\nprompt = \"\"\"\nAdd comprehensive docstrings and inline comments to this function:\n\ndef merge_sorted_arrays(arr1, arr2):\n    result = []\n    i = j = 0\n\n    while i &lt; len(arr1) and j &lt; len(arr2):\n        if arr1[i] &lt;= arr2[j]:\n            result.append(arr1[i])\n            i += 1\n        else:\n            result.append(arr2[j])\n            j += 1\n\n    result.extend(arr1[i:])\n    result.extend(arr2[j:])\n    return result\n\"\"\"\n\nresponse = orchestrator.execute(prompt, agent=\"claude\")\n</code></pre></p>"},{"location":"examples/documentation/#result-with-documentation","title":"Result with Documentation","text":"<pre><code>def merge_sorted_arrays(arr1: list, arr2: list) -&gt; list:\n    \"\"\"\n    Merge two sorted arrays into a single sorted array.\n\n    This function implements the merge step of merge sort, combining\n    two pre-sorted arrays into one sorted array in O(n+m) time.\n\n    Args:\n        arr1 (list): First sorted array\n        arr2 (list): Second sorted array\n\n    Returns:\n        list: A new sorted array containing all elements from both inputs\n\n    Examples:\n        &gt;&gt;&gt; merge_sorted_arrays([1, 3, 5], [2, 4, 6])\n        [1, 2, 3, 4, 5, 6]\n\n        &gt;&gt;&gt; merge_sorted_arrays([1, 2], [3, 4, 5])\n        [1, 2, 3, 4, 5]\n\n    Time Complexity: O(n + m) where n and m are the lengths of the arrays\n    Space Complexity: O(n + m) for the result array\n    \"\"\"\n    result = []\n    i = j = 0  # Initialize pointers for both arrays\n\n    # Compare elements from both arrays and add the smaller one\n    while i &lt; len(arr1) and j &lt; len(arr2):\n        if arr1[i] &lt;= arr2[j]:\n            result.append(arr1[i])\n            i += 1  # Move pointer in first array\n        else:\n            result.append(arr2[j])\n            j += 1  # Move pointer in second array\n\n    # Add remaining elements from arr1 (if any)\n    result.extend(arr1[i:])\n\n    # Add remaining elements from arr2 (if any)\n    result.extend(arr2[j:])\n\n    return result\n</code></pre>"},{"location":"examples/documentation/#example-4-technical-specification","title":"Example 4: Technical Specification","text":""},{"location":"examples/documentation/#prompt_1","title":"Prompt","text":"<pre><code>prompt = \"\"\"\nWrite a technical specification document for a rate limiting system that:\n- Supports multiple algorithms (token bucket, sliding window)\n- Has Redis backend\n- Provides middleware for Flask/FastAPI\n\"\"\"\n\nresponse = orchestrator.execute(prompt, agent=\"claude\")\n</code></pre>"},{"location":"examples/documentation/#generated-specification","title":"Generated Specification","text":"<pre><code># Rate Limiting System - Technical Specification\n\n## 1. Overview\n\nA flexible rate limiting system supporting multiple algorithms with Redis backend\nand framework middleware integration.\n\n## 2. System Architecture\n\n### 2.1 Core Components\n\n- **Rate Limiter Engine**: Algorithm implementation layer\n- **Storage Backend**: Redis-based persistence\n- **Middleware Layer**: Framework integrations\n- **Configuration Manager**: Dynamic rule management\n\n### 2.2 Supported Algorithms\n\n#### Token Bucket\n- Configurable capacity and refill rate\n- Burst traffic support\n- Per-user/IP buckets\n\n#### Sliding Window Log\n- Precise rate limiting\n- Configurable window size\n- Memory-efficient implementation\n\n## 3. API Specification\n\n### 3.1 Core Interface\n\n```python\nclass RateLimiter:\n    def __init__(self, backend: RedisBackend, algorithm: Algorithm):\n        pass\n\n    def is_allowed(self, key: str, cost: int = 1) -&gt; bool:\n        pass\n\n    def get_remaining(self, key: str) -&gt; int:\n        pass\n</code></pre>"},{"location":"examples/documentation/#32-middleware-integration","title":"3.2 Middleware Integration","text":"<pre><code># Flask\n@app.before_request\n@rate_limit(requests=100, window=3600)\ndef check_rate_limit():\n    pass\n\n# FastAPI\n@app.middleware(\"http\")\nasync def rate_limit_middleware(request: Request, call_next):\n    pass\n</code></pre>"},{"location":"examples/documentation/#4-redis-schema","title":"4. Redis Schema","text":"<pre><code>rate_limit:{algorithm}:{key} -&gt; {\n    \"tokens\": 100,\n    \"last_refill\": 1234567890,\n    \"requests\": []\n}\n</code></pre>"},{"location":"examples/documentation/#5-performance-requirements","title":"5. Performance Requirements","text":"<ul> <li>Latency: &lt; 5ms per check</li> <li>Throughput: 10,000 checks/second</li> <li>Memory: O(n) where n = unique keys</li> </ul>"},{"location":"examples/documentation/#6-configuration","title":"6. Configuration","text":"<p><pre><code>rate_limiting:\n  default_algorithm: token_bucket\n  redis:\n    host: localhost\n    port: 6379\n  rules:\n    - path: /api/*\n      limit: 100\n      window: 3600\n</code></pre> ```</p>"},{"location":"examples/documentation/#best-practices-for-documentation-generation","title":"Best Practices for Documentation Generation","text":""},{"location":"examples/documentation/#1-provide-context","title":"1. Provide Context","text":"<p>Include relevant code structure, project type, and target audience in your prompts.</p>"},{"location":"examples/documentation/#2-specify-format","title":"2. Specify Format","text":"<p>Request specific documentation formats (Markdown, reStructuredText, etc.).</p>"},{"location":"examples/documentation/#3-include-examples","title":"3. Include Examples","text":"<p>Ask for usage examples and code snippets in documentation.</p>"},{"location":"examples/documentation/#4-request-sections","title":"4. Request Sections","text":"<p>Specify required sections like installation, configuration, API reference, etc.</p>"},{"location":"examples/documentation/#see-also","title":"See Also","text":"<ul> <li>Prompt Engineering Guide</li> <li>Code Generation Examples</li> <li>Testing Examples</li> </ul>"},{"location":"examples/simple-task/","title":"Simple Task Example: Todo List CLI","text":"<p>This example demonstrates building a simple command-line todo list application using Ralph Orchestrator.</p>"},{"location":"examples/simple-task/#overview","title":"Overview","text":"<p>We'll create a Python CLI application that: - Manages todo items (add, list, complete, remove) - Persists data to JSON file - Includes colored output - Has comprehensive error handling</p>"},{"location":"examples/simple-task/#the-prompt","title":"The Prompt","text":"<p>Create a file <code>todo-prompt.md</code>:</p> <p><pre><code># Build Todo List CLI Application\n\n## Objective\nCreate a command-line todo list manager with file persistence.\n\n## Requirements\n\n### Core Features\n1. Add new todo items with descriptions\n2. List all todos with status\n3. Mark todos as complete\n4. Remove todos\n5. Clear all todos\n6. Save todos to JSON file\n\n### Technical Specifications\n- Language: Python 3.8+\n- File storage: todos.json\n- Use argparse for CLI\n- Add colored output (use colorama or ANSI codes)\n- Include proper error handling\n\n### Commands\n- `todo add &lt;description&gt;` - Add new todo\n- `todo list` - Show all todos\n- `todo done &lt;id&gt;` - Mark as complete\n- `todo remove &lt;id&gt;` - Delete todo\n- `todo clear` - Remove all todos\n\n### File Structure\n</code></pre> todo-app/ \u251c\u2500\u2500 todo.py          # Main CLI application \u251c\u2500\u2500 todos.json       # Data storage \u251c\u2500\u2500 test_todo.py     # Unit tests \u2514\u2500\u2500 README.md        # Documentation <pre><code>## Example Usage\n\n```bash\n$ python todo.py add \"Buy groceries\"\n\u2705 Added: Buy groceries (ID: 1)\n\n$ python todo.py add \"Write documentation\"\n\u2705 Added: Write documentation (ID: 2)\n\n$ python todo.py list\nTodo List:\n[ ] 1. Buy groceries\n[ ] 2. Write documentation\n\n$ python todo.py done 1\n\u2705 Completed: Buy groceries\n\n$ python todo.py list\nTodo List:\n[\u2713] 1. Buy groceries\n[ ] 2. Write documentation\n\n$ python todo.py remove 1\n\u2705 Removed: Buy groceries\n</code></pre></p>"},{"location":"examples/simple-task/#data-format","title":"Data Format","text":"<p>todos.json: <pre><code>{\n  \"todos\": [\n    {\n      \"id\": 1,\n      \"description\": \"Buy groceries\",\n      \"completed\": false,\n      \"created_at\": \"2024-01-10T10:00:00\",\n      \"completed_at\": null\n    }\n  ],\n  \"next_id\": 2\n}\n</code></pre></p>"},{"location":"examples/simple-task/#success-criteria","title":"Success Criteria","text":"<ul> <li> All commands working as specified</li> <li> Data persists between runs</li> <li> Colored output for better UX</li> <li> Error handling for edge cases</li> <li> Tests cover main functionality</li> <li> README with usage instructions</li> </ul> <p>When complete, add \"TASK_COMPLETE\" to this file. <pre><code>## Running the Example\n\n### Basic Execution\n\n```bash\npython ralph_orchestrator.py --prompt todo-prompt.md\n</code></pre></p>"},{"location":"examples/simple-task/#with-specific-settings","title":"With Specific Settings","text":"<pre><code># Budget-conscious approach\npython ralph_orchestrator.py \\\n  --agent q \\\n  --prompt todo-prompt.md \\\n  --max-cost 2.0 \\\n  --max-iterations 20\n\n# Quality-focused approach\npython ralph_orchestrator.py \\\n  --agent claude \\\n  --prompt todo-prompt.md \\\n  --max-cost 10.0 \\\n  --checkpoint-interval 3\n</code></pre>"},{"location":"examples/simple-task/#expected-results","title":"Expected Results","text":""},{"location":"examples/simple-task/#iterations","title":"Iterations","text":"<p>Typical completion: 5-15 iterations</p>"},{"location":"examples/simple-task/#cost-estimates","title":"Cost Estimates","text":"<ul> <li>Q Chat: $0.50 - $1.50</li> <li>Gemini: $0.75 - $2.00</li> <li>Claude: $2.00 - $5.00</li> </ul>"},{"location":"examples/simple-task/#files-created","title":"Files Created","text":"<p>After successful completion:</p> <pre><code>todo-app/\n\u251c\u2500\u2500 todo.py          # ~200 lines\n\u251c\u2500\u2500 todos.json       # Initial empty structure\n\u251c\u2500\u2500 test_todo.py     # ~100 lines\n\u2514\u2500\u2500 README.md        # ~50 lines\n</code></pre>"},{"location":"examples/simple-task/#sample-output","title":"Sample Output","text":"<p>Here's what the generated <code>todo.py</code> might look like:</p> <pre><code>#!/usr/bin/env python3\n\"\"\"\nTodo List CLI Application\nA simple command-line todo manager with JSON persistence.\n\"\"\"\n\nimport argparse\nimport json\nimport os\nfrom datetime import datetime\nfrom pathlib import Path\n\n# ANSI color codes\nGREEN = '\\033[92m'\nYELLOW = '\\033[93m'\nRED = '\\033[91m'\nRESET = '\\033[0m'\nBOLD = '\\033[1m'\n\nclass TodoManager:\n    def __init__(self, filename='todos.json'):\n        self.filename = filename\n        self.todos = self.load_todos()\n\n    def load_todos(self):\n        \"\"\"Load todos from JSON file.\"\"\"\n        if not os.path.exists(self.filename):\n            return {'todos': [], 'next_id': 1}\n\n        try:\n            with open(self.filename, 'r') as f:\n                return json.load(f)\n        except json.JSONDecodeError:\n            return {'todos': [], 'next_id': 1}\n\n    def save_todos(self):\n        \"\"\"Save todos to JSON file.\"\"\"\n        with open(self.filename, 'w') as f:\n            json.dump(self.todos, f, indent=2, default=str)\n\n    def add_todo(self, description):\n        \"\"\"Add a new todo item.\"\"\"\n        todo = {\n            'id': self.todos['next_id'],\n            'description': description,\n            'completed': False,\n            'created_at': datetime.now().isoformat(),\n            'completed_at': None\n        }\n\n        self.todos['todos'].append(todo)\n        self.todos['next_id'] += 1\n        self.save_todos()\n\n        print(f\"{GREEN}\u2705 Added: {description} (ID: {todo['id']}){RESET}\")\n        return todo['id']\n\n    def list_todos(self):\n        \"\"\"List all todos.\"\"\"\n        if not self.todos['todos']:\n            print(f\"{YELLOW}No todos found.{RESET}\")\n            return\n\n        print(f\"{BOLD}Todo List:{RESET}\")\n        for todo in self.todos['todos']:\n            status = f\"{GREEN}[\u2713]{RESET}\" if todo['completed'] else \"[ ]\"\n            print(f\"{status} {todo['id']}. {todo['description']}\")\n\n    def complete_todo(self, todo_id):\n        \"\"\"Mark a todo as complete.\"\"\"\n        for todo in self.todos['todos']:\n            if todo['id'] == todo_id:\n                todo['completed'] = True\n                todo['completed_at'] = datetime.now().isoformat()\n                self.save_todos()\n                print(f\"{GREEN}\u2705 Completed: {todo['description']}{RESET}\")\n                return True\n\n        print(f\"{RED}\u274c Todo with ID {todo_id} not found.{RESET}\")\n        return False\n\n    def remove_todo(self, todo_id):\n        \"\"\"Remove a todo.\"\"\"\n        for i, todo in enumerate(self.todos['todos']):\n            if todo['id'] == todo_id:\n                removed = self.todos['todos'].pop(i)\n                self.save_todos()\n                print(f\"{GREEN}\u2705 Removed: {removed['description']}{RESET}\")\n                return True\n\n        print(f\"{RED}\u274c Todo with ID {todo_id} not found.{RESET}\")\n        return False\n\n    def clear_todos(self):\n        \"\"\"Clear all todos.\"\"\"\n        count = len(self.todos['todos'])\n        self.todos = {'todos': [], 'next_id': 1}\n        self.save_todos()\n        print(f\"{GREEN}\u2705 Cleared {count} todos.{RESET}\")\n\ndef main():\n    parser = argparse.ArgumentParser(description='Todo List CLI')\n    subparsers = parser.add_subparsers(dest='command', help='Commands')\n\n    # Add command\n    add_parser = subparsers.add_parser('add', help='Add a new todo')\n    add_parser.add_argument('description', nargs='+', help='Todo description')\n\n    # List command\n    subparsers.add_parser('list', help='List all todos')\n\n    # Done command\n    done_parser = subparsers.add_parser('done', help='Mark todo as complete')\n    done_parser.add_argument('id', type=int, help='Todo ID')\n\n    # Remove command\n    remove_parser = subparsers.add_parser('remove', help='Remove a todo')\n    remove_parser.add_argument('id', type=int, help='Todo ID')\n\n    # Clear command\n    subparsers.add_parser('clear', help='Clear all todos')\n\n    args = parser.parse_args()\n\n    if not args.command:\n        parser.print_help()\n        return\n\n    manager = TodoManager()\n\n    if args.command == 'add':\n        description = ' '.join(args.description)\n        manager.add_todo(description)\n    elif args.command == 'list':\n        manager.list_todos()\n    elif args.command == 'done':\n        manager.complete_todo(args.id)\n    elif args.command == 'remove':\n        manager.remove_todo(args.id)\n    elif args.command == 'clear':\n        manager.clear_todos()\n\nif __name__ == '__main__':\n    main()\n</code></pre>"},{"location":"examples/simple-task/#variations","title":"Variations","text":""},{"location":"examples/simple-task/#1-enhanced-version","title":"1. Enhanced Version","text":"<p>Add these features to the prompt:</p> <pre><code>## Additional Features\n- Priority levels (high, medium, low)\n- Due dates with reminders\n- Categories/tags\n- Search functionality\n- Export to CSV/Markdown\n</code></pre>"},{"location":"examples/simple-task/#2-web-interface","title":"2. Web Interface","text":"<p>Transform to a web application:</p> <pre><code>## Web Version\nInstead of CLI, create a Flask web app with:\n- HTML interface\n- REST API endpoints\n- SQLite database\n- Basic authentication\n</code></pre>"},{"location":"examples/simple-task/#3-collaborative-version","title":"3. Collaborative Version","text":"<p>Add multi-user support:</p> <pre><code>## Multi-User Features\n- User accounts\n- Shared todo lists\n- Permissions (view/edit)\n- Activity logging\n</code></pre>"},{"location":"examples/simple-task/#troubleshooting","title":"Troubleshooting","text":""},{"location":"examples/simple-task/#issue-file-not-created","title":"Issue: File Not Created","text":"<p>Solution: Ensure the agent has write permissions:</p> <pre><code># Check permissions\nls -la\n\n# Run with explicit path\npython ralph_orchestrator.py --prompt ./todo-prompt.md\n</code></pre>"},{"location":"examples/simple-task/#issue-tests-failing","title":"Issue: Tests Failing","text":"<p>Solution: Specify test framework:</p> <pre><code>## Testing Requirements\nUse pytest for testing:\n- Install: pip install pytest\n- Run: pytest test_todo.py\n- Coverage: pytest --cov=todo\n</code></pre>"},{"location":"examples/simple-task/#issue-colors-not-working","title":"Issue: Colors Not Working","text":"<p>Solution: Add fallback for Windows:</p> <pre><code>## Color Output\n- Try colorama first (cross-platform)\n- Fall back to ANSI codes\n- Detect terminal support\n- Add --no-color option\n</code></pre>"},{"location":"examples/simple-task/#learning-points","title":"Learning Points","text":""},{"location":"examples/simple-task/#what-this-example-teaches","title":"What This Example Teaches","text":"<ol> <li>CLI Development: Using argparse effectively</li> <li>Data Persistence: JSON file handling</li> <li>Error Handling: Graceful failure modes</li> <li>User Experience: Colored output and clear feedback</li> <li>Testing: Writing unit tests for CLI apps</li> </ol>"},{"location":"examples/simple-task/#key-patterns","title":"Key Patterns","text":"<ul> <li>Command pattern for CLI actions</li> <li>Repository pattern for data storage</li> <li>Clear separation of concerns</li> <li>Comprehensive error messages</li> </ul>"},{"location":"examples/simple-task/#next-steps","title":"Next Steps","text":"<p>After completing this example:</p> <ol> <li>Extend Features: Add the variations mentioned above</li> <li>Improve Testing: Add integration tests</li> <li>Package It: Create setup.py for distribution</li> <li>Add CI/CD: GitHub Actions workflow</li> </ol>"},{"location":"examples/simple-task/#related-examples","title":"Related Examples","text":"<ul> <li>Web API Example - Build a REST API version</li> <li>CLI Tool Example - More advanced CLI patterns</li> <li>Data Analysis Example - Process todo statistics</li> </ul> <p>\ud83d\udcda Continue to Web API Example \u2192</p>"},{"location":"examples/testing/","title":"Testing Examples","text":""},{"location":"examples/testing/#overview","title":"Overview","text":"<p>This guide demonstrates how to use Ralph Orchestrator for generating comprehensive test suites.</p>"},{"location":"examples/testing/#example-1-unit-test-generation","title":"Example 1: Unit Test Generation","text":""},{"location":"examples/testing/#source-code","title":"Source Code","text":"<pre><code>class Calculator:\n    def add(self, a, b):\n        return a + b\n\n    def divide(self, a, b):\n        if b == 0:\n            raise ValueError(\"Cannot divide by zero\")\n        return a / b\n\n    def calculate_percentage(self, value, percentage):\n        return (value * percentage) / 100\n</code></pre>"},{"location":"examples/testing/#test-generation-request","title":"Test Generation Request","text":"<pre><code>prompt = \"\"\"\nGenerate comprehensive unit tests for this Calculator class using pytest.\nInclude edge cases, error handling, and parametrized tests.\n\"\"\"\n\nresponse = orchestrator.execute(prompt, agent=\"claude\")\n</code></pre>"},{"location":"examples/testing/#generated-tests","title":"Generated Tests","text":"<pre><code>import pytest\nfrom calculator import Calculator\n\nclass TestCalculator:\n    \"\"\"Comprehensive test suite for Calculator class.\"\"\"\n\n    @pytest.fixture\n    def calc(self):\n        \"\"\"Provide a Calculator instance for tests.\"\"\"\n        return Calculator()\n\n    # Addition Tests\n    @pytest.mark.parametrize(\"a,b,expected\", [\n        (2, 3, 5),\n        (-1, 1, 0),\n        (0, 0, 0),\n        (1.5, 2.5, 4.0),\n        (-5, -3, -8),\n        (1e10, 1e10, 2e10),  # Large numbers\n    ])\n    def test_add(self, calc, a, b, expected):\n        \"\"\"Test addition with various inputs.\"\"\"\n        assert calc.add(a, b) == expected\n\n    # Division Tests\n    @pytest.mark.parametrize(\"a,b,expected\", [\n        (10, 2, 5),\n        (7, 2, 3.5),\n        (-10, 2, -5),\n        (0, 5, 0),\n        (1, 3, 0.3333333333333333),\n    ])\n    def test_divide(self, calc, a, b, expected):\n        \"\"\"Test division with valid inputs.\"\"\"\n        assert calc.divide(a, b) == pytest.approx(expected)\n\n    def test_divide_by_zero(self, calc):\n        \"\"\"Test that dividing by zero raises ValueError.\"\"\"\n        with pytest.raises(ValueError, match=\"Cannot divide by zero\"):\n            calc.divide(10, 0)\n\n    # Percentage Tests\n    @pytest.mark.parametrize(\"value,percentage,expected\", [\n        (100, 10, 10),\n        (50, 50, 25),\n        (200, 25, 50),\n        (0, 50, 0),\n        (100, 0, 0),\n        (100, 150, 150),  # Over 100%\n        (100, -10, -10),   # Negative percentage\n    ])\n    def test_calculate_percentage(self, calc, value, percentage, expected):\n        \"\"\"Test percentage calculation with various inputs.\"\"\"\n        assert calc.calculate_percentage(value, percentage) == expected\n\n    # Edge Cases\n    def test_add_with_none(self, calc):\n        \"\"\"Test that adding None raises TypeError.\"\"\"\n        with pytest.raises(TypeError):\n            calc.add(None, 5)\n\n    def test_float_precision(self, calc):\n        \"\"\"Test floating point precision handling.\"\"\"\n        result = calc.add(0.1, 0.2)\n        assert result == pytest.approx(0.3)\n\n    # Property-based tests (using hypothesis)\n    @pytest.mark.skipif(not pytest.importorskip(\"hypothesis\"), \n                        reason=\"hypothesis not installed\")\n    def test_add_commutative(self, calc):\n        \"\"\"Test that addition is commutative.\"\"\"\n        from hypothesis import given, strategies as st\n\n        @given(st.floats(allow_nan=False), st.floats(allow_nan=False))\n        def check_commutative(a, b):\n            assert calc.add(a, b) == calc.add(b, a)\n\n        check_commutative()\n</code></pre>"},{"location":"examples/testing/#example-2-integration-test-generation","title":"Example 2: Integration Test Generation","text":""},{"location":"examples/testing/#api-code","title":"API Code","text":"<pre><code>class UserService:\n    def __init__(self, db, email_service):\n        self.db = db\n        self.email_service = email_service\n\n    def create_user(self, email, name):\n        if self.db.user_exists(email):\n            raise ValueError(\"User already exists\")\n\n        user = self.db.create_user(email=email, name=name)\n        self.email_service.send_welcome_email(email, name)\n        return user\n</code></pre>"},{"location":"examples/testing/#test-generation-request_1","title":"Test Generation Request","text":"<pre><code>prompt = \"\"\"\nGenerate integration tests for UserService that test the interaction \nbetween database and email service. Use mocking where appropriate.\n\"\"\"\n\nresponse = orchestrator.execute(prompt, agent=\"claude\")\n</code></pre>"},{"location":"examples/testing/#generated-integration-tests","title":"Generated Integration Tests","text":"<pre><code>import pytest\nfrom unittest.mock import Mock, MagicMock, call\nfrom user_service import UserService\n\nclass TestUserServiceIntegration:\n    \"\"\"Integration tests for UserService.\"\"\"\n\n    @pytest.fixture\n    def mock_db(self):\n        \"\"\"Create a mock database.\"\"\"\n        db = Mock()\n        db.user_exists.return_value = False\n        db.create_user.return_value = {\n            \"id\": 1,\n            \"email\": \"test@example.com\",\n            \"name\": \"Test User\"\n        }\n        return db\n\n    @pytest.fixture\n    def mock_email_service(self):\n        \"\"\"Create a mock email service.\"\"\"\n        return Mock()\n\n    @pytest.fixture\n    def user_service(self, mock_db, mock_email_service):\n        \"\"\"Create UserService with mocked dependencies.\"\"\"\n        return UserService(mock_db, mock_email_service)\n\n    def test_create_user_success(self, user_service, mock_db, mock_email_service):\n        \"\"\"Test successful user creation flow.\"\"\"\n        # Arrange\n        email = \"newuser@example.com\"\n        name = \"New User\"\n\n        # Act\n        user = user_service.create_user(email, name)\n\n        # Assert\n        mock_db.user_exists.assert_called_once_with(email)\n        mock_db.create_user.assert_called_once_with(email=email, name=name)\n        mock_email_service.send_welcome_email.assert_called_once_with(email, name)\n        assert user[\"email\"] == \"test@example.com\"\n\n    def test_create_user_already_exists(self, user_service, mock_db):\n        \"\"\"Test user creation when user already exists.\"\"\"\n        # Arrange\n        mock_db.user_exists.return_value = True\n\n        # Act &amp; Assert\n        with pytest.raises(ValueError, match=\"User already exists\"):\n            user_service.create_user(\"existing@example.com\", \"Existing User\")\n\n        # Verify email was not sent\n        mock_db.create_user.assert_not_called()\n\n    def test_create_user_email_failure(self, user_service, mock_email_service):\n        \"\"\"Test handling of email service failure.\"\"\"\n        # Arrange\n        mock_email_service.send_welcome_email.side_effect = Exception(\"Email failed\")\n\n        # Act &amp; Assert\n        with pytest.raises(Exception, match=\"Email failed\"):\n            user_service.create_user(\"user@example.com\", \"User\")\n\n    def test_create_multiple_users(self, user_service, mock_db, mock_email_service):\n        \"\"\"Test creating multiple users in sequence.\"\"\"\n        users = [\n            (\"user1@example.com\", \"User One\"),\n            (\"user2@example.com\", \"User Two\"),\n            (\"user3@example.com\", \"User Three\"),\n        ]\n\n        for email, name in users:\n            user_service.create_user(email, name)\n\n        # Verify all calls were made\n        assert mock_db.user_exists.call_count == 3\n        assert mock_db.create_user.call_count == 3\n        assert mock_email_service.send_welcome_email.call_count == 3\n\n        # Verify call order\n        email_calls = [call(email, name) for email, name in users]\n        mock_email_service.send_welcome_email.assert_has_calls(email_calls)\n</code></pre>"},{"location":"examples/testing/#example-3-end-to-end-test-generation","title":"Example 3: End-to-End Test Generation","text":""},{"location":"examples/testing/#web-application-route","title":"Web Application Route","text":"<pre><code>@app.route('/api/login', methods=['POST'])\ndef login():\n    data = request.json\n    username = data.get('username')\n    password = data.get('password')\n\n    if not username or not password:\n        return jsonify({\"error\": \"Missing credentials\"}), 400\n\n    user = authenticate_user(username, password)\n    if not user:\n        return jsonify({\"error\": \"Invalid credentials\"}), 401\n\n    token = generate_token(user)\n    return jsonify({\"token\": token}), 200\n</code></pre>"},{"location":"examples/testing/#test-generation-request_2","title":"Test Generation Request","text":"<pre><code>prompt = \"\"\"\nGenerate end-to-end tests for this login endpoint using pytest and requests.\nTest successful login, missing fields, and invalid credentials.\n\"\"\"\n\nresponse = orchestrator.execute(prompt, agent=\"claude\")\n</code></pre>"},{"location":"examples/testing/#generated-e2e-tests","title":"Generated E2E Tests","text":"<pre><code>import pytest\nimport requests\nimport json\nfrom unittest.mock import patch\n\nclass TestLoginEndToEnd:\n    \"\"\"End-to-end tests for login endpoint.\"\"\"\n\n    @pytest.fixture\n    def base_url(self):\n        \"\"\"Base URL for the API.\"\"\"\n        return \"http://localhost:5000\"\n\n    @pytest.fixture\n    def valid_credentials(self):\n        \"\"\"Valid user credentials.\"\"\"\n        return {\n            \"username\": \"testuser\",\n            \"password\": \"testpass123\"\n        }\n\n    def test_successful_login(self, base_url, valid_credentials):\n        \"\"\"Test successful login returns token.\"\"\"\n        response = requests.post(\n            f\"{base_url}/api/login\",\n            json=valid_credentials,\n            headers={\"Content-Type\": \"application/json\"}\n        )\n\n        assert response.status_code == 200\n        data = response.json()\n        assert \"token\" in data\n        assert len(data[\"token\"]) &gt; 0\n\n    def test_missing_username(self, base_url):\n        \"\"\"Test login with missing username.\"\"\"\n        response = requests.post(\n            f\"{base_url}/api/login\",\n            json={\"password\": \"testpass123\"},\n            headers={\"Content-Type\": \"application/json\"}\n        )\n\n        assert response.status_code == 400\n        data = response.json()\n        assert data[\"error\"] == \"Missing credentials\"\n\n    def test_missing_password(self, base_url):\n        \"\"\"Test login with missing password.\"\"\"\n        response = requests.post(\n            f\"{base_url}/api/login\",\n            json={\"username\": \"testuser\"},\n            headers={\"Content-Type\": \"application/json\"}\n        )\n\n        assert response.status_code == 400\n        data = response.json()\n        assert data[\"error\"] == \"Missing credentials\"\n\n    def test_empty_request_body(self, base_url):\n        \"\"\"Test login with empty request body.\"\"\"\n        response = requests.post(\n            f\"{base_url}/api/login\",\n            json={},\n            headers={\"Content-Type\": \"application/json\"}\n        )\n\n        assert response.status_code == 400\n        data = response.json()\n        assert data[\"error\"] == \"Missing credentials\"\n\n    def test_invalid_credentials(self, base_url):\n        \"\"\"Test login with invalid credentials.\"\"\"\n        response = requests.post(\n            f\"{base_url}/api/login\",\n            json={\n                \"username\": \"wronguser\",\n                \"password\": \"wrongpass\"\n            },\n            headers={\"Content-Type\": \"application/json\"}\n        )\n\n        assert response.status_code == 401\n        data = response.json()\n        assert data[\"error\"] == \"Invalid credentials\"\n\n    @pytest.mark.parametrize(\"content_type\", [\n        \"text/plain\",\n        \"application/xml\",\n        None\n    ])\n    def test_invalid_content_type(self, base_url, valid_credentials, content_type):\n        \"\"\"Test login with invalid content types.\"\"\"\n        headers = {}\n        if content_type:\n            headers[\"Content-Type\"] = content_type\n\n        response = requests.post(\n            f\"{base_url}/api/login\",\n            data=json.dumps(valid_credentials),\n            headers=headers\n        )\n\n        assert response.status_code in [400, 415]\n\n    def test_sql_injection_attempt(self, base_url):\n        \"\"\"Test that SQL injection attempts are handled safely.\"\"\"\n        response = requests.post(\n            f\"{base_url}/api/login\",\n            json={\n                \"username\": \"admin' OR '1'='1\",\n                \"password\": \"' OR '1'='1\"\n            },\n            headers={\"Content-Type\": \"application/json\"}\n        )\n\n        assert response.status_code == 401\n        data = response.json()\n        assert data[\"error\"] == \"Invalid credentials\"\n\n    def test_rate_limiting(self, base_url):\n        \"\"\"Test that rate limiting is enforced.\"\"\"\n        # Make 10 rapid requests\n        for _ in range(10):\n            requests.post(\n                f\"{base_url}/api/login\",\n                json={\"username\": \"test\", \"password\": \"wrong\"},\n                headers={\"Content-Type\": \"application/json\"}\n            )\n\n        # 11th request should be rate limited\n        response = requests.post(\n            f\"{base_url}/api/login\",\n            json={\"username\": \"test\", \"password\": \"wrong\"},\n            headers={\"Content-Type\": \"application/json\"}\n        )\n\n        assert response.status_code == 429  # Too Many Requests\n</code></pre>"},{"location":"examples/testing/#example-4-performance-test-generation","title":"Example 4: Performance Test Generation","text":""},{"location":"examples/testing/#test-generation-request_3","title":"Test Generation Request","text":"<pre><code>prompt = \"\"\"\nGenerate performance tests for a function that processes large datasets.\nInclude tests for execution time, memory usage, and scalability.\n\"\"\"\n\nresponse = orchestrator.execute(prompt, agent=\"claude\")\n</code></pre>"},{"location":"examples/testing/#generated-performance-tests","title":"Generated Performance Tests","text":"<pre><code>import pytest\nimport time\nimport tracemalloc\nfrom memory_profiler import profile\nimport numpy as np\n\nclass TestPerformance:\n    \"\"\"Performance test suite for data processing functions.\"\"\"\n\n    @pytest.fixture\n    def large_dataset(self):\n        \"\"\"Generate a large dataset for testing.\"\"\"\n        return np.random.rand(1000000)\n\n    def test_execution_time(self, large_dataset):\n        \"\"\"Test that processing completes within time limit.\"\"\"\n        start_time = time.perf_counter()\n\n        # Process the data\n        result = process_data(large_dataset)\n\n        end_time = time.perf_counter()\n        execution_time = end_time - start_time\n\n        # Assert execution time is under 1 second\n        assert execution_time &lt; 1.0, f\"Execution took {execution_time:.2f}s\"\n\n    def test_memory_usage(self, large_dataset):\n        \"\"\"Test that memory usage stays within limits.\"\"\"\n        tracemalloc.start()\n\n        # Process the data\n        result = process_data(large_dataset)\n\n        current, peak = tracemalloc.get_traced_memory()\n        tracemalloc.stop()\n\n        # Convert to MB\n        peak_mb = peak / 1024 / 1024\n\n        # Assert memory usage is under 100MB\n        assert peak_mb &lt; 100, f\"Peak memory usage: {peak_mb:.2f}MB\"\n\n    @pytest.mark.parametrize(\"size\", [100, 1000, 10000, 100000])\n    def test_scalability(self, size):\n        \"\"\"Test that performance scales linearly with data size.\"\"\"\n        data = np.random.rand(size)\n\n        start_time = time.perf_counter()\n        result = process_data(data)\n        execution_time = time.perf_counter() - start_time\n\n        # Calculate time per element\n        time_per_element = execution_time / size\n\n        # Assert time per element is roughly constant (with 20% tolerance)\n        expected_time_per_element = 1e-6  # 1 microsecond\n        assert time_per_element &lt; expected_time_per_element * 1.2\n\n    def test_concurrent_processing(self):\n        \"\"\"Test performance under concurrent load.\"\"\"\n        import concurrent.futures\n\n        def process_batch():\n            data = np.random.rand(10000)\n            return process_data(data)\n\n        start_time = time.perf_counter()\n\n        with concurrent.futures.ThreadPoolExecutor(max_workers=4) as executor:\n            futures = [executor.submit(process_batch) for _ in range(10)]\n            results = [f.result() for f in futures]\n\n        execution_time = time.perf_counter() - start_time\n\n        # Should complete 10 batches in under 2 seconds with parallelism\n        assert execution_time &lt; 2.0\n\n    @pytest.mark.benchmark\n    def test_benchmark(self, benchmark):\n        \"\"\"Benchmark the function using pytest-benchmark.\"\"\"\n        data = np.random.rand(10000)\n        result = benchmark(process_data, data)\n\n        # Assertions on benchmark stats\n        assert benchmark.stats[\"mean\"] &lt; 0.01  # Mean time under 10ms\n        assert benchmark.stats[\"stddev\"] &lt; 0.002  # Low variance\n</code></pre>"},{"location":"examples/testing/#test-generation-best-practices","title":"Test Generation Best Practices","text":""},{"location":"examples/testing/#1-coverage-goals","title":"1. Coverage Goals","text":"<ul> <li>Aim for &gt;80% code coverage</li> <li>Test all public methods</li> <li>Include edge cases and error paths</li> </ul>"},{"location":"examples/testing/#2-test-organization","title":"2. Test Organization","text":"<ul> <li>Group related tests in classes</li> <li>Use descriptive test names</li> <li>Follow AAA pattern (Arrange, Act, Assert)</li> </ul>"},{"location":"examples/testing/#3-fixtures-and-mocking","title":"3. Fixtures and Mocking","text":"<ul> <li>Use fixtures for common setup</li> <li>Mock external dependencies</li> <li>Keep tests isolated and independent</li> </ul>"},{"location":"examples/testing/#4-parametrized-tests","title":"4. Parametrized Tests","text":"<ul> <li>Use parametrize for similar test cases</li> <li>Test boundary values</li> <li>Include negative test cases</li> </ul>"},{"location":"examples/testing/#5-performance-testing","title":"5. Performance Testing","text":"<ul> <li>Set realistic performance goals</li> <li>Test with representative data sizes</li> <li>Monitor resource usage</li> </ul>"},{"location":"examples/testing/#see-also","title":"See Also","text":"<ul> <li>Testing Best Practices</li> <li>CI/CD Integration</li> <li>Code Coverage Guide</li> </ul>"},{"location":"examples/web-api/","title":"Building a Web API with Ralph","text":"<p>This example demonstrates how to use Ralph Orchestrator to build a complete REST API with database integration.</p>"},{"location":"examples/web-api/#task-description","title":"Task Description","text":"<p>Create a Flask REST API for a todo list application with: - SQLite database - CRUD operations - Input validation - Error handling - Unit tests</p>"},{"location":"examples/web-api/#promptmd-file","title":"PROMPT.md File","text":"<p><pre><code># Task: Build Todo List REST API\n\nCreate a Flask REST API with the following requirements:\n\n## API Endpoints\n\n1. GET /todos - List all todos\n2. GET /todos/&lt;id&gt; - Get single todo\n3. POST /todos - Create new todo\n4. PUT /todos/&lt;id&gt; - Update todo\n5. DELETE /todos/&lt;id&gt; - Delete todo\n\n## Data Model\n\nTodo:\n- id (integer, primary key)\n- title (string, required, max 200 chars)\n- description (text, optional)\n- completed (boolean, default false)\n- created_at (datetime)\n- updated_at (datetime)\n\n## Requirements\n\n- Use Flask and SQLAlchemy\n- SQLite database\n- Input validation\n- Proper HTTP status codes\n- Error handling with JSON responses\n- Unit tests with pytest\n- README with API documentation\n\n## File Structure\n</code></pre> todo-api/ \u251c\u2500\u2500 app.py           # Main application \u251c\u2500\u2500 models.py        # Database models \u251c\u2500\u2500 schemas.py       # Validation schemas \u251c\u2500\u2500 requirements.txt # Dependencies \u251c\u2500\u2500 test_api.py      # Unit tests \u2514\u2500\u2500 README.md        # Documentation <pre><code>&lt;!-- TASK_COMPLETE will be added when done --&gt;\n</code></pre></p>"},{"location":"examples/web-api/#running-ralph","title":"Running Ralph","text":"<pre><code># Initialize project\nralph init\n\n# Copy prompt to PROMPT.md\ncp web-api-prompt.md PROMPT.md\n\n# Run with Claude (recommended for complex tasks)\nralph run --agent claude --max-iterations 50\n</code></pre>"},{"location":"examples/web-api/#expected-output","title":"Expected Output","text":"<p>Ralph will create the following files:</p>"},{"location":"examples/web-api/#apppy","title":"app.py","text":"<pre><code>from flask import Flask, request, jsonify\nfrom flask_sqlalchemy import SQLAlchemy\nfrom datetime import datetime\nfrom marshmallow import ValidationError\nfrom schemas import TodoSchema\nimport os\n\napp = Flask(__name__)\napp.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///todos.db'\napp.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False\ndb = SQLAlchemy(app)\n\n# Import models after db initialization\nfrom models import Todo\n\n# Create tables\nwith app.app_context():\n    db.create_all()\n\n# Schema instances\ntodo_schema = TodoSchema()\ntodos_schema = TodoSchema(many=True)\n\n@app.route('/todos', methods=['GET'])\ndef get_todos():\n    \"\"\"Get all todos\"\"\"\n    todos = Todo.query.all()\n    return jsonify(todos_schema.dump(todos)), 200\n\n@app.route('/todos/&lt;int:id&gt;', methods=['GET'])\ndef get_todo(id):\n    \"\"\"Get single todo\"\"\"\n    todo = Todo.query.get_or_404(id)\n    return jsonify(todo_schema.dump(todo)), 200\n\n@app.route('/todos', methods=['POST'])\ndef create_todo():\n    \"\"\"Create new todo\"\"\"\n    try:\n        data = todo_schema.load(request.json)\n    except ValidationError as err:\n        return jsonify({'errors': err.messages}), 400\n\n    todo = Todo(**data)\n    db.session.add(todo)\n    db.session.commit()\n\n    return jsonify(todo_schema.dump(todo)), 201\n\n@app.route('/todos/&lt;int:id&gt;', methods=['PUT'])\ndef update_todo(id):\n    \"\"\"Update todo\"\"\"\n    todo = Todo.query.get_or_404(id)\n\n    try:\n        data = todo_schema.load(request.json, partial=True)\n    except ValidationError as err:\n        return jsonify({'errors': err.messages}), 400\n\n    for key, value in data.items():\n        setattr(todo, key, value)\n\n    todo.updated_at = datetime.utcnow()\n    db.session.commit()\n\n    return jsonify(todo_schema.dump(todo)), 200\n\n@app.route('/todos/&lt;int:id&gt;', methods=['DELETE'])\ndef delete_todo(id):\n    \"\"\"Delete todo\"\"\"\n    todo = Todo.query.get_or_404(id)\n    db.session.delete(todo)\n    db.session.commit()\n\n    return '', 204\n\n@app.errorhandler(404)\ndef not_found(error):\n    return jsonify({'error': 'Resource not found'}), 404\n\n@app.errorhandler(500)\ndef internal_error(error):\n    db.session.rollback()\n    return jsonify({'error': 'Internal server error'}), 500\n\nif __name__ == '__main__':\n    app.run(debug=True)\n</code></pre>"},{"location":"examples/web-api/#modelspy","title":"models.py","text":"<pre><code>from datetime import datetime\nfrom app import db\n\nclass Todo(db.Model):\n    __tablename__ = 'todos'\n\n    id = db.Column(db.Integer, primary_key=True)\n    title = db.Column(db.String(200), nullable=False)\n    description = db.Column(db.Text)\n    completed = db.Column(db.Boolean, default=False)\n    created_at = db.Column(db.DateTime, default=datetime.utcnow)\n    updated_at = db.Column(db.DateTime, default=datetime.utcnow)\n\n    def __repr__(self):\n        return f'&lt;Todo {self.id}: {self.title}&gt;'\n</code></pre>"},{"location":"examples/web-api/#test_apipy","title":"test_api.py","text":"<pre><code>import pytest\nimport json\nfrom app import app, db, Todo\n\n@pytest.fixture\ndef client():\n    app.config['TESTING'] = True\n    app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///:memory:'\n\n    with app.test_client() as client:\n        with app.app_context():\n            db.create_all()\n        yield client\n\ndef test_create_todo(client):\n    response = client.post('/todos',\n        json={'title': 'Test Todo', 'description': 'Test description'})\n    assert response.status_code == 201\n    data = json.loads(response.data)\n    assert data['title'] == 'Test Todo'\n\ndef test_get_todos(client):\n    # Create test todo\n    client.post('/todos', json={'title': 'Test'})\n\n    response = client.get('/todos')\n    assert response.status_code == 200\n    data = json.loads(response.data)\n    assert len(data) == 1\n\ndef test_update_todo(client):\n    # Create todo\n    create_response = client.post('/todos', json={'title': 'Original'})\n    todo_id = json.loads(create_response.data)['id']\n\n    # Update todo\n    response = client.put(f'/todos/{todo_id}',\n        json={'title': 'Updated'})\n    assert response.status_code == 200\n    data = json.loads(response.data)\n    assert data['title'] == 'Updated'\n\ndef test_delete_todo(client):\n    # Create todo\n    create_response = client.post('/todos', json={'title': 'Delete Me'})\n    todo_id = json.loads(create_response.data)['id']\n\n    # Delete todo\n    response = client.delete(f'/todos/{todo_id}')\n    assert response.status_code == 204\n\n    # Verify deletion\n    get_response = client.get(f'/todos/{todo_id}')\n    assert get_response.status_code == 404\n</code></pre>"},{"location":"examples/web-api/#monitoring-progress","title":"Monitoring Progress","text":"<pre><code># Watch Ralph's progress\nralph status\n\n# Monitor in real-time\nwatch -n 5 'ralph status'\n\n# Check logs\ntail -f .agent/logs/ralph.log\n</code></pre>"},{"location":"examples/web-api/#iteration-examples","title":"Iteration Examples","text":""},{"location":"examples/web-api/#iteration-1-project-setup","title":"Iteration 1: Project Setup","text":"<ul> <li>Creates project structure</li> <li>Initializes Flask application</li> <li>Sets up SQLAlchemy configuration</li> </ul>"},{"location":"examples/web-api/#iteration-2-5-model-implementation","title":"Iteration 2-5: Model Implementation","text":"<ul> <li>Creates Todo model</li> <li>Implements database schema</li> <li>Sets up migrations</li> </ul>"},{"location":"examples/web-api/#iteration-6-10-api-endpoints","title":"Iteration 6-10: API Endpoints","text":"<ul> <li>Implements CRUD operations</li> <li>Adds routing</li> <li>Handles HTTP methods</li> </ul>"},{"location":"examples/web-api/#iteration-11-15-validation","title":"Iteration 11-15: Validation","text":"<ul> <li>Adds input validation</li> <li>Implements error handling</li> <li>Creates response schemas</li> </ul>"},{"location":"examples/web-api/#iteration-16-20-testing","title":"Iteration 16-20: Testing","text":"<ul> <li>Writes unit tests</li> <li>Ensures coverage</li> <li>Fixes any issues</li> </ul>"},{"location":"examples/web-api/#final-iteration","title":"Final Iteration","text":"<ul> <li>Creates README</li> <li>Adds requirements.txt</li> <li>Marks TASK_COMPLETE</li> </ul>"},{"location":"examples/web-api/#tips-for-success","title":"Tips for Success","text":"<ol> <li>Clear Requirements: Be specific about API endpoints and data models</li> <li>Include Examples: Provide sample requests/responses if needed</li> <li>Test Requirements: Specify testing framework and coverage expectations</li> <li>Error Handling: Explicitly request proper error handling</li> <li>Documentation: Ask for API documentation in README</li> </ol>"},{"location":"examples/web-api/#common-issues-and-solutions","title":"Common Issues and Solutions","text":""},{"location":"examples/web-api/#issue-database-connection-errors","title":"Issue: Database Connection Errors","text":"<pre><code># Add to prompt:\nEnsure database is properly initialized before first request.\nUse app.app_context() for database operations.\n</code></pre>"},{"location":"examples/web-api/#issue-import-circular-dependencies","title":"Issue: Import Circular Dependencies","text":"<pre><code># Add to prompt:\nAvoid circular imports by importing models after db initialization.\nUse application factory pattern if needed.\n</code></pre>"},{"location":"examples/web-api/#issue-test-failures","title":"Issue: Test Failures","text":"<pre><code># Add to prompt:\nUse in-memory SQLite database for tests.\nEnsure proper test isolation with fixtures.\n</code></pre>"},{"location":"examples/web-api/#extending-the-example","title":"Extending the Example","text":""},{"location":"examples/web-api/#add-authentication","title":"Add Authentication","text":"<pre><code>## Additional Requirements\n- JWT authentication\n- User registration and login\n- Protected endpoints\n- Role-based access control\n</code></pre>"},{"location":"examples/web-api/#add-pagination","title":"Add Pagination","text":"<pre><code>## Additional Requirements\n- Paginate GET /todos endpoint\n- Support page and per_page parameters\n- Return pagination metadata\n</code></pre>"},{"location":"examples/web-api/#add-filtering","title":"Add Filtering","text":"<pre><code>## Additional Requirements\n- Filter todos by completed status\n- Search todos by title\n- Sort by created_at or updated_at\n</code></pre>"},{"location":"examples/web-api/#cost-estimation","title":"Cost Estimation","text":"<ul> <li>Iterations: ~20-30 for complete implementation</li> <li>Time: ~10-15 minutes</li> <li>Agent: Claude recommended for complex logic</li> <li>API Calls: ~$0.20-0.30 (Claude pricing)</li> </ul>"},{"location":"examples/web-api/#verification","title":"Verification","text":"<p>After Ralph completes:</p> <pre><code># Install dependencies\npip install -r requirements.txt\n\n# Run tests\npytest test_api.py -v\n\n# Start server\npython app.py\n\n# Test endpoints\ncurl http://localhost:5000/todos\ncurl -X POST http://localhost:5000/todos \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"title\": \"Test Todo\"}'\n</code></pre>"},{"location":"guide/agents/","title":"AI Agents Guide","text":"<p>Ralph Orchestrator supports multiple AI agents, each with unique capabilities and cost structures. This guide helps you choose and configure the right agent for your task.</p>"},{"location":"guide/agents/#supported-agents","title":"Supported Agents","text":""},{"location":"guide/agents/#claude-anthropic","title":"Claude (Anthropic)","text":"<p>Claude is Anthropic's advanced AI assistant, known for nuanced understanding and high-quality outputs.</p> <p>Strengths: - Excellent code generation and debugging - Strong reasoning and analysis - Comprehensive documentation writing - Ethical and safe responses - Large context window (200K tokens)</p> <p>Best For: - Complex software development - Technical documentation - Research and analysis - Creative writing - Problem-solving requiring deep reasoning</p> <p>Installation: <pre><code>npm install -g @anthropic-ai/claude-cli\n</code></pre></p> <p>Usage: <pre><code>python ralph_orchestrator.py --agent claude\n</code></pre></p> <p>Cost: - Input: $3.00 per million tokens - Output: $15.00 per million tokens</p>"},{"location":"guide/agents/#q-chat","title":"Q Chat","text":"<p>Q Chat is a cost-effective AI assistant suitable for many general tasks.</p> <p>Strengths: - Good general-purpose capabilities - Fast response times - Cost-effective for simple tasks - Reliable for straightforward operations</p> <p>Best For: - Simple coding tasks - Basic documentation - Data processing - Quick prototypes - Budget-conscious operations</p> <p>Installation: <pre><code>pip install q-cli\n</code></pre></p> <p>Usage: <pre><code>python ralph_orchestrator.py --agent q\n</code></pre></p> <p>Cost: - Input: $0.50 per million tokens (estimated) - Output: $1.50 per million tokens (estimated)</p>"},{"location":"guide/agents/#gemini-google","title":"Gemini (Google)","text":"<p>Google's Gemini offers strong capabilities with multimodal understanding.</p> <p>Strengths: - Excellent at data analysis - Strong mathematical capabilities - Good code understanding - Multimodal capabilities (Pro version) - Competitive pricing</p> <p>Best For: - Data science tasks - Mathematical computations - Code analysis - Research tasks - Multi-language support</p> <p>Installation: <pre><code>pip install google-generativeai\n</code></pre></p> <p>Usage: <pre><code>python ralph_orchestrator.py --agent gemini\n</code></pre></p> <p>Cost: - Input: $0.50 per million tokens - Output: $1.50 per million tokens</p>"},{"location":"guide/agents/#auto-detection","title":"Auto-Detection","text":"<p>Ralph Orchestrator can automatically detect and use available agents:</p> <pre><code>python ralph_orchestrator.py --agent auto\n</code></pre> <p>Detection Order: 1. Claude (if installed) 2. Q Chat (if installed) 3. Gemini (if installed)</p>"},{"location":"guide/agents/#agent-comparison","title":"Agent Comparison","text":"Feature Claude Q Chat Gemini Context Window 200K 100K 128K Code Quality Excellent Good Very Good Documentation Excellent Good Good Speed Moderate Fast Fast Cost High Low Low Reasoning Excellent Good Very Good Creativity Excellent Good Good Math/Data Very Good Good Excellent"},{"location":"guide/agents/#choosing-the-right-agent","title":"Choosing the Right Agent","text":""},{"location":"guide/agents/#decision-tree","title":"Decision Tree","text":"<pre><code>graph TD\n    A[Select Agent] --&gt; B{Task Type?}\n    B --&gt;|Complex Code| C[Claude]\n    B --&gt;|Simple Task| D{Budget?}\n    B --&gt;|Data Analysis| E[Gemini]\n    D --&gt;|Limited| F[Q Chat]\n    D --&gt;|Flexible| G[Claude/Gemini]\n    B --&gt;|Documentation| H{Quality Need?}\n    H --&gt;|High| I[Claude]\n    H --&gt;|Standard| J[Q Chat/Gemini]</code></pre>"},{"location":"guide/agents/#task-agent-mapping","title":"Task-Agent Mapping","text":"Task Type Recommended Agent Alternative Web API Development Claude Gemini CLI Tool Creation Claude Q Chat Data Processing Gemini Claude Documentation Claude Gemini Testing Claude Q Chat Refactoring Claude Gemini Simple Scripts Q Chat Gemini Research Claude Gemini Prototyping Q Chat Gemini Production Code Claude -"},{"location":"guide/agents/#agent-configuration","title":"Agent Configuration","text":""},{"location":"guide/agents/#claude-configuration","title":"Claude Configuration","text":"<pre><code># Standard Claude usage\npython ralph_orchestrator.py --agent claude\n\n# With specific model\npython ralph_orchestrator.py \\\n  --agent claude \\\n  --agent-args \"--model claude-3-sonnet-20240229\"\n\n# With custom parameters\npython ralph_orchestrator.py \\\n  --agent claude \\\n  --agent-args \"--temperature 0.7 --max-tokens 4096\"\n</code></pre>"},{"location":"guide/agents/#q-chat-configuration","title":"Q Chat Configuration","text":"<pre><code># Standard Q usage\npython ralph_orchestrator.py --agent q\n\n# With custom parameters\npython ralph_orchestrator.py \\\n  --agent q \\\n  --agent-args \"--context-length 50000\"\n</code></pre>"},{"location":"guide/agents/#gemini-configuration","title":"Gemini Configuration","text":"<pre><code># Standard Gemini usage\npython ralph_orchestrator.py --agent gemini\n\n# With specific model\npython ralph_orchestrator.py \\\n  --agent gemini \\\n  --agent-args \"--model gemini-pro\"\n</code></pre>"},{"location":"guide/agents/#agent-specific-features","title":"Agent-Specific Features","text":""},{"location":"guide/agents/#claude-features","title":"Claude Features","text":"<ul> <li>Constitutional AI: Built-in safety and ethics</li> <li>Code Understanding: Deep comprehension of complex codebases</li> <li>Long Context: Handles up to 200K tokens</li> <li>Nuanced Responses: Understands subtle requirements</li> </ul> <pre><code># Leverage Claude's long context\npython ralph_orchestrator.py \\\n  --agent claude \\\n  --context-window 200000 \\\n  --context-threshold 0.9\n</code></pre>"},{"location":"guide/agents/#q-chat-features","title":"Q Chat Features","text":"<ul> <li>Speed: Fast response times</li> <li>Efficiency: Lower resource usage</li> <li>Simplicity: Straightforward for basic tasks</li> </ul> <pre><code># Quick iterations with Q\npython ralph_orchestrator.py \\\n  --agent q \\\n  --max-iterations 100 \\\n  --retry-delay 1\n</code></pre>"},{"location":"guide/agents/#gemini-features","title":"Gemini Features","text":"<ul> <li>Data Excellence: Superior at data tasks</li> <li>Mathematical Prowess: Strong calculation abilities</li> <li>Multi-language: Good support for various programming languages</li> </ul> <pre><code># Data processing with Gemini\npython ralph_orchestrator.py \\\n  --agent gemini \\\n  --prompt data_analysis.md\n</code></pre>"},{"location":"guide/agents/#multi-agent-strategies","title":"Multi-Agent Strategies","text":""},{"location":"guide/agents/#sequential-processing","title":"Sequential Processing","text":"<p>Process with different agents for different phases:</p> <pre><code># Phase 1: Research with Claude\npython ralph_orchestrator.py --agent claude --prompt research.md\n\n# Phase 2: Implementation with Q\npython ralph_orchestrator.py --agent q --prompt implement.md\n\n# Phase 3: Documentation with Claude\npython ralph_orchestrator.py --agent claude --prompt document.md\n</code></pre>"},{"location":"guide/agents/#cost-optimization","title":"Cost Optimization","text":"<p>Start with cheaper agents, escalate if needed:</p> <pre><code># Try Q first\npython ralph_orchestrator.py --agent q --max-cost 2.0\n\n# If unsuccessful, try Claude\npython ralph_orchestrator.py --agent claude --max-cost 20.0\n</code></pre>"},{"location":"guide/agents/#agent-performance-tuning","title":"Agent Performance Tuning","text":""},{"location":"guide/agents/#claude-optimization","title":"Claude Optimization","text":"<pre><code># Optimized for quality\npython ralph_orchestrator.py \\\n  --agent claude \\\n  --max-iterations 50 \\\n  --checkpoint-interval 5 \\\n  --context-window 200000\n\n# Optimized for speed\npython ralph_orchestrator.py \\\n  --agent claude \\\n  --max-iterations 20 \\\n  --retry-delay 1\n</code></pre>"},{"location":"guide/agents/#q-chat-optimization","title":"Q Chat Optimization","text":"<pre><code># Maximum efficiency\npython ralph_orchestrator.py \\\n  --agent q \\\n  --max-iterations 200 \\\n  --checkpoint-interval 20 \\\n  --metrics-interval 50\n</code></pre>"},{"location":"guide/agents/#gemini-optimization","title":"Gemini Optimization","text":"<pre><code># Data-heavy tasks\npython ralph_orchestrator.py \\\n  --agent gemini \\\n  --context-window 128000 \\\n  --max-tokens 500000\n</code></pre>"},{"location":"guide/agents/#troubleshooting-agents","title":"Troubleshooting Agents","text":""},{"location":"guide/agents/#common-issues","title":"Common Issues","text":"<ol> <li> <p>Agent Not Found <pre><code># Check installation\nwhich claude  # or q, gemini\n\n# Use auto-detection\npython ralph_orchestrator.py --agent auto --dry-run\n</code></pre></p> </li> <li> <p>Rate Limiting <pre><code># Increase retry delay\npython ralph_orchestrator.py --retry-delay 10\n</code></pre></p> </li> <li> <p>Context Overflow <pre><code># Adjust context settings\npython ralph_orchestrator.py \\\n  --context-window 100000 \\\n  --context-threshold 0.7\n</code></pre></p> </li> <li> <p>Poor Output Quality <pre><code># Switch to higher-quality agent\npython ralph_orchestrator.py --agent claude\n</code></pre></p> </li> </ol>"},{"location":"guide/agents/#agent-diagnostics","title":"Agent Diagnostics","text":"<pre><code># Test agent availability\npython ralph_orchestrator.py --agent auto --dry-run --verbose\n\n# Check agent performance\npython ralph_orchestrator.py \\\n  --agent claude \\\n  --max-iterations 1 \\\n  --verbose \\\n  --metrics-interval 1\n</code></pre>"},{"location":"guide/agents/#cost-management-by-agent","title":"Cost Management by Agent","text":""},{"location":"guide/agents/#budget-allocation","title":"Budget Allocation","text":"<pre><code># Low budget: Use Q\npython ralph_orchestrator.py --agent q --max-cost 5.0\n\n# Medium budget: Use Gemini\npython ralph_orchestrator.py --agent gemini --max-cost 25.0\n\n# High budget: Use Claude\npython ralph_orchestrator.py --agent claude --max-cost 100.0\n</code></pre>"},{"location":"guide/agents/#cost-tracking","title":"Cost Tracking","text":"<p>Monitor costs per agent:</p> <pre><code># Enable detailed metrics\npython ralph_orchestrator.py \\\n  --agent claude \\\n  --metrics-interval 1 \\\n  --verbose\n</code></pre>"},{"location":"guide/agents/#best-practices","title":"Best Practices","text":""},{"location":"guide/agents/#1-match-agent-to-task","title":"1. Match Agent to Task","text":"<ul> <li>Complex logic: Use Claude</li> <li>Simple tasks: Use Q Chat</li> <li>Data work: Use Gemini</li> </ul>"},{"location":"guide/agents/#2-start-small","title":"2. Start Small","text":"<p>Test with few iterations first:</p> <pre><code>python ralph_orchestrator.py --agent auto --max-iterations 5\n</code></pre>"},{"location":"guide/agents/#3-monitor-performance","title":"3. Monitor Performance","text":"<p>Track metrics for optimization:</p> <pre><code>python ralph_orchestrator.py --metrics-interval 5 --verbose\n</code></pre>"},{"location":"guide/agents/#4-use-auto-detection","title":"4. Use Auto-Detection","text":"<p>Let the system choose when unsure:</p> <pre><code>python ralph_orchestrator.py --agent auto\n</code></pre>"},{"location":"guide/agents/#5-consider-costs","title":"5. Consider Costs","text":"<p>Balance quality with budget:</p> <ul> <li>Development: Use Q Chat</li> <li>Testing: Use Gemini</li> <li>Production: Use Claude</li> </ul>"},{"location":"guide/agents/#next-steps","title":"Next Steps","text":"<ul> <li>Master Prompt Engineering for better results</li> <li>Learn about Cost Management</li> <li>Understand Checkpointing strategies</li> <li>Explore Configuration options</li> </ul>"},{"location":"guide/checkpointing/","title":"Checkpointing and Recovery Guide","text":"<p>Ralph Orchestrator provides robust checkpointing mechanisms to ensure work is never lost and tasks can be resumed after interruptions.</p>"},{"location":"guide/checkpointing/#overview","title":"Overview","text":"<p>Checkpointing saves the state of your orchestration at regular intervals, enabling: - Recovery from crashes or interruptions - Progress tracking across iterations - State inspection for debugging - Audit trails for compliance</p>"},{"location":"guide/checkpointing/#checkpoint-types","title":"Checkpoint Types","text":""},{"location":"guide/checkpointing/#1-git-checkpoints","title":"1. Git Checkpoints","text":"<p>Automatic git commits at specified intervals:</p> <pre><code># Enable git checkpointing (default)\npython ralph_orchestrator.py --checkpoint-interval 5\n\n# Disable git checkpointing\npython ralph_orchestrator.py --no-git\n</code></pre> <p>What's saved: - Current prompt file state - Any files created/modified by the agent - Timestamp and iteration number</p>"},{"location":"guide/checkpointing/#2-prompt-archives","title":"2. Prompt Archives","text":"<p>Historical versions of the prompt file:</p> <pre><code># Enable prompt archiving (default)\npython ralph_orchestrator.py\n\n# Disable prompt archiving\npython ralph_orchestrator.py --no-archive\n</code></pre> <p>Location: <code>.agent/prompts/prompt_YYYYMMDD_HHMMSS.md</code></p>"},{"location":"guide/checkpointing/#3-state-snapshots","title":"3. State Snapshots","text":"<p>JSON files containing orchestrator state:</p> <pre><code>{\n  \"iteration\": 15,\n  \"agent\": \"claude\",\n  \"start_time\": \"2024-01-10T10:00:00\",\n  \"tokens_used\": 50000,\n  \"cost_incurred\": 2.50,\n  \"status\": \"running\"\n}\n</code></pre> <p>Location: <code>.agent/metrics/state_*.json</code></p>"},{"location":"guide/checkpointing/#configuration","title":"Configuration","text":""},{"location":"guide/checkpointing/#checkpoint-interval","title":"Checkpoint Interval","text":"<p>Control how often checkpoints occur:</p> <pre><code># Checkpoint every iteration (maximum safety)\npython ralph_orchestrator.py --checkpoint-interval 1\n\n# Checkpoint every 10 iterations (balanced)\npython ralph_orchestrator.py --checkpoint-interval 10\n\n# Checkpoint every 50 iterations (minimal overhead)\npython ralph_orchestrator.py --checkpoint-interval 50\n</code></pre>"},{"location":"guide/checkpointing/#checkpoint-strategies","title":"Checkpoint Strategies","text":""},{"location":"guide/checkpointing/#aggressive-checkpointing","title":"Aggressive Checkpointing","text":"<p>For critical or experimental tasks:</p> <pre><code>python ralph_orchestrator.py \\\n  --checkpoint-interval 1 \\\n  --metrics-interval 1 \\\n  --verbose\n</code></pre>"},{"location":"guide/checkpointing/#balanced-checkpointing","title":"Balanced Checkpointing","text":"<p>For standard production tasks:</p> <pre><code>python ralph_orchestrator.py \\\n  --checkpoint-interval 5 \\\n  --metrics-interval 10\n</code></pre>"},{"location":"guide/checkpointing/#minimal-checkpointing","title":"Minimal Checkpointing","text":"<p>For simple, fast tasks:</p> <pre><code>python ralph_orchestrator.py \\\n  --checkpoint-interval 20 \\\n  --no-archive\n</code></pre>"},{"location":"guide/checkpointing/#recovery-procedures","title":"Recovery Procedures","text":""},{"location":"guide/checkpointing/#automatic-recovery","title":"Automatic Recovery","text":"<p>Ralph Orchestrator automatically recovers from the last checkpoint:</p> <ol> <li>Detect interruption</li> <li>Load last checkpoint</li> <li>Resume from last known state</li> <li>Continue iteration</li> </ol>"},{"location":"guide/checkpointing/#manual-recovery","title":"Manual Recovery","text":""},{"location":"guide/checkpointing/#from-git-checkpoint","title":"From Git Checkpoint","text":"<pre><code># View checkpoint history\ngit log --oneline | grep \"Ralph checkpoint\"\n\n# Restore specific checkpoint\ngit checkout &lt;commit-hash&gt;\n\n# Resume orchestration\npython ralph_orchestrator.py --prompt PROMPT.md\n</code></pre>"},{"location":"guide/checkpointing/#from-prompt-archive","title":"From Prompt Archive","text":"<pre><code># List archived prompts\nls -la .agent/prompts/\n\n# Restore archived prompt\ncp .agent/prompts/prompt_20240110_100000.md PROMPT.md\n\n# Resume orchestration\npython ralph_orchestrator.py\n</code></pre>"},{"location":"guide/checkpointing/#from-state-snapshot","title":"From State Snapshot","text":"<pre><code># Load state programmatically\nimport json\n\nwith open('.agent/metrics/state_20240110_100000.json') as f:\n    state = json.load(f)\n\nprint(f\"Last iteration: {state['iteration']}\")\nprint(f\"Tokens used: {state['tokens_used']}\")\nprint(f\"Cost incurred: ${state['cost_incurred']}\")\n</code></pre>"},{"location":"guide/checkpointing/#checkpoint-storage","title":"Checkpoint Storage","text":""},{"location":"guide/checkpointing/#directory-structure","title":"Directory Structure","text":"<pre><code>.agent/\n\u251c\u2500\u2500 checkpoints/       # Git checkpoint metadata\n\u251c\u2500\u2500 prompts/          # Archived prompt files\n\u2502   \u251c\u2500\u2500 prompt_20240110_100000.md\n\u2502   \u251c\u2500\u2500 prompt_20240110_101500.md\n\u2502   \u2514\u2500\u2500 prompt_20240110_103000.md\n\u251c\u2500\u2500 metrics/          # State and metrics\n\u2502   \u251c\u2500\u2500 state_20240110_100000.json\n\u2502   \u251c\u2500\u2500 state_20240110_101500.json\n\u2502   \u2514\u2500\u2500 metrics_20240110_103000.json\n\u2514\u2500\u2500 logs/            # Execution logs\n</code></pre>"},{"location":"guide/checkpointing/#storage-management","title":"Storage Management","text":""},{"location":"guide/checkpointing/#clean-old-checkpoints","title":"Clean Old Checkpoints","text":"<pre><code># Remove checkpoints older than 7 days\nfind .agent/prompts -mtime +7 -delete\nfind .agent/metrics -name \"*.json\" -mtime +7 -delete\n\n# Keep only last 100 checkpoints\nls -t .agent/prompts/*.md | tail -n +101 | xargs rm -f\n</code></pre>"},{"location":"guide/checkpointing/#backup-checkpoints","title":"Backup Checkpoints","text":"<pre><code># Create backup archive\ntar -czf ralph_checkpoints_$(date +%Y%m%d).tar.gz .agent/\n\n# Backup to remote\nrsync -av .agent/ user@backup-server:/backups/ralph/\n</code></pre>"},{"location":"guide/checkpointing/#advanced-checkpointing","title":"Advanced Checkpointing","text":""},{"location":"guide/checkpointing/#custom-checkpoint-triggers","title":"Custom Checkpoint Triggers","text":"<p>Beyond interval-based checkpointing, you can trigger checkpoints in your prompt:</p> <pre><code>## Progress\n- Step 1 complete [CHECKPOINT]\n- Step 2 complete [CHECKPOINT]\n- Step 3 complete [CHECKPOINT]\n</code></pre>"},{"location":"guide/checkpointing/#checkpoint-hooks","title":"Checkpoint Hooks","text":"<p>Use git hooks for custom checkpoint processing:</p> <pre><code># .git/hooks/post-commit\n#!/bin/bash\nif [[ $1 == *\"Ralph checkpoint\"* ]]; then\n    # Custom backup or notification\n    cp PROMPT.md /backup/location/\n    echo \"Checkpoint created\" | mail -s \"Ralph Progress\" admin@example.com\nfi\n</code></pre>"},{"location":"guide/checkpointing/#distributed-checkpointing","title":"Distributed Checkpointing","text":"<p>For team environments:</p> <pre><code># Push checkpoints to shared repository\npython ralph_orchestrator.py --checkpoint-interval 5\n\n# In another terminal/machine\ngit pull  # Get latest checkpoints\n\n# Or use automated sync\nwatch -n 60 'git pull'\n</code></pre>"},{"location":"guide/checkpointing/#best-practices","title":"Best Practices","text":""},{"location":"guide/checkpointing/#1-choose-appropriate-intervals","title":"1. Choose Appropriate Intervals","text":"Task Type Recommended Interval Rationale Experimental 1-2 Maximum recovery points Development 5-10 Balance safety/performance Production 10-20 Minimize overhead Simple 20-50 Low risk tasks"},{"location":"guide/checkpointing/#2-monitor-checkpoint-size","title":"2. Monitor Checkpoint Size","text":"<pre><code># Check checkpoint storage usage\ndu -sh .agent/\n\n# Monitor growth\nwatch -n 60 'du -sh .agent/*'\n</code></pre>"},{"location":"guide/checkpointing/#3-test-recovery","title":"3. Test Recovery","text":"<p>Regularly test recovery procedures:</p> <pre><code># Simulate interruption\npython ralph_orchestrator.py &amp;\nPID=$!\nsleep 30\nkill $PID\n\n# Verify recovery\npython ralph_orchestrator.py  # Should resume\n</code></pre>"},{"location":"guide/checkpointing/#4-clean-up-regularly","title":"4. Clean Up Regularly","text":"<p>Implement checkpoint rotation:</p> <pre><code># Keep last 50 checkpoints\n#!/bin/bash\nMAX_CHECKPOINTS=50\nCOUNT=$(ls .agent/prompts/*.md 2&gt;/dev/null | wc -l)\nif [ $COUNT -gt $MAX_CHECKPOINTS ]; then\n    ls -t .agent/prompts/*.md | tail -n +$(($MAX_CHECKPOINTS+1)) | xargs rm\nfi\n</code></pre>"},{"location":"guide/checkpointing/#troubleshooting","title":"Troubleshooting","text":""},{"location":"guide/checkpointing/#common-issues","title":"Common Issues","text":""},{"location":"guide/checkpointing/#1-git-checkpointing-fails","title":"1. Git Checkpointing Fails","text":"<p>Error: \"Not a git repository\"</p> <p>Solution: <pre><code># Initialize git repository\ngit init\ngit add .\ngit commit -m \"Initial commit\"\n\n# Or disable git checkpointing\npython ralph_orchestrator.py --no-git\n</code></pre></p>"},{"location":"guide/checkpointing/#2-checkpoint-storage-full","title":"2. Checkpoint Storage Full","text":"<p>Error: \"No space left on device\"</p> <p>Solution: <pre><code># Clean old checkpoints\nfind .agent -type f -mtime +30 -delete\n\n# Move to larger storage\nmv .agent /larger/disk/\nln -s /larger/disk/.agent .agent\n</code></pre></p>"},{"location":"guide/checkpointing/#3-corrupted-checkpoint","title":"3. Corrupted Checkpoint","text":"<p>Error: \"Invalid checkpoint data\"</p> <p>Solution: <pre><code># Use previous checkpoint\nls -la .agent/prompts/  # Find earlier version\ncp .agent/prompts/prompt_EARLIER.md PROMPT.md\n</code></pre></p>"},{"location":"guide/checkpointing/#recovery-validation","title":"Recovery Validation","text":"<p>Verify checkpoint integrity:</p> <pre><code>#!/usr/bin/env python3\nimport json\nimport os\nfrom pathlib import Path\n\ndef validate_checkpoints():\n    checkpoint_dir = Path('.agent/metrics')\n    for state_file in checkpoint_dir.glob('state_*.json'):\n        try:\n            with open(state_file) as f:\n                data = json.load(f)\n                assert 'iteration' in data\n                assert 'agent' in data\n                print(f\"\u2713 {state_file.name}\")\n        except Exception as e:\n            print(f\"\u2717 {state_file.name}: {e}\")\n\nvalidate_checkpoints()\n</code></pre>"},{"location":"guide/checkpointing/#performance-impact","title":"Performance Impact","text":""},{"location":"guide/checkpointing/#checkpoint-overhead","title":"Checkpoint Overhead","text":"Interval Overhead Use Case 1 High (5-10%) Critical tasks 5 Moderate (2-5%) Standard tasks 10 Low (1-2%) Long tasks 20+ Minimal (&lt;1%) Simple tasks"},{"location":"guide/checkpointing/#optimization-tips","title":"Optimization Tips","text":"<ol> <li>Use SSDs for checkpoint storage</li> <li>Disable unnecessary features (e.g., <code>--no-archive</code> if not needed)</li> <li>Adjust intervals based on task criticality</li> <li>Clean up regularly to maintain performance</li> </ol>"},{"location":"guide/checkpointing/#integration","title":"Integration","text":""},{"location":"guide/checkpointing/#cicd-integration","title":"CI/CD Integration","text":"<pre><code># .github/workflows/ralph.yml\nname: Ralph Orchestration\non:\n  push:\n    branches: [main]\n\njobs:\n  orchestrate:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v2\n\n      - name: Run Ralph\n        run: |\n          python ralph_orchestrator.py \\\n            --checkpoint-interval 10 \\\n            --max-iterations 100\n\n      - name: Save Checkpoints\n        uses: actions/upload-artifact@v2\n        with:\n          name: ralph-checkpoints\n          path: .agent/\n</code></pre>"},{"location":"guide/checkpointing/#monitoring-integration","title":"Monitoring Integration","text":"<pre><code># Send checkpoint events to monitoring\n#!/bin/bash\nCHECKPOINT_COUNT=$(ls .agent/prompts/*.md 2&gt;/dev/null | wc -l)\ncurl -X POST https://metrics.example.com/api/v1/metrics \\\n  -d \"ralph.checkpoints.count=$CHECKPOINT_COUNT\"\n</code></pre>"},{"location":"guide/checkpointing/#next-steps","title":"Next Steps","text":"<ul> <li>Learn about Cost Management to optimize checkpoint costs</li> <li>Explore Configuration for checkpoint options</li> <li>Review Troubleshooting for recovery issues</li> <li>See Examples for checkpoint patterns</li> </ul>"},{"location":"guide/configuration/","title":"Configuration Guide","text":"<p>Ralph Orchestrator provides extensive configuration options to control execution, manage costs, and ensure safe operation. This guide covers all configuration parameters and best practices.</p>"},{"location":"guide/configuration/#configuration-methods","title":"Configuration Methods","text":""},{"location":"guide/configuration/#1-command-line-arguments","title":"1. Command Line Arguments","text":"<p>The primary way to configure Ralph Orchestrator is through command-line arguments:</p> <pre><code>python ralph_orchestrator.py --agent claude --max-iterations 50 --max-cost 25.0\n</code></pre>"},{"location":"guide/configuration/#2-environment-variables","title":"2. Environment Variables","text":"<p>Some settings can be configured via environment variables:</p> <pre><code>export RALPH_AGENT=claude\nexport RALPH_MAX_COST=25.0\npython ralph_orchestrator.py\n</code></pre>"},{"location":"guide/configuration/#3-configuration-file-future","title":"3. Configuration File (Future)","text":"<p>Configuration file support is planned for future releases.</p>"},{"location":"guide/configuration/#core-configuration-options","title":"Core Configuration Options","text":""},{"location":"guide/configuration/#agent-selection","title":"Agent Selection","text":"Parameter Default Description <code>--agent</code> <code>auto</code> AI agent to use: <code>claude</code>, <code>q</code>, <code>gemini</code>, or <code>auto</code> <code>--agent-args</code> None Additional arguments to pass to the agent <p>Example: <pre><code># Use Claude specifically\npython ralph_orchestrator.py --agent claude\n\n# Auto-detect available agent\npython ralph_orchestrator.py --agent auto\n\n# Pass additional arguments to agent\npython ralph_orchestrator.py --agent claude --agent-args \"--model claude-3-sonnet\"\n</code></pre></p>"},{"location":"guide/configuration/#prompt-configuration","title":"Prompt Configuration","text":"Parameter Default Description <code>--prompt</code> <code>PROMPT.md</code> Path to the prompt file <code>--max-prompt-size</code> 10MB Maximum allowed prompt file size <p>Example: <pre><code># Use custom prompt file\npython ralph_orchestrator.py --prompt tasks/my-task.md\n\n# Set maximum prompt size (in bytes)\npython ralph_orchestrator.py --max-prompt-size 5242880  # 5MB\n</code></pre></p>"},{"location":"guide/configuration/#execution-limits","title":"Execution Limits","text":""},{"location":"guide/configuration/#iteration-and-runtime","title":"Iteration and Runtime","text":"Parameter Default Description <code>--max-iterations</code> 100 Maximum number of iterations <code>--max-runtime</code> 14400 Maximum runtime in seconds (4 hours) <p>Example: <pre><code># Quick task with few iterations\npython ralph_orchestrator.py --max-iterations 10 --max-runtime 600\n\n# Long-running task\npython ralph_orchestrator.py --max-iterations 500 --max-runtime 86400  # 24 hours\n</code></pre></p>"},{"location":"guide/configuration/#token-and-cost-management","title":"Token and Cost Management","text":"Parameter Default Description <code>--max-tokens</code> 1,000,000 Maximum total tokens to use <code>--max-cost</code> 50.0 Maximum cost in USD <code>--context-window</code> 200,000 Context window size in tokens <code>--context-threshold</code> 0.8 Trigger summarization at this % of context <p>Example: <pre><code># Budget-conscious configuration\npython ralph_orchestrator.py \\\n  --max-tokens 100000 \\\n  --max-cost 5.0 \\\n  --context-window 100000\n\n# High-capacity configuration\npython ralph_orchestrator.py \\\n  --max-tokens 5000000 \\\n  --max-cost 200.0 \\\n  --context-window 500000\n</code></pre></p>"},{"location":"guide/configuration/#checkpointing-and-recovery","title":"Checkpointing and Recovery","text":"Parameter Default Description <code>--checkpoint-interval</code> 5 Iterations between checkpoints <code>--no-git</code> False Disable git checkpointing <code>--no-archive</code> False Disable prompt archiving <p>Example: <pre><code># Frequent checkpoints for critical tasks\npython ralph_orchestrator.py --checkpoint-interval 1\n\n# Disable git operations (for non-git directories)\npython ralph_orchestrator.py --no-git\n\n# Minimal persistence\npython ralph_orchestrator.py --no-git --no-archive\n</code></pre></p>"},{"location":"guide/configuration/#monitoring-and-debugging","title":"Monitoring and Debugging","text":"Parameter Default Description <code>--metrics-interval</code> 10 Iterations between metrics logs <code>--no-metrics</code> False Disable metrics collection <code>--verbose</code> False Enable verbose logging <code>--dry-run</code> False Test configuration without execution <p>Example: <pre><code># Verbose monitoring\npython ralph_orchestrator.py --verbose --metrics-interval 1\n\n# Test configuration\npython ralph_orchestrator.py --dry-run --verbose\n\n# Minimal logging\npython ralph_orchestrator.py --no-metrics\n</code></pre></p>"},{"location":"guide/configuration/#security-options","title":"Security Options","text":"Parameter Default Description <code>--allow-unsafe-paths</code> False Allow potentially unsafe file paths <p>Example: <pre><code># Standard security (recommended)\npython ralph_orchestrator.py\n\n# Allow unsafe paths (use with caution)\npython ralph_orchestrator.py --allow-unsafe-paths\n</code></pre></p>"},{"location":"guide/configuration/#retry-and-recovery","title":"Retry and Recovery","text":"Parameter Default Description <code>--retry-delay</code> 2 Delay between retries in seconds <p>Example: <pre><code># Slower retry for rate-limited APIs\npython ralph_orchestrator.py --retry-delay 10\n\n# Fast retry for local agents\npython ralph_orchestrator.py --retry-delay 1\n</code></pre></p>"},{"location":"guide/configuration/#configuration-profiles","title":"Configuration Profiles","text":""},{"location":"guide/configuration/#development-profile","title":"Development Profile","text":"<p>For local development and testing:</p> <pre><code>python ralph_orchestrator.py \\\n  --agent q \\\n  --max-iterations 10 \\\n  --max-cost 1.0 \\\n  --verbose \\\n  --checkpoint-interval 1 \\\n  --metrics-interval 1\n</code></pre>"},{"location":"guide/configuration/#production-profile","title":"Production Profile","text":"<p>For production workloads:</p> <pre><code>python ralph_orchestrator.py \\\n  --agent claude \\\n  --max-iterations 100 \\\n  --max-runtime 14400 \\\n  --max-tokens 1000000 \\\n  --max-cost 50.0 \\\n  --checkpoint-interval 5 \\\n  --metrics-interval 10\n</code></pre>"},{"location":"guide/configuration/#budget-profile","title":"Budget Profile","text":"<p>For cost-sensitive operations:</p> <pre><code>python ralph_orchestrator.py \\\n  --agent q \\\n  --max-tokens 50000 \\\n  --max-cost 2.0 \\\n  --context-window 50000 \\\n  --context-threshold 0.7\n</code></pre>"},{"location":"guide/configuration/#high-performance-profile","title":"High-Performance Profile","text":"<p>For complex, resource-intensive tasks:</p> <pre><code>python ralph_orchestrator.py \\\n  --agent claude \\\n  --max-iterations 500 \\\n  --max-runtime 86400 \\\n  --max-tokens 5000000 \\\n  --max-cost 500.0 \\\n  --context-window 500000 \\\n  --checkpoint-interval 10\n</code></pre>"},{"location":"guide/configuration/#configuration-best-practices","title":"Configuration Best Practices","text":""},{"location":"guide/configuration/#1-start-conservative","title":"1. Start Conservative","text":"<p>Begin with lower limits and increase as needed:</p> <pre><code># Start small\npython ralph_orchestrator.py --max-iterations 5 --max-cost 1.0\n\n# Increase if needed\npython ralph_orchestrator.py --max-iterations 50 --max-cost 10.0\n</code></pre>"},{"location":"guide/configuration/#2-use-dry-run","title":"2. Use Dry Run","text":"<p>Always test configuration before production:</p> <pre><code>python ralph_orchestrator.py --dry-run --verbose\n</code></pre>"},{"location":"guide/configuration/#3-monitor-metrics","title":"3. Monitor Metrics","text":"<p>Enable metrics for production workloads:</p> <pre><code>python ralph_orchestrator.py --metrics-interval 5 --verbose\n</code></pre>"},{"location":"guide/configuration/#4-set-appropriate-limits","title":"4. Set Appropriate Limits","text":"<p>Choose limits based on task complexity:</p> <ul> <li>Simple tasks: 10-20 iterations, $1-5 cost</li> <li>Medium tasks: 50-100 iterations, $10-25 cost</li> <li>Complex tasks: 100-500 iterations, $50-200 cost</li> </ul>"},{"location":"guide/configuration/#5-checkpoint-frequently","title":"5. Checkpoint Frequently","text":"<p>For long-running tasks, checkpoint often:</p> <pre><code>python ralph_orchestrator.py --checkpoint-interval 3\n</code></pre>"},{"location":"guide/configuration/#environment-specific-configuration","title":"Environment-Specific Configuration","text":""},{"location":"guide/configuration/#cicd-pipelines","title":"CI/CD Pipelines","text":"<pre><code>python ralph_orchestrator.py \\\n  --agent auto \\\n  --max-iterations 50 \\\n  --max-runtime 3600 \\\n  --no-git \\\n  --metrics-interval 10\n</code></pre>"},{"location":"guide/configuration/#docker-containers","title":"Docker Containers","text":"<pre><code>ENV RALPH_AGENT=claude\nENV RALPH_MAX_COST=25.0\nCMD [\"python\", \"ralph_orchestrator.py\", \"--no-git\", \"--max-runtime\", \"7200\"]\n</code></pre>"},{"location":"guide/configuration/#kubernetes","title":"Kubernetes","text":"<pre><code>apiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: ralph-config\ndata:\n  RALPH_AGENT: \"claude\"\n  RALPH_MAX_COST: \"50.0\"\n  RALPH_MAX_ITERATIONS: \"100\"\n</code></pre>"},{"location":"guide/configuration/#troubleshooting-configuration","title":"Troubleshooting Configuration","text":""},{"location":"guide/configuration/#common-issues","title":"Common Issues","text":"<ol> <li>Agent not found</li> <li> <p>Solution: Check agent installation with <code>--agent auto</code></p> </li> <li> <p>Exceeding cost limits</p> </li> <li> <p>Solution: Increase <code>--max-cost</code> or use cheaper agent</p> </li> <li> <p>Context overflow</p> </li> <li> <p>Solution: Decrease <code>--context-threshold</code> or increase <code>--context-window</code></p> </li> <li> <p>Slow performance</p> </li> <li>Solution: Increase <code>--checkpoint-interval</code> and <code>--metrics-interval</code></li> </ol>"},{"location":"guide/configuration/#debug-commands","title":"Debug Commands","text":"<pre><code># Check configuration\npython ralph_orchestrator.py --dry-run --verbose\n\n# List available agents\npython ralph_orchestrator.py --agent auto --dry-run\n\n# Test with minimal configuration\npython ralph_orchestrator.py --max-iterations 1 --verbose\n</code></pre>"},{"location":"guide/configuration/#configuration-reference","title":"Configuration Reference","text":"<p>For a complete list of all configuration options, run:</p> <pre><code>python ralph_orchestrator.py --help\n</code></pre>"},{"location":"guide/configuration/#next-steps","title":"Next Steps","text":"<ul> <li>Learn about AI Agents and their capabilities</li> <li>Understand Prompt Engineering for better results</li> <li>Explore Cost Management strategies</li> <li>Set up Checkpointing for recovery</li> </ul>"},{"location":"guide/cost-management/","title":"Cost Management Guide","text":"<p>Effective cost management is crucial when running AI orchestration at scale. This guide helps you optimize spending while maintaining task quality.</p>"},{"location":"guide/cost-management/#understanding-costs","title":"Understanding Costs","text":""},{"location":"guide/cost-management/#token-pricing","title":"Token Pricing","text":"<p>Current pricing per million tokens:</p> Agent Input Cost Output Cost Avg Cost/Task Claude $3.00 $15.00 $5-50 Q Chat $0.50 $1.50 $1-10 Gemini $0.50 $1.50 $1-10"},{"location":"guide/cost-management/#cost-calculation","title":"Cost Calculation","text":"<pre><code>total_cost = (input_tokens / 1_000_000 * input_price) + \n             (output_tokens / 1_000_000 * output_price)\n</code></pre> <p>Example: - Task uses 100K input tokens, 50K output tokens - With Claude: (0.1 \u00d7 $3) + (0.05 \u00d7 $15) = $1.05 - With Q Chat: (0.1 \u00d7 $0.50) + (0.05 \u00d7 $1.50) = $0.125</p>"},{"location":"guide/cost-management/#cost-control-mechanisms","title":"Cost Control Mechanisms","text":""},{"location":"guide/cost-management/#1-hard-limits","title":"1. Hard Limits","text":"<p>Set maximum spending caps:</p> <pre><code># Strict $10 limit\npython ralph_orchestrator.py --max-cost 10.0\n\n# Conservative token limit\npython ralph_orchestrator.py --max-tokens 100000\n</code></pre>"},{"location":"guide/cost-management/#2-context-management","title":"2. Context Management","text":"<p>Reduce token usage through smart context handling:</p> <pre><code># Aggressive context management\npython ralph_orchestrator.py \\\n  --context-window 50000 \\\n  --context-threshold 0.6  # Summarize at 60% full\n</code></pre>"},{"location":"guide/cost-management/#3-agent-selection","title":"3. Agent Selection","text":"<p>Choose cost-effective agents:</p> <pre><code># Development: Use cheaper agents\npython ralph_orchestrator.py --agent q --max-cost 5.0\n\n# Production: Use quality agents with limits\npython ralph_orchestrator.py --agent claude --max-cost 50.0\n</code></pre>"},{"location":"guide/cost-management/#optimization-strategies","title":"Optimization Strategies","text":""},{"location":"guide/cost-management/#1-tiered-agent-strategy","title":"1. Tiered Agent Strategy","text":"<p>Use different agents for different task phases:</p> <pre><code># Phase 1: Research with Q (cheap)\necho \"Research the problem\" &gt; research.md\npython ralph_orchestrator.py --agent q --prompt research.md --max-cost 2.0\n\n# Phase 2: Implementation with Claude (quality)\necho \"Implement the solution\" &gt; implement.md\npython ralph_orchestrator.py --agent claude --prompt implement.md --max-cost 20.0\n\n# Phase 3: Testing with Q (cheap)\necho \"Test the solution\" &gt; test.md\npython ralph_orchestrator.py --agent q --prompt test.md --max-cost 2.0\n</code></pre>"},{"location":"guide/cost-management/#2-prompt-optimization","title":"2. Prompt Optimization","text":"<p>Reduce token usage through efficient prompts:</p>"},{"location":"guide/cost-management/#before-expensive","title":"Before (Expensive)","text":"<pre><code>Please create a comprehensive web application with the following features:\n- User authentication system with registration, login, password reset\n- Dashboard with charts and graphs\n- API with full CRUD operations\n- Complete test suite\n- Detailed documentation\n[... 5000 tokens of requirements ...]\n</code></pre>"},{"location":"guide/cost-management/#after-optimized","title":"After (Optimized)","text":"<pre><code>Build user auth API:\n- Register/login endpoints\n- JWT tokens\n- PostgreSQL storage\n- Basic tests\nSee spec.md for details.\n</code></pre>"},{"location":"guide/cost-management/#3-context-window-management","title":"3. Context Window Management","text":""},{"location":"guide/cost-management/#automatic-summarization","title":"Automatic Summarization","text":"<pre><code># Trigger summarization early to save tokens\npython ralph_orchestrator.py \\\n  --context-window 100000 \\\n  --context-threshold 0.5  # Summarize at 50%\n</code></pre>"},{"location":"guide/cost-management/#manual-context-control","title":"Manual Context Control","text":"<pre><code>## Context Management\nWhen context reaches 50%, summarize:\n- Keep only essential information\n- Remove completed task details\n- Compress verbose outputs\n</code></pre>"},{"location":"guide/cost-management/#4-iteration-optimization","title":"4. Iteration Optimization","text":"<p>Fewer, smarter iterations save money:</p> <pre><code># Many quick iterations (expensive)\npython ralph_orchestrator.py --max-iterations 100  # \u274c\n\n# Fewer, focused iterations (economical)\npython ralph_orchestrator.py --max-iterations 20   # \u2705\n</code></pre>"},{"location":"guide/cost-management/#cost-monitoring","title":"Cost Monitoring","text":""},{"location":"guide/cost-management/#real-time-tracking","title":"Real-time Tracking","text":"<p>Monitor costs during execution:</p> <pre><code># Verbose cost reporting\npython ralph_orchestrator.py \\\n  --verbose \\\n  --metrics-interval 1\n</code></pre> <p>Output: <pre><code>[INFO] Iteration 5: Tokens: 25,000 | Cost: $1.25 | Remaining: $48.75\n</code></pre></p>"},{"location":"guide/cost-management/#cost-reports","title":"Cost Reports","text":"<p>Access detailed cost breakdowns:</p> <pre><code>import json\nfrom pathlib import Path\n\n# Load metrics\nmetrics_dir = Path('.agent/metrics')\ntotal_cost = 0\n\nfor metric_file in metrics_dir.glob('metrics_*.json'):\n    with open(metric_file) as f:\n        data = json.load(f)\n        total_cost += data.get('cost', 0)\n\nprint(f\"Total cost: ${total_cost:.2f}\")\n</code></pre>"},{"location":"guide/cost-management/#cost-dashboards","title":"Cost Dashboards","text":"<p>Create monitoring dashboards:</p> <pre><code>#!/usr/bin/env python3\nimport json\nimport matplotlib.pyplot as plt\nfrom pathlib import Path\n\ncosts = []\niterations = []\n\nfor metric_file in sorted(Path('.agent/metrics').glob('*.json')):\n    with open(metric_file) as f:\n        data = json.load(f)\n        costs.append(data.get('total_cost', 0))\n        iterations.append(data.get('iteration', 0))\n\nplt.plot(iterations, costs)\nplt.xlabel('Iteration')\nplt.ylabel('Cumulative Cost ($)')\nplt.title('Ralph Orchestrator Cost Progression')\nplt.savefig('cost_report.png')\n</code></pre>"},{"location":"guide/cost-management/#budget-planning","title":"Budget Planning","text":""},{"location":"guide/cost-management/#task-cost-estimation","title":"Task Cost Estimation","text":"Task Type Complexity Recommended Budget Agent Simple Script Low $0.50 - $2 Q Chat Web API Medium $5 - $20 Gemini/Claude Full Application High $20 - $100 Claude Data Analysis Medium $5 - $15 Gemini Documentation Low-Medium $2 - $10 Q/Claude Debugging Variable $5 - $50 Claude"},{"location":"guide/cost-management/#monthly-budget-planning","title":"Monthly Budget Planning","text":"<pre><code># Calculate monthly budget needs\ntasks_per_month = 50\navg_cost_per_task = 10.0\nsafety_margin = 1.5\n\nmonthly_budget = tasks_per_month * avg_cost_per_task * safety_margin\nprint(f\"Recommended monthly budget: ${monthly_budget}\")\n</code></pre>"},{"location":"guide/cost-management/#cost-optimization-profiles","title":"Cost Optimization Profiles","text":""},{"location":"guide/cost-management/#minimal-cost-profile","title":"Minimal Cost Profile","text":"<p>Maximum savings, acceptable quality:</p> <pre><code>python ralph_orchestrator.py \\\n  --agent q \\\n  --max-tokens 50000 \\\n  --max-cost 2.0 \\\n  --context-window 30000 \\\n  --context-threshold 0.5 \\\n  --checkpoint-interval 10\n</code></pre>"},{"location":"guide/cost-management/#balanced-profile","title":"Balanced Profile","text":"<p>Good quality, reasonable cost:</p> <pre><code>python ralph_orchestrator.py \\\n  --agent gemini \\\n  --max-tokens 200000 \\\n  --max-cost 10.0 \\\n  --context-window 100000 \\\n  --context-threshold 0.7 \\\n  --checkpoint-interval 5\n</code></pre>"},{"location":"guide/cost-management/#quality-profile","title":"Quality Profile","text":"<p>Best results, controlled spending:</p> <pre><code>python ralph_orchestrator.py \\\n  --agent claude \\\n  --max-tokens 500000 \\\n  --max-cost 50.0 \\\n  --context-window 200000 \\\n  --context-threshold 0.8 \\\n  --checkpoint-interval 3\n</code></pre>"},{"location":"guide/cost-management/#advanced-cost-management","title":"Advanced Cost Management","text":""},{"location":"guide/cost-management/#dynamic-agent-switching","title":"Dynamic Agent Switching","text":"<p>Switch agents based on budget remaining:</p> <pre><code># Pseudo-code for dynamic switching\nif remaining_budget &gt; 20:\n    agent = \"claude\"\nelif remaining_budget &gt; 5:\n    agent = \"gemini\"\nelse:\n    agent = \"q\"\n</code></pre>"},{"location":"guide/cost-management/#cost-aware-prompts","title":"Cost-Aware Prompts","text":"<p>Include cost considerations in prompts:</p> <pre><code>## Budget Constraints\n- Maximum budget: $10\n- Optimize for efficiency\n- Skip non-essential features if approaching limit\n- Prioritize core functionality\n</code></pre>"},{"location":"guide/cost-management/#batch-processing","title":"Batch Processing","text":"<p>Combine multiple small tasks:</p> <pre><code># Inefficient: Multiple orchestrations\npython ralph_orchestrator.py --prompt task1.md  # $5\npython ralph_orchestrator.py --prompt task2.md  # $5\npython ralph_orchestrator.py --prompt task3.md  # $5\n# Total: $15\n\n# Efficient: Batched orchestration\ncat task1.md task2.md task3.md &gt; batch.md\npython ralph_orchestrator.py --prompt batch.md  # $10\n# Total: $10 (33% savings)\n</code></pre>"},{"location":"guide/cost-management/#cost-alerts","title":"Cost Alerts","text":""},{"location":"guide/cost-management/#setting-up-alerts","title":"Setting Up Alerts","text":"<pre><code>#!/bin/bash\n# cost_monitor.sh\n\nCOST_LIMIT=25.0\nCURRENT_COST=$(python -c \"\nimport json\nwith open('.agent/metrics/state_latest.json') as f:\n    print(json.load(f)['total_cost'])\n\")\n\nif (( $(echo \"$CURRENT_COST &gt; $COST_LIMIT\" | bc -l) )); then\n    echo \"ALERT: Cost exceeded $COST_LIMIT\" | mail -s \"Ralph Cost Alert\" admin@example.com\nfi\n</code></pre>"},{"location":"guide/cost-management/#automated-stops","title":"Automated Stops","text":"<p>Implement circuit breakers:</p> <pre><code># cost_breaker.py\nimport json\nimport sys\n\nwith open('.agent/metrics/state_latest.json') as f:\n    state = json.load(f)\n\nif state['total_cost'] &gt; state['max_cost'] * 0.9:\n    print(\"WARNING: 90% of budget consumed\")\n    sys.exit(1)\n</code></pre>"},{"location":"guide/cost-management/#roi-analysis","title":"ROI Analysis","text":""},{"location":"guide/cost-management/#calculating-roi","title":"Calculating ROI","text":"<pre><code># ROI calculation\nhours_saved = 10  # Hours of manual work saved\nhourly_rate = 50  # Developer hourly rate\nai_cost = 25  # Cost of AI orchestration\n\nvalue_created = hours_saved * hourly_rate\nroi = (value_created - ai_cost) / ai_cost * 100\n\nprint(f\"Value created: ${value_created}\")\nprint(f\"AI cost: ${ai_cost}\")\nprint(f\"ROI: {roi:.1f}%\")\n</code></pre>"},{"location":"guide/cost-management/#cost-benefit-matrix","title":"Cost-Benefit Matrix","text":"Task Manual Hours Manual Cost AI Cost Savings API Development 40h $2000 $50 $1950 Documentation 20h $1000 $20 $980 Testing Suite 30h $1500 $30 $1470 Bug Fixing 10h $500 $25 $475"},{"location":"guide/cost-management/#best-practices","title":"Best Practices","text":""},{"location":"guide/cost-management/#1-start-small","title":"1. Start Small","text":"<p>Test with minimal budgets first:</p> <pre><code># Test run\npython ralph_orchestrator.py --max-cost 1.0 --max-iterations 5\n\n# Scale up if successful\npython ralph_orchestrator.py --max-cost 10.0 --max-iterations 50\n</code></pre>"},{"location":"guide/cost-management/#2-monitor-continuously","title":"2. Monitor Continuously","text":"<p>Track costs in real-time:</p> <pre><code># Terminal 1: Run orchestration\npython ralph_orchestrator.py --verbose\n\n# Terminal 2: Monitor costs\nwatch -n 5 'tail -n 20 .agent/metrics/state_latest.json'\n</code></pre>"},{"location":"guide/cost-management/#3-optimize-iteratively","title":"3. Optimize Iteratively","text":"<ul> <li>Analyze cost reports</li> <li>Identify expensive operations</li> <li>Refine prompts and settings</li> <li>Test optimizations</li> </ul>"},{"location":"guide/cost-management/#4-set-realistic-budgets","title":"4. Set Realistic Budgets","text":"<ul> <li>Development: 50% of production budget</li> <li>Testing: 25% of production budget</li> <li>Production: Full budget with safety margin</li> </ul>"},{"location":"guide/cost-management/#5-document-costs","title":"5. Document Costs","text":"<p>Keep records for analysis:</p> <pre><code># Save cost report after each run\npython ralph_orchestrator.py &amp;&amp; \\\n  cp .agent/metrics/state_latest.json \"reports/run_$(date +%Y%m%d_%H%M%S).json\"\n</code></pre>"},{"location":"guide/cost-management/#troubleshooting","title":"Troubleshooting","text":""},{"location":"guide/cost-management/#common-issues","title":"Common Issues","text":"<ol> <li>Unexpected high costs</li> <li>Check token usage in metrics</li> <li>Review prompt efficiency</li> <li> <p>Verify context settings</p> </li> <li> <p>Budget exceeded quickly</p> </li> <li>Lower context window</li> <li>Increase summarization threshold</li> <li> <p>Use cheaper agent</p> </li> <li> <p>Poor results with budget constraints</p> </li> <li>Increase budget slightly</li> <li>Optimize prompts</li> <li>Consider phased approach</li> </ol>"},{"location":"guide/cost-management/#next-steps","title":"Next Steps","text":"<ul> <li>Review Agent Selection for cost-effective choices</li> <li>Optimize Prompts for efficiency</li> <li>Configure Checkpointing to save progress</li> <li>Explore Examples for cost-optimized patterns</li> </ul>"},{"location":"guide/overview/","title":"Overview","text":""},{"location":"guide/overview/#what-is-ralph-orchestrator","title":"What is Ralph Orchestrator?","text":"<p>Ralph Orchestrator is a production-ready implementation of the Ralph Wiggum orchestration technique for AI agents. It provides a robust framework for running AI agents in a continuous loop until a task is completed, with enterprise-grade safety, monitoring, and cost controls.</p> <p>The system is named after Ralph Wiggum from The Simpsons, embodying the philosophy of persistent iteration: \"Me fail English? That's unpossible!\" - just keep trying until you succeed.</p>"},{"location":"guide/overview/#key-concepts","title":"Key Concepts","text":""},{"location":"guide/overview/#the-ralph-wiggum-technique","title":"The Ralph Wiggum Technique","text":"<p>The Ralph Wiggum technique is a simple yet powerful approach to AI orchestration:</p> <ol> <li>Give the AI a task via a prompt file</li> <li>Let it iterate continuously on the problem</li> <li>Monitor progress through checkpoints and metrics</li> <li>Stop when complete or when limits are reached</li> </ol> <p>This approach leverages the AI's ability to self-correct and improve through multiple iterations, similar to how humans refine their work through multiple drafts.</p>"},{"location":"guide/overview/#core-components","title":"Core Components","text":"<pre><code>graph TB\n    A[Prompt File] --&gt; B[Ralph Orchestrator]\n    B --&gt; C{AI Agent}\n    C --&gt; D[Claude]\n    C --&gt; E[Q Chat]\n    C --&gt; F[Gemini]\n    D --&gt; G[Execute Task]\n    E --&gt; G\n    F --&gt; G\n    G --&gt; H{Task Complete?}\n    H --&gt;|No| B\n    H --&gt;|Yes| I[End]\n    B --&gt; J[Checkpointing]\n    B --&gt; K[Metrics]\n    B --&gt; L[Cost Control]</code></pre>"},{"location":"guide/overview/#how-it-works","title":"How It Works","text":""},{"location":"guide/overview/#1-initialization-phase","title":"1. Initialization Phase","text":"<p>When you start Ralph Orchestrator, it:</p> <ul> <li>Validates the prompt file for security</li> <li>Detects available AI agents</li> <li>Sets up monitoring and metrics collection</li> <li>Creates working directories for checkpoints</li> <li>Initializes cost and token tracking</li> </ul>"},{"location":"guide/overview/#2-iteration-loop","title":"2. Iteration Loop","text":"<p>The main orchestration loop:</p> <ol> <li>Pre-flight checks: Verify token/cost limits haven't been exceeded</li> <li>Context management: Check if context window needs summarization</li> <li>Agent execution: Run the selected AI agent with the prompt</li> <li>Response processing: Capture and analyze the agent's output</li> <li>Metrics collection: Track tokens, costs, and performance</li> <li>Completion check: Look for the <code>TASK_COMPLETE</code> marker</li> <li>Checkpoint: Save state at configured intervals</li> <li>Repeat: Continue until task is complete or limits are reached</li> </ol>"},{"location":"guide/overview/#3-safety-mechanisms","title":"3. Safety Mechanisms","text":"<p>Multiple layers of protection ensure safe operation:</p> <ul> <li>Input validation: Sanitizes prompts to prevent injection attacks</li> <li>Resource limits: Enforces token, cost, and runtime boundaries</li> <li>Context overflow: Automatically summarizes when approaching limits</li> <li>Graceful shutdown: Handles interrupts and saves state</li> <li>Error recovery: Retries with exponential backoff</li> </ul>"},{"location":"guide/overview/#4-completion","title":"4. Completion","text":"<p>When the task completes or limits are reached:</p> <ul> <li>Final metrics are saved</li> <li>State is persisted for analysis</li> <li>Usage statistics are reported</li> <li>Detailed logs are exported</li> </ul>"},{"location":"guide/overview/#use-cases","title":"Use Cases","text":"<p>Ralph Orchestrator excels at:</p>"},{"location":"guide/overview/#software-development","title":"Software Development","text":"<ul> <li>Writing complete applications from specifications</li> <li>Refactoring large codebases</li> <li>Implementing complex features iteratively</li> <li>Debugging difficult issues</li> </ul>"},{"location":"guide/overview/#content-creation","title":"Content Creation","text":"<ul> <li>Writing comprehensive documentation</li> <li>Generating test suites</li> <li>Creating API specifications</li> <li>Developing training materials</li> </ul>"},{"location":"guide/overview/#data-processing","title":"Data Processing","text":"<ul> <li>Analyzing large datasets</li> <li>Generating reports</li> <li>Data transformation pipelines</li> <li>ETL operations</li> </ul>"},{"location":"guide/overview/#research-analysis","title":"Research &amp; Analysis","text":"<ul> <li>Literature reviews</li> <li>Market research</li> <li>Competitive analysis</li> <li>Technical investigations</li> </ul>"},{"location":"guide/overview/#benefits","title":"Benefits","text":""},{"location":"guide/overview/#productivity","title":"\ud83d\ude80 Productivity","text":"<ul> <li>Automate complex, multi-step tasks</li> <li>Reduce human intervention</li> <li>Parallelize work across multiple agents</li> <li>24/7 operation capability</li> </ul>"},{"location":"guide/overview/#cost-management","title":"\ud83d\udcb0 Cost Management","text":"<ul> <li>Real-time cost tracking</li> <li>Configurable spending limits</li> <li>Per-agent pricing models</li> <li>Token usage optimization</li> </ul>"},{"location":"guide/overview/#security","title":"\ud83d\udd12 Security","text":"<ul> <li>Input sanitization</li> <li>Command injection prevention</li> <li>Path traversal protection</li> <li>Audit trails</li> </ul>"},{"location":"guide/overview/#observability","title":"\ud83d\udcca Observability","text":"<ul> <li>Detailed metrics collection</li> <li>Performance monitoring</li> <li>Success/failure tracking</li> <li>Resource utilization</li> </ul>"},{"location":"guide/overview/#reliability","title":"\ud83d\udd04 Reliability","text":"<ul> <li>Automatic retries</li> <li>State persistence</li> <li>Checkpoint recovery</li> <li>Graceful degradation</li> </ul>"},{"location":"guide/overview/#architecture-overview","title":"Architecture Overview","text":"<pre><code>graph LR\n    subgraph \"Input Layer\"\n        A[CLI Arguments]\n        B[Prompt File]\n        C[Configuration]\n    end\n\n    subgraph \"Orchestration Core\"\n        D[Ralph Orchestrator]\n        E[Agent Manager]\n        F[Context Manager]\n        G[Metrics Collector]\n    end\n\n    subgraph \"AI Agents\"\n        H[Claude]\n        I[Q Chat]\n        J[Gemini]\n    end\n\n    subgraph \"Persistence\"\n        K[Git Checkpoints]\n        L[Prompt Archives]\n        M[Metrics Store]\n    end\n\n    A --&gt; D\n    B --&gt; D\n    C --&gt; D\n    D --&gt; E\n    E --&gt; H\n    E --&gt; I\n    E --&gt; J\n    D --&gt; F\n    D --&gt; G\n    D --&gt; K\n    D --&gt; L\n    G --&gt; M</code></pre>"},{"location":"guide/overview/#getting-started","title":"Getting Started","text":"<p>To start using Ralph Orchestrator:</p> <ol> <li>Install the tool and at least one AI agent</li> <li>Create a prompt file with your task</li> <li>Run the orchestrator with appropriate limits</li> <li>Monitor progress through logs and metrics</li> <li>Retrieve results when complete</li> </ol> <p>See the Quick Start guide for detailed instructions.</p>"},{"location":"guide/overview/#next-steps","title":"Next Steps","text":"<ul> <li>Learn about Configuration options</li> <li>Understand Agent selection and capabilities</li> <li>Master Prompt engineering for best results</li> <li>Explore Cost Management strategies</li> <li>Set up Checkpointing for recovery</li> </ul>"},{"location":"guide/prompts/","title":"Prompt Engineering Guide","text":"<p>Effective prompt engineering is crucial for successful Ralph Orchestrator tasks. This guide covers best practices, patterns, and techniques for writing prompts that get results.</p>"},{"location":"guide/prompts/#prompt-file-basics","title":"Prompt File Basics","text":""},{"location":"guide/prompts/#file-format","title":"File Format","text":"<p>Ralph Orchestrator uses Markdown files for prompts:</p> <pre><code># Task Title\n\n## Objective\nClear description of what needs to be accomplished.\n\n## Requirements\n- Specific requirement 1\n- Specific requirement 2\n\n## Success Criteria\nThe task is complete when:\n- Criterion 1 is met\n- Criterion 2 is met\n\nWhen finished, add \"TASK_COMPLETE\" to this file.\n</code></pre>"},{"location":"guide/prompts/#file-location","title":"File Location","text":"<p>Default prompt file: <code>PROMPT.md</code></p> <p>Custom location: <pre><code>python ralph_orchestrator.py --prompt path/to/task.md\n</code></pre></p>"},{"location":"guide/prompts/#prompt-structure","title":"Prompt Structure","text":""},{"location":"guide/prompts/#essential-components","title":"Essential Components","text":"<p>Every prompt should include:</p> <ol> <li>Clear Objective</li> <li>Specific Requirements</li> <li>Success Criteria</li> <li>Completion Marker</li> </ol>"},{"location":"guide/prompts/#template","title":"Template","text":"<pre><code># [Task Name]\n\n## Objective\n[One or two sentences describing the goal]\n\n## Context\n[Background information the agent needs]\n\n## Requirements\n1. [Specific requirement]\n2. [Specific requirement]\n3. [Specific requirement]\n\n## Constraints\n- [Limitation or boundary]\n- [Technical constraint]\n- [Resource constraint]\n\n## Success Criteria\nThe task is complete when:\n- [ ] [Measurable outcome]\n- [ ] [Verifiable result]\n- [ ] [Specific deliverable]\n\n## Notes\n[Additional guidance or hints]\n\n---\nWhen the task is fully complete, add \"TASK_COMPLETE\" to this file.\n</code></pre>"},{"location":"guide/prompts/#prompt-patterns","title":"Prompt Patterns","text":""},{"location":"guide/prompts/#1-software-development-pattern","title":"1. Software Development Pattern","text":"<pre><code># Build Web API\n\n## Objective\nCreate a RESTful API for user management with authentication.\n\n## Requirements\n1. Implement user CRUD operations\n2. Add JWT authentication\n3. Include input validation\n4. Write comprehensive tests\n5. Create API documentation\n\n## Technical Specifications\n- Framework: FastAPI\n- Database: PostgreSQL\n- Authentication: JWT tokens\n- Testing: pytest\n\n## Endpoints\n- POST /auth/register\n- POST /auth/login\n- GET /users\n- GET /users/{id}\n- PUT /users/{id}\n- DELETE /users/{id}\n\n## Success Criteria\n- [ ] All endpoints functional\n- [ ] Tests passing with &gt;80% coverage\n- [ ] API documentation generated\n- [ ] Authentication working\n\nWhen complete, add \"TASK_COMPLETE\" to this file.\n</code></pre>"},{"location":"guide/prompts/#2-documentation-pattern","title":"2. Documentation Pattern","text":"<p><pre><code># Create User Documentation\n\n## Objective\nWrite comprehensive user documentation for the application.\n\n## Requirements\n1. Installation guide\n2. Configuration reference\n3. Usage examples\n4. Troubleshooting section\n5. FAQ\n\n## Structure\n</code></pre> docs/ \u251c\u2500\u2500 getting-started.md \u251c\u2500\u2500 installation.md \u251c\u2500\u2500 configuration.md \u251c\u2500\u2500 usage/ \u2502   \u251c\u2500\u2500 basic.md \u2502   \u2514\u2500\u2500 advanced.md \u251c\u2500\u2500 troubleshooting.md \u2514\u2500\u2500 faq.md <pre><code>## Style Guide\n- Use clear, concise language\n- Include code examples\n- Add screenshots where helpful\n- Follow Markdown best practices\n\n## Success Criteria\n- [ ] All sections complete\n- [ ] Examples tested and working\n- [ ] Reviewed for clarity\n- [ ] No broken links\n\nAdd \"TASK_COMPLETE\" when finished.\n</code></pre></p>"},{"location":"guide/prompts/#3-data-analysis-pattern","title":"3. Data Analysis Pattern","text":"<pre><code># Analyze Sales Data\n\n## Objective\nAnalyze Q4 sales data and generate insights report.\n\n## Data Sources\n- sales_data.csv\n- customer_demographics.json\n- product_catalog.xlsx\n\n## Analysis Requirements\n1. Revenue trends by month\n2. Top performing products\n3. Customer segmentation\n4. Regional performance\n5. Year-over-year comparison\n\n## Deliverables\n1. Python analysis script\n2. Jupyter notebook with visualizations\n3. Executive summary (PDF)\n4. Raw data exports\n\n## Success Criteria\n- [ ] All analyses complete\n- [ ] Visualizations created\n- [ ] Insights documented\n- [ ] Code reproducible\n\nMark \"TASK_COMPLETE\" when done.\n</code></pre>"},{"location":"guide/prompts/#4-debugging-pattern","title":"4. Debugging Pattern","text":"<pre><code># Debug Application Issue\n\n## Problem Description\nUsers report application crashes when uploading large files.\n\n## Symptoms\n- Crash occurs with files &gt;100MB\n- Error: \"Memory allocation failed\"\n- Affects 30% of users\n\n## Investigation Steps\n1. Reproduce the issue\n2. Analyze memory usage\n3. Review upload handling code\n4. Check server resources\n5. Examine error logs\n\n## Required Fixes\n- Identify root cause\n- Implement solution\n- Add error handling\n- Write regression tests\n- Update documentation\n\n## Success Criteria\n- [ ] Issue reproduced\n- [ ] Root cause identified\n- [ ] Fix implemented\n- [ ] Tests passing\n- [ ] No regressions\n\nAdd \"TASK_COMPLETE\" after verification.\n</code></pre>"},{"location":"guide/prompts/#best-practices","title":"Best Practices","text":""},{"location":"guide/prompts/#1-be-specific","title":"1. Be Specific","text":"<p>\u274c Bad: <pre><code>Build a website\n</code></pre></p> <p>\u2705 Good: <pre><code>Build a responsive e-commerce website using React and Node.js with:\n- Product catalog with search\n- Shopping cart functionality\n- Stripe payment integration\n- User authentication\n- Order tracking\n</code></pre></p>"},{"location":"guide/prompts/#2-provide-context","title":"2. Provide Context","text":"<p>\u274c Bad: <pre><code>Fix the bug\n</code></pre></p> <p>\u2705 Good: <pre><code>Fix the memory leak in the image processing module that occurs when:\n- Processing images larger than 10MB\n- Multiple images are processed simultaneously\n- The cleanup function in ImageProcessor.process() may not be releasing buffers\n</code></pre></p>"},{"location":"guide/prompts/#3-define-success-clearly","title":"3. Define Success Clearly","text":"<p>\u274c Bad: <pre><code>Make it work better\n</code></pre></p> <p>\u2705 Good: <pre><code>## Success Criteria\n- Response time &lt; 200ms for 95% of requests\n- Memory usage stays below 512MB\n- All unit tests pass\n- No errors in 24-hour stress test\n</code></pre></p>"},{"location":"guide/prompts/#4-include-examples","title":"4. Include Examples","text":"<pre><code>## Example Input/Output\n\nInput:\n```json\n{\n  \"user_id\": 123,\n  \"action\": \"purchase\",\n  \"items\": [\"SKU-001\", \"SKU-002\"]\n}\n</code></pre> <p>Expected Output: <pre><code>{\n  \"order_id\": \"ORD-789\",\n  \"status\": \"confirmed\",\n  \"total\": 99.99,\n  \"estimated_delivery\": \"2024-01-15\"\n}\n</code></pre> <pre><code>### 5. Specify Constraints\n\n```markdown\n## Constraints\n- Must be Python 3.8+ compatible\n- Cannot use external APIs\n- Must complete in under 5 seconds\n- Memory usage &lt; 1GB\n- Must follow PEP 8 style guide\n</code></pre></p>"},{"location":"guide/prompts/#iterative-prompts","title":"Iterative Prompts","text":"<p>Ralph Orchestrator modifies the prompt file during execution. Design prompts that support iteration:</p>"},{"location":"guide/prompts/#self-documenting-progress","title":"Self-Documenting Progress","text":"<pre><code>## Progress Log\n&lt;!-- Agent will update this section --&gt;\n- [ ] Step 1: Setup environment\n- [ ] Step 2: Implement core logic\n- [ ] Step 3: Add tests\n- [ ] Step 4: Documentation\n\n## Current Status\n&lt;!-- Agent updates this --&gt;\nWorking on: [current task]\nCompleted: [list of completed items]\nNext: [planned next step]\n</code></pre>"},{"location":"guide/prompts/#checkpoint-markers","title":"Checkpoint Markers","text":"<pre><code>## Checkpoints\n- [ ] CHECKPOINT_1: Basic structure complete\n- [ ] CHECKPOINT_2: Core functionality working\n- [ ] CHECKPOINT_3: Tests passing\n- [ ] CHECKPOINT_4: Documentation complete\n- [ ] TASK_COMPLETE\n</code></pre>"},{"location":"guide/prompts/#advanced-techniques","title":"Advanced Techniques","text":""},{"location":"guide/prompts/#1-multi-phase-prompts","title":"1. Multi-Phase Prompts","text":"<pre><code># Phase 1: Research\nResearch existing solutions and document findings.\n\n&lt;!-- After Phase 1 complete, update prompt for Phase 2 --&gt;\n\n# Phase 2: Implementation\nBased on research, implement the solution.\n\n# Phase 3: Testing\nComprehensive testing and validation.\n</code></pre>"},{"location":"guide/prompts/#2-conditional-instructions","title":"2. Conditional Instructions","text":"<pre><code>## Implementation\n\nIf using Python:\n- Use type hints\n- Follow PEP 8\n- Use pytest for testing\n\nIf using JavaScript:\n- Use TypeScript\n- Follow Airbnb style guide\n- Use Jest for testing\n</code></pre>"},{"location":"guide/prompts/#3-learning-prompts","title":"3. Learning Prompts","text":"<pre><code>## Approach\n1. First, try the simple solution\n2. If that doesn't work, research alternatives\n3. Document what was learned\n4. Implement the best solution\n\n## Document Learnings\n&lt;!-- Agent fills this during execution --&gt;\n- Attempted: [approach]\n- Result: [outcome]\n- Learning: [insight]\n</code></pre>"},{"location":"guide/prompts/#4-error-recovery","title":"4. Error Recovery","text":"<pre><code>## Error Handling\nIf you encounter errors:\n1. Document the error in this file\n2. Research the solution\n3. Try alternative approaches\n4. Update this prompt with findings\n\n## Error Log\n&lt;!-- Agent updates this --&gt;\n</code></pre>"},{"location":"guide/prompts/#prompt-security","title":"Prompt Security","text":""},{"location":"guide/prompts/#sanitization","title":"Sanitization","text":"<p>Ralph Orchestrator automatically sanitizes prompts for: - Command injection attempts - Path traversal attacks - Malicious patterns</p>"},{"location":"guide/prompts/#safe-patterns","title":"Safe Patterns","text":"<pre><code>## File Operations\nWork only in the ./workspace directory\nDo not modify system files\nCreate backups before changes\n</code></pre>"},{"location":"guide/prompts/#size-limits","title":"Size Limits","text":"<p>Default maximum prompt size: 10MB</p> <p>Adjust if needed: <pre><code>python ralph_orchestrator.py --max-prompt-size 20971520  # 20MB\n</code></pre></p>"},{"location":"guide/prompts/#testing-prompts","title":"Testing Prompts","text":""},{"location":"guide/prompts/#dry-run","title":"Dry Run","text":"<p>Test prompts without execution:</p> <pre><code>python ralph_orchestrator.py --dry-run --prompt test.md\n</code></pre>"},{"location":"guide/prompts/#limited-iterations","title":"Limited Iterations","text":"<p>Test with few iterations:</p> <pre><code>python ralph_orchestrator.py --max-iterations 3 --prompt test.md\n</code></pre>"},{"location":"guide/prompts/#verbose-mode","title":"Verbose Mode","text":"<p>Debug prompt processing:</p> <pre><code>python ralph_orchestrator.py --verbose --prompt test.md\n</code></pre>"},{"location":"guide/prompts/#common-pitfalls","title":"Common Pitfalls","text":""},{"location":"guide/prompts/#1-vague-instructions","title":"1. Vague Instructions","text":"<p>\u274c Avoid: - \"Make it good\" - \"Optimize everything\" - \"Fix all issues\"</p> <p>\u2705 Instead: - \"Achieve 95% test coverage\" - \"Reduce response time to &lt;100ms\" - \"Fix the memory leak in process_image()\"</p>"},{"location":"guide/prompts/#2-missing-completion-criteria","title":"2. Missing Completion Criteria","text":"<p>\u274c Avoid: Forgetting to specify when the task is done</p> <p>\u2705 Instead: Always include clear completion criteria and the TASK_COMPLETE marker</p>"},{"location":"guide/prompts/#3-overly-complex-prompts","title":"3. Overly Complex Prompts","text":"<p>\u274c Avoid: Single prompt with 50+ requirements</p> <p>\u2705 Instead: Break into phases or separate tasks</p>"},{"location":"guide/prompts/#4-no-examples","title":"4. No Examples","text":"<p>\u274c Avoid: Describing desired behavior without examples</p> <p>\u2705 Instead: Include input/output examples and edge cases</p>"},{"location":"guide/prompts/#prompt-library","title":"Prompt Library","text":""},{"location":"guide/prompts/#starter-templates","title":"Starter Templates","text":"<ol> <li>Web API Development</li> <li>CLI Tool Creation</li> <li>Data Analysis</li> <li>Documentation Writing</li> <li>Bug Fixing</li> <li>Testing Suite</li> </ol>"},{"location":"guide/prompts/#next-steps","title":"Next Steps","text":"<ul> <li>Explore Cost Management for efficient prompts</li> <li>Learn about Checkpointing for long tasks</li> <li>Review Agent Selection for optimal results</li> <li>See Examples for real-world prompts</li> </ul>"}]}